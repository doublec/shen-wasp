"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.<defprolog> (V809) (let Parse_shen.<predicate*> (shen.<predicate*> V809) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V818 V819) (cond ((and (cons? V819) (and (cons? (tl V819)) (= () (tl (tl V819))))) (simple-error (cn "prolog syntax error in " (shen.app V818 (cn " here:

 " (shen.app (shen.next-50 50 (hd V819)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V818 "
" shen.a))))))

(defun shen.next-50 (V826 V827) (cond ((= () V827) "") ((= 0 V826) "") ((cons? V827) (cn (shen.decons-string (hd V827)) (shen.next-50 (- V826 1) (tl V827)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V829) (cond ((and (cons? V829) (and (= cons (hd V829)) (and (cons? (tl V829)) (and (cons? (tl (tl V829))) (= () (tl (tl (tl V829)))))))) (shen.app (shen.eval-cons V829) " " shen.s)) (true (shen.app V829 " " shen.r))))

(defun shen.insert-predicate (V832 V833) (cond ((and (cons? V833) (and (cons? (tl V833)) (= () (tl (tl V833))))) (cons (cons V832 (hd V833)) (cons :- (tl V833)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V835) (if (cons? (hd V835)) (let Parse_X (shen.hdhd V835) (shen.pair (hd (shen.pair (shen.tlhd V835) (shen.hdtl V835))) Parse_X)) (fail)))

(defun shen.<clauses*> (V837) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V837) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V837) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V840) (let Parse_shen.<head*> (shen.<head*> V840) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (shen.hdhd Parse_shen.<head*>))) (let NewStream838 (shen.pair (shen.tlhd Parse_shen.<head*>) (shen.hdtl Parse_shen.<head*>)) (let Parse_shen.<body*> (shen.<body*> NewStream838) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail)))) (fail)) (fail))))

(defun shen.<head*> (V842) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V842) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V842) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V844) (if (cons? (hd V844)) (let Parse_X (shen.hdhd V844) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (shen.tlhd V844) (shen.hdtl V844))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V850) (cond ((and (cons? V850) (and (= cons (hd V850)) (and (cons? (tl V850)) (and (cons? (tl (tl V850))) (= () (tl (tl (tl V850)))))))) (and (shen.legitimate-term? (hd (tl V850))) (shen.legitimate-term? (hd (tl (tl V850)))))) ((and (cons? V850) (and (= mode (hd V850)) (and (cons? (tl V850)) (and (cons? (tl (tl V850))) (and (= + (hd (tl (tl V850)))) (= () (tl (tl (tl V850))))))))) (shen.legitimate-term? (hd (tl V850)))) ((and (cons? V850) (and (= mode (hd V850)) (and (cons? (tl V850)) (and (cons? (tl (tl V850))) (and (= - (hd (tl (tl V850)))) (= () (tl (tl (tl V850))))))))) (shen.legitimate-term? (hd (tl V850)))) ((cons? V850) false) (true true)))

(defun shen.eval-cons (V852) (cond ((and (cons? V852) (and (= cons (hd V852)) (and (cons? (tl V852)) (and (cons? (tl (tl V852))) (= () (tl (tl (tl V852)))))))) (cons (shen.eval-cons (hd (tl V852))) (shen.eval-cons (hd (tl (tl V852)))))) ((and (cons? V852) (and (= mode (hd V852)) (and (cons? (tl V852)) (and (cons? (tl (tl V852))) (= () (tl (tl (tl V852)))))))) (cons mode (cons (shen.eval-cons (hd (tl V852))) (tl (tl V852))))) (true V852)))

(defun shen.<body*> (V854) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V854) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V854) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V857) (let YaccParse (if (and (cons? (hd V857)) (= ! (shen.hdhd V857))) (let NewStream855 (shen.pair (shen.tlhd V857) (shen.hdtl V857)) (shen.pair (hd NewStream855) (cons cut (cons (intern "Throwcontrol") ())))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V857)) (let Parse_X (shen.hdhd V857) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V857) (shen.hdtl V857))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V859) (if (cons? (hd V859)) (let Parse_X (shen.hdhd V859) (if (= Parse_X ;) (shen.pair (hd (shen.pair (shen.tlhd V859) (shen.hdtl V859))) Parse_X) (fail))) (fail)))

(defun cut (V863 V864 V865) (let Result (thaw V865) (if (= Result false) V863 Result)))

(defun shen.insert_modes (V867) (cond ((and (cons? V867) (and (= mode (hd V867)) (and (cons? (tl V867)) (and (cons? (tl (tl V867))) (= () (tl (tl (tl V867)))))))) V867) ((= () V867) ()) ((cons? V867) (cons (cons mode (cons (hd V867) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V867)) (cons - ()))))) (true V867)))

(defun shen.s-prolog (V869) (map (lambda X (eval X)) (shen.prolog->shen V869)))

(defun shen.prolog->shen (V871) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V871)))))

(defun shen.s-prolog_clause (V873) (cond ((and (cons? V873) (and (cons? (tl V873)) (and (= :- (hd (tl V873))) (and (cons? (tl (tl V873))) (= () (tl (tl (tl V873)))))))) (cons (hd V873) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V873)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V875) (cond ((and (cons? V875) (and (cons? (tl V875)) (and (= :- (hd (tl V875))) (and (cons? (tl (tl V875))) (and (= () (tl (tl (tl V875)))) (trap-error (< (shen.complexity_head (hd V875)) (value shen.*maxcomplexity*)) (lambda _ false))))))) (cons V875 ())) ((and (cons? V875) (and (cons? (hd V875)) (and (cons? (tl V875)) (and (= :- (hd (tl V875))) (and (cons? (tl (tl V875))) (= () (tl (tl (tl V875))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V875))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V875)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V875)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V875)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V881) (cond ((cons? V881) (shen.safe-product (map (lambda X (shen.complexity X)) (tl V881)))) (true (shen.f_error shen.complexity_head))))

(defun shen.safe-multiply (V884 V885) (* V884 V885))

(defun shen.complexity (V894) (cond ((and (cons? V894) (and (= mode (hd V894)) (and (cons? (tl V894)) (and (cons? (hd (tl V894))) (and (= mode (hd (hd (tl V894)))) (and (cons? (tl (hd (tl V894)))) (and (cons? (tl (tl (hd (tl V894))))) (and (= () (tl (tl (tl (hd (tl V894)))))) (and (cons? (tl (tl V894))) (= () (tl (tl (tl V894))))))))))))) (shen.complexity (hd (tl V894)))) ((and (cons? V894) (and (= mode (hd V894)) (and (cons? (tl V894)) (and (cons? (hd (tl V894))) (and (cons? (tl (tl V894))) (and (= + (hd (tl (tl V894)))) (= () (tl (tl (tl V894)))))))))) (shen.safe-multiply 2 (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V894))) (tl (tl V894))))) (shen.complexity (cons mode (cons (tl (hd (tl V894))) (tl (tl V894)))))))) ((and (cons? V894) (and (= mode (hd V894)) (and (cons? (tl V894)) (and (cons? (hd (tl V894))) (and (cons? (tl (tl V894))) (and (= - (hd (tl (tl V894)))) (= () (tl (tl (tl V894)))))))))) (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V894))) (tl (tl V894))))) (shen.complexity (cons mode (cons (tl (hd (tl V894))) (tl (tl V894))))))) ((and (cons? V894) (and (= mode (hd V894)) (and (cons? (tl V894)) (and (cons? (tl (tl V894))) (and (= () (tl (tl (tl V894)))) (variable? (hd (tl V894)))))))) 1) ((and (cons? V894) (and (= mode (hd V894)) (and (cons? (tl V894)) (and (cons? (tl (tl V894))) (and (= + (hd (tl (tl V894)))) (= () (tl (tl (tl V894))))))))) 2) ((and (cons? V894) (and (= mode (hd V894)) (and (cons? (tl V894)) (and (cons? (tl (tl V894))) (and (= - (hd (tl (tl V894)))) (= () (tl (tl (tl V894))))))))) 1) (true (shen.complexity (cons mode (cons V894 (cons + ())))))))

(defun shen.safe-product (V896) (cond ((= () V896) 1) ((cons? V896) (shen.safe-multiply (hd V896) (shen.safe-product (tl V896)))) (true (shen.f_error shen.safe-product))))

(defun shen.s-prolog_literal (V898) (cond ((and (cons? V898) (and (= is (hd V898)) (and (cons? (tl V898)) (and (cons? (tl (tl V898))) (= () (tl (tl (tl V898)))))))) (cons bind (cons (hd (tl V898)) (cons (shen.insert-deref (hd (tl (tl V898))) ProcessN) ())))) ((and (cons? V898) (and (= when (hd V898)) (and (cons? (tl V898)) (= () (tl (tl V898)))))) (cons fwhen (cons (shen.insert-deref (hd (tl V898)) ProcessN) ()))) ((and (cons? V898) (and (= bind (hd V898)) (and (cons? (tl V898)) (and (cons? (tl (tl V898))) (= () (tl (tl (tl V898)))))))) (cons bind (cons (hd (tl V898)) (cons (shen.insert-lazyderef (hd (tl (tl V898))) ProcessN) ())))) ((and (cons? V898) (and (= fwhen (hd V898)) (and (cons? (tl V898)) (= () (tl (tl V898)))))) (cons fwhen (cons (shen.insert-lazyderef (hd (tl V898)) ProcessN) ()))) ((cons? V898) V898) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert-deref (V905 V906) (cond ((variable? V905) (cons shen.deref (cons V905 (cons V906 ())))) ((and (cons? V905) (and (= lambda (hd V905)) (and (cons? (tl V905)) (and (cons? (tl (tl V905))) (= () (tl (tl (tl V905)))))))) (cons lambda (cons (hd (tl V905)) (cons (shen.insert-deref (hd (tl (tl V905))) V906) ())))) ((and (cons? V905) (and (= let (hd V905)) (and (cons? (tl V905)) (and (cons? (tl (tl V905))) (and (cons? (tl (tl (tl V905)))) (= () (tl (tl (tl (tl V905)))))))))) (cons let (cons (hd (tl V905)) (cons (shen.insert-deref (hd (tl (tl V905))) V906) (cons (shen.insert-deref (hd (tl (tl (tl V905)))) V906) ()))))) ((cons? V905) (cons (shen.insert-deref (hd V905) V906) (shen.insert-deref (tl V905) V906))) (true V905)))

(defun shen.insert-lazyderef (V913 V914) (cond ((variable? V913) (cons shen.lazyderef (cons V913 (cons V914 ())))) ((and (cons? V913) (and (= lambda (hd V913)) (and (cons? (tl V913)) (and (cons? (tl (tl V913))) (= () (tl (tl (tl V913)))))))) (cons lambda (cons (hd (tl V913)) (cons (shen.insert-lazyderef (hd (tl (tl V913))) V914) ())))) ((and (cons? V913) (and (= let (hd V913)) (and (cons? (tl V913)) (and (cons? (tl (tl V913))) (and (cons? (tl (tl (tl V913)))) (= () (tl (tl (tl (tl V913)))))))))) (cons let (cons (hd (tl V913)) (cons (shen.insert-lazyderef (hd (tl (tl V913))) V914) (cons (shen.insert-lazyderef (hd (tl (tl (tl V913)))) V914) ()))))) ((cons? V913) (cons (shen.insert-lazyderef (hd V913) V914) (shen.insert-lazyderef (tl V913) V914))) (true V913)))

(defun shen.group_clauses (V916) (cond ((= () V916) ()) ((cons? V916) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V916) X)) V916) (let Rest (difference V916 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V921 V922) (cond ((= () V922) ()) ((cons? V922) (if (V921 (hd V922)) (cons (hd V922) (shen.collect V921 (tl V922))) (shen.collect V921 (tl V922)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V941 V942) (cond ((and (cons? V941) (and (cons? (hd V941)) (and (cons? V942) (cons? (hd V942))))) (= (hd (hd V941)) (hd (hd V942)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V944) (let F (shen.procedure_name V944) (let Shen (shen.clauses-to-shen F V944) Shen)))

(defun shen.procedure_name (V958) (cond ((and (cons? V958) (and (cons? (hd V958)) (cons? (hd (hd V958))))) (hd (hd (hd V958)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V961 V962) (let Linear (map (lambda X (shen.linearise-clause X)) V962) (let Arity (shen.prolog-aritycheck V961 (map (lambda X (head X)) V962)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V961 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V964) (cond ((not (shen.occurs? cut V964)) V964) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V964 ()))) ())))))))

(defun shen.catchpoint () (cons shen.catchpoint! (set shen.*catch* (+ 1 (value shen.*catch*)))))

(defun shen.cutpoint (V972 V973) (cond ((= V973 V972) false) (true V973)))

(defun shen.nest-disjunct (V975) (cond ((and (cons? V975) (= () (tl V975))) (hd V975)) ((cons? V975) (shen.lisp-or (hd V975) (shen.nest-disjunct (tl V975)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V978 V979) (cons let (cons Case (cons V978 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V979 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V984 V985) (cond ((and (cons? V985) (= () (tl V985))) (- (length (hd V985)) 1)) ((and (cons? V985) (cons? (tl V985))) (if (= (length (hd V985)) (length (hd (tl V985)))) (shen.prolog-aritycheck V984 (tl V985)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V984 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V987) (cond ((and (cons? V987) (and (cons? (tl V987)) (and (= :- (hd (tl V987))) (and (cons? (tl (tl V987))) (= () (tl (tl (tl V987)))))))) (let Linear (shen.linearise (cons (hd V987) (tl (tl V987)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V989) (cond ((and (cons? V989) (and (cons? (tl V989)) (= () (tl (tl V989))))) (cons (shen.explicit_modes (hd V989)) (cons :- (cons (shen.cf_help (hd (tl V989))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V991) (cond ((cons? V991) (cons (hd V991) (map (lambda X (shen.em_help X)) (tl V991)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V993) (cond ((and (cons? V993) (and (= mode (hd V993)) (and (cons? (tl V993)) (and (cons? (tl (tl V993))) (= () (tl (tl (tl V993)))))))) V993) (true (cons mode (cons V993 (cons + ()))))))

(defun shen.cf_help (V995) (cond ((and (cons? V995) (and (= where (hd V995)) (and (cons? (tl V995)) (and (cons? (hd (tl V995))) (and (= = (hd (hd (tl V995)))) (and (cons? (tl (hd (tl V995)))) (and (cons? (tl (tl (hd (tl V995))))) (and (= () (tl (tl (tl (hd (tl V995)))))) (and (cons? (tl (tl V995))) (= () (tl (tl (tl V995))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V995)))) (shen.cf_help (hd (tl (tl V995)))))) (true V995)))

(defun occurs-check (V1001) (cond ((= + V1001) (set shen.*occurs* true)) ((= - V1001) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1004 V1005) (cond ((and (cons? V1004) (and (cons? (hd V1004)) (and (cons? (tl V1004)) (and (= :- (hd (tl V1004))) (and (cons? (tl (tl V1004))) (= () (tl (tl (tl V1004))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1004)) (cons (shen.continuation_call (tl (hd V1004)) (hd (tl (tl V1004)))) ()))) V1005) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V1008 V1009) (let VTerms (cons ProcessN (shen.extract_vars V1008)) (let VBody (shen.extract_vars V1009) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1009)))))

(defun remove (V1012 V1013) (shen.remove-h V1012 V1013 ()))

(defun shen.remove-h (V1020 V1021 V1022) (cond ((= () V1021) (reverse V1022)) ((and (cons? V1021) (= (hd V1021) V1020)) (shen.remove-h (hd V1021) (tl V1021) V1022)) ((cons? V1021) (shen.remove-h V1020 (tl V1021) (cons (hd V1021) V1022))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V1025 V1026) (cond ((and (= () V1025) (= () V1026)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1026) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1025 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1025) (cons call (cons shen.the (cons shen.continuation (cons V1026 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1025 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1026 ())))) ())))))))))))

(defun shen.make_mu_application (V1029 V1030) (cond ((and (cons? V1029) (and (= shen.mu (hd V1029)) (and (cons? (tl V1029)) (and (= () (hd (tl V1029))) (and (cons? (tl (tl V1029))) (and (= () (tl (tl (tl V1029)))) (= () V1030))))))) (hd (tl (tl V1029)))) ((and (cons? V1029) (and (= shen.mu (hd V1029)) (and (cons? (tl V1029)) (and (cons? (hd (tl V1029))) (and (cons? (tl (tl V1029))) (and (= () (tl (tl (tl V1029)))) (cons? V1030))))))) (cons (cons shen.mu (cons (hd (hd (tl V1029))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1029))) (tl (tl V1029)))) (tl V1030)) ()))) (cons (hd V1030) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V1039 V1040) (cond ((and (cons? V1039) (and (cons? (hd V1039)) (and (= shen.mu (hd (hd V1039))) (and (cons? (tl (hd V1039))) (and (cons? (hd (tl (hd V1039)))) (and (= mode (hd (hd (tl (hd V1039))))) (and (cons? (tl (hd (tl (hd V1039))))) (and (cons? (tl (tl (hd (tl (hd V1039)))))) (and (= () (tl (tl (tl (hd (tl (hd V1039))))))) (and (cons? (tl (tl (hd V1039)))) (and (= () (tl (tl (tl (hd V1039))))) (and (cons? (tl V1039)) (= () (tl (tl V1039))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1039))))) (tl (tl (hd V1039))))) (tl V1039)) (hd (tl (tl (hd (tl (hd V1039)))))))) ((and (cons? V1039) (and (cons? (hd V1039)) (and (= shen.mu (hd (hd V1039))) (and (cons? (tl (hd V1039))) (and (cons? (tl (tl (hd V1039)))) (and (= () (tl (tl (tl (hd V1039))))) (and (cons? (tl V1039)) (and (= () (tl (tl V1039))) (= _ (hd (tl (hd V1039)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1039)))) V1040)) ((and (cons? V1039) (and (cons? (hd V1039)) (and (= shen.mu (hd (hd V1039))) (and (cons? (tl (hd V1039))) (and (cons? (tl (tl (hd V1039)))) (and (= () (tl (tl (tl (hd V1039))))) (and (cons? (tl V1039)) (and (= () (tl (tl V1039))) (shen.ephemeral_variable? (hd (tl (hd V1039))) (hd (tl V1039))))))))))) (subst (hd (tl V1039)) (hd (tl (hd V1039))) (shen.mu_reduction (hd (tl (tl (hd V1039)))) V1040))) ((and (cons? V1039) (and (cons? (hd V1039)) (and (= shen.mu (hd (hd V1039))) (and (cons? (tl (hd V1039))) (and (cons? (tl (tl (hd V1039)))) (and (= () (tl (tl (tl (hd V1039))))) (and (cons? (tl V1039)) (and (= () (tl (tl V1039))) (variable? (hd (tl (hd V1039)))))))))))) (cons let (cons (hd (tl (hd V1039))) (cons shen.be (cons (hd (tl V1039)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1039)))) V1040) ()))))))) ((and (cons? V1039) (and (cons? (hd V1039)) (and (= shen.mu (hd (hd V1039))) (and (cons? (tl (hd V1039))) (and (cons? (tl (tl (hd V1039)))) (and (= () (tl (tl (tl (hd V1039))))) (and (cons? (tl V1039)) (and (= () (tl (tl V1039))) (and (= - V1040) (shen.prolog_constant? (hd (tl (hd V1039))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1039))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1039))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1039)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1039) (and (cons? (hd V1039)) (and (= shen.mu (hd (hd V1039))) (and (cons? (tl (hd V1039))) (and (cons? (tl (tl (hd V1039)))) (and (= () (tl (tl (tl (hd V1039))))) (and (cons? (tl V1039)) (and (= () (tl (tl V1039))) (and (= + V1040) (shen.prolog_constant? (hd (tl (hd V1039))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1039))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1039))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1039)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1039))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1039)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1039) (and (cons? (hd V1039)) (and (= shen.mu (hd (hd V1039))) (and (cons? (tl (hd V1039))) (and (cons? (hd (tl (hd V1039)))) (and (cons? (tl (tl (hd V1039)))) (and (= () (tl (tl (tl (hd V1039))))) (and (cons? (tl V1039)) (and (= () (tl (tl V1039))) (= - V1040)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1039))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1039)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1039)))) (tl (tl (hd V1039))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1039) (and (cons? (hd V1039)) (and (= shen.mu (hd (hd V1039))) (and (cons? (tl (hd V1039))) (and (cons? (hd (tl (hd V1039)))) (and (cons? (tl (tl (hd V1039)))) (and (= () (tl (tl (tl (hd V1039))))) (and (cons? (tl V1039)) (and (= () (tl (tl V1039))) (= + V1040)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1039))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1039)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1039)))) (tl (tl (hd V1039))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1039)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1039))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1039)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1039)))

(defun shen.rcons_form (V1042) (cond ((cons? V1042) (cons cons (cons (shen.rcons_form (hd V1042)) (cons (shen.rcons_form (tl V1042)) ())))) (true V1042)))

(defun shen.remove_modes (V1044) (cond ((and (cons? V1044) (and (= mode (hd V1044)) (and (cons? (tl V1044)) (and (cons? (tl (tl V1044))) (and (= + (hd (tl (tl V1044)))) (= () (tl (tl (tl V1044))))))))) (shen.remove_modes (hd (tl V1044)))) ((and (cons? V1044) (and (= mode (hd V1044)) (and (cons? (tl V1044)) (and (cons? (tl (tl V1044))) (and (= - (hd (tl (tl V1044)))) (= () (tl (tl (tl V1044))))))))) (shen.remove_modes (hd (tl V1044)))) ((cons? V1044) (cons (shen.remove_modes (hd V1044)) (shen.remove_modes (tl V1044)))) (true V1044)))

(defun shen.ephemeral_variable? (V1047 V1048) (and (variable? V1047) (variable? V1048)))

(defun shen.prolog_constant? (V1058) (cond ((cons? V1058) false) (true true)))

(defun shen.aum_to_shen (V1060) (cond ((and (cons? V1060) (and (= let (hd V1060)) (and (cons? (tl V1060)) (and (cons? (tl (tl V1060))) (and (= shen.be (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (cons? (tl (tl (tl (tl V1060))))) (and (= in (hd (tl (tl (tl (tl V1060)))))) (and (cons? (tl (tl (tl (tl (tl V1060)))))) (= () (tl (tl (tl (tl (tl (tl V1060)))))))))))))))) (cons let (cons (hd (tl V1060)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1060))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1060))))))) ()))))) ((and (cons? V1060) (and (= shen.the (hd V1060)) (and (cons? (tl V1060)) (and (= shen.result (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.of (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (= shen.dereferencing (hd (tl (tl (tl V1060))))) (and (cons? (tl (tl (tl (tl V1060))))) (= () (tl (tl (tl (tl (tl V1060))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1060)))))) (cons ProcessN ())))) ((and (cons? V1060) (and (= if (hd V1060)) (and (cons? (tl V1060)) (and (cons? (tl (tl V1060))) (and (= shen.then (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (cons? (tl (tl (tl (tl V1060))))) (and (= shen.else (hd (tl (tl (tl (tl V1060)))))) (and (cons? (tl (tl (tl (tl (tl V1060)))))) (= () (tl (tl (tl (tl (tl (tl V1060)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1060))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1060))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1060))))))) ()))))) ((and (cons? V1060) (and (cons? (tl V1060)) (and (= is (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.a (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (= shen.variable (hd (tl (tl (tl V1060))))) (= () (tl (tl (tl (tl V1060)))))))))))) (cons shen.pvar? (cons (hd V1060) ()))) ((and (cons? V1060) (and (cons? (tl V1060)) (and (= is (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.a (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (= shen.non-empty (hd (tl (tl (tl V1060))))) (and (cons? (tl (tl (tl (tl V1060))))) (and (= list (hd (tl (tl (tl (tl V1060)))))) (= () (tl (tl (tl (tl (tl V1060))))))))))))))) (cons cons? (cons (hd V1060) ()))) ((and (cons? V1060) (and (= shen.rename (hd V1060)) (and (cons? (tl V1060)) (and (= shen.the (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.variables (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (= in (hd (tl (tl (tl V1060))))) (and (cons? (tl (tl (tl (tl V1060))))) (and (= () (hd (tl (tl (tl (tl V1060)))))) (and (cons? (tl (tl (tl (tl (tl V1060)))))) (and (= and (hd (tl (tl (tl (tl (tl V1060))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1060))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1060)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1060)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1060)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1060)))))))))) ((and (cons? V1060) (and (= shen.rename (hd V1060)) (and (cons? (tl V1060)) (and (= shen.the (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.variables (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (= in (hd (tl (tl (tl V1060))))) (and (cons? (tl (tl (tl (tl V1060))))) (and (cons? (hd (tl (tl (tl (tl V1060)))))) (and (cons? (tl (tl (tl (tl (tl V1060)))))) (and (= and (hd (tl (tl (tl (tl (tl V1060))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1060))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1060)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1060)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1060)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1060)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1060)))))) (tl (tl (tl (tl (tl V1060))))))))))) ()))))) ((and (cons? V1060) (and (= bind (hd V1060)) (and (cons? (tl V1060)) (and (cons? (tl (tl V1060))) (and (= shen.to (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (cons? (tl (tl (tl (tl V1060))))) (and (= in (hd (tl (tl (tl (tl V1060)))))) (and (cons? (tl (tl (tl (tl (tl V1060)))))) (= () (tl (tl (tl (tl (tl (tl V1060)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1060)) (cons (shen.chwild (hd (tl (tl (tl V1060))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1060))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1060)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1060) (and (cons? (tl V1060)) (and (= is (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= identical (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (and (= shen.to (hd (tl (tl (tl V1060))))) (and (cons? (tl (tl (tl (tl V1060))))) (= () (tl (tl (tl (tl (tl V1060)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1060))))) (cons (hd V1060) ())))) ((= shen.failed! V1060) false) ((and (cons? V1060) (and (= shen.the (hd V1060)) (and (cons? (tl V1060)) (and (= head (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.of (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (= () (tl (tl (tl (tl V1060)))))))))))) (cons hd (tl (tl (tl V1060))))) ((and (cons? V1060) (and (= shen.the (hd V1060)) (and (cons? (tl V1060)) (and (= tail (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.of (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (= () (tl (tl (tl (tl V1060)))))))))))) (cons tl (tl (tl (tl V1060))))) ((and (cons? V1060) (and (= shen.pop (hd V1060)) (and (cons? (tl V1060)) (and (= shen.the (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.stack (hd (tl (tl V1060)))) (= () (tl (tl (tl V1060)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1060) (and (= call (hd V1060)) (and (cons? (tl V1060)) (and (= shen.the (hd (tl V1060))) (and (cons? (tl (tl V1060))) (and (= shen.continuation (hd (tl (tl V1060)))) (and (cons? (tl (tl (tl V1060)))) (= () (tl (tl (tl (tl V1060)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1060))))) ProcessN Continuation) ())))) (true V1060)))

(defun shen.chwild (V1062) (cond ((= V1062 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1062) (map (lambda Z (shen.chwild Z)) V1062)) (true V1062)))

(defun shen.newpv (V1064) (let Count+1 (+ (<-address (value shen.*varcounter*) V1064) 1) (let IncVar (address-> (value shen.*varcounter*) V1064 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1064) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1064 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1067 V1068) (let Vector (<-address (value shen.*prologvectors*) V1067) (let BigVector (shen.resize-vector Vector (+ V1068 V1068) shen.-null-) (address-> (value shen.*prologvectors*) V1067 BigVector))))

(defun shen.resize-vector (V1072 V1073 V1074) (let BigVector (address-> (absvector (+ 1 V1073)) 0 V1073) (shen.copy-vector V1072 BigVector (limit V1072) V1073 V1074)))

(defun shen.copy-vector (V1080 V1081 V1082 V1083 V1084) (shen.copy-vector-stage-2 (+ 1 V1082) (+ V1083 1) V1084 (shen.copy-vector-stage-1 1 V1080 V1081 (+ 1 V1082))))

(defun shen.copy-vector-stage-1 (V1092 V1093 V1094 V1095) (cond ((= V1095 V1092) V1094) (true (shen.copy-vector-stage-1 (+ 1 V1092) V1093 (address-> V1094 V1092 (<-address V1093 V1092)) V1095))))

(defun shen.copy-vector-stage-2 (V1103 V1104 V1105 V1106) (cond ((= V1104 V1103) V1106) (true (shen.copy-vector-stage-2 (+ V1103 1) V1104 V1105 (address-> V1106 V1103 V1105)))))

(defun shen.mk-pvar (V1108) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1108))

(defun shen.pvar? (V1110) (and (absvector? V1110) (= (trap-error (<-address V1110 0) (lambda E shen.not-pvar)) shen.pvar)))

(defun shen.bindv (V1114 V1115 V1116) (let Vector (<-address (value shen.*prologvectors*) V1116) (address-> Vector (<-address V1114 1) V1115)))

(defun shen.unbindv (V1119 V1120) (let Vector (<-address (value shen.*prologvectors*) V1120) (address-> Vector (<-address V1119 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1124 V1125 V1126) (cond ((and (cons? V1124) (and (cons? (hd V1124)) (= () (tl V1124)))) (cons (hd (hd V1124)) (append (tl (hd V1124)) (cons V1125 (cons V1126 ()))))) ((and (cons? V1124) (cons? (hd V1124))) (let NewContinuation (shen.newcontinuation (tl V1124) V1125 V1126) (cons (hd (hd V1124)) (append (tl (hd V1124)) (cons V1125 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V1130 V1131 V1132) (cond ((= () V1130) V1132) ((and (cons? V1130) (cons? (hd V1130))) (cons freeze (cons (cons (hd (hd V1130)) (append (tl (hd V1130)) (cons V1131 (cons (shen.newcontinuation (tl V1130) V1131 V1132) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V1140 V1141 V1142) (shen.deref V1140 V1141))

(defun shen.measure&return (V1150 V1151 V1152) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1150 V1151)))

(defun unify (V1157 V1158 V1159 V1160) (shen.lzy= (shen.lazyderef V1157 V1159) (shen.lazyderef V1158 V1159) V1159 V1160))

(defun shen.lzy= (V1182 V1183 V1184 V1185) (cond ((= V1183 V1182) (thaw V1185)) ((shen.pvar? V1182) (bind V1182 V1183 V1184 V1185)) ((shen.pvar? V1183) (bind V1183 V1182 V1184 V1185)) ((and (cons? V1182) (cons? V1183)) (shen.lzy= (shen.lazyderef (hd V1182) V1184) (shen.lazyderef (hd V1183) V1184) V1184 (freeze (shen.lzy= (shen.lazyderef (tl V1182) V1184) (shen.lazyderef (tl V1183) V1184) V1184 V1185)))) (true false)))

(defun shen.deref (V1188 V1189) (cond ((cons? V1188) (cons (shen.deref (hd V1188) V1189) (shen.deref (tl V1188) V1189))) (true (if (shen.pvar? V1188) (let Value (shen.valvector V1188 V1189) (if (= Value shen.-null-) V1188 (shen.deref Value V1189))) V1188))))

(defun shen.lazyderef (V1192 V1193) (if (shen.pvar? V1192) (let Value (shen.valvector V1192 V1193) (if (= Value shen.-null-) V1192 (shen.lazyderef Value V1193))) V1192))

(defun shen.valvector (V1196 V1197) (<-address (<-address (value shen.*prologvectors*) V1197) (<-address V1196 1)))

(defun unify! (V1202 V1203 V1204 V1205) (shen.lzy=! (shen.lazyderef V1202 V1204) (shen.lazyderef V1203 V1204) V1204 V1205))

(defun shen.lzy=! (V1227 V1228 V1229 V1230) (cond ((= V1228 V1227) (thaw V1230)) ((and (shen.pvar? V1227) (not (shen.occurs? V1227 (shen.deref V1228 V1229)))) (bind V1227 V1228 V1229 V1230)) ((and (shen.pvar? V1228) (not (shen.occurs? V1228 (shen.deref V1227 V1229)))) (bind V1228 V1227 V1229 V1230)) ((and (cons? V1227) (cons? V1228)) (shen.lzy=! (shen.lazyderef (hd V1227) V1229) (shen.lazyderef (hd V1228) V1229) V1229 (freeze (shen.lzy=! (shen.lazyderef (tl V1227) V1229) (shen.lazyderef (tl V1228) V1229) V1229 V1230)))) (true false)))

(defun shen.occurs? (V1242 V1243) (cond ((= V1243 V1242) true) ((cons? V1243) (or (shen.occurs? V1242 (hd V1243)) (shen.occurs? V1242 (tl V1243)))) (true false)))

(defun identical (V1248 V1249 V1250 V1251) (shen.lzy== (shen.lazyderef V1248 V1250) (shen.lazyderef V1249 V1250) V1250 V1251))

(defun shen.lzy== (V1273 V1274 V1275 V1276) (cond ((= V1274 V1273) (thaw V1276)) ((and (cons? V1273) (cons? V1274)) (shen.lzy== (shen.lazyderef (hd V1273) V1275) (shen.lazyderef (hd V1274) V1275) V1275 (freeze (shen.lzy== (tl V1273) (tl V1274) V1275 V1276)))) (true false)))

(defun shen.pvar (V1278) (cn "Var" (shen.app (<-address V1278 1) "" shen.a)))

(defun bind (V1283 V1284 V1285 V1286) (do (shen.bindv V1283 V1284 V1285) (let Result (thaw V1286) (do (shen.unbindv V1283 V1285) Result))))

(defun fwhen (V1304 V1305 V1306) (cond ((= true V1304) (thaw V1306)) ((= false V1304) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1304 "%" shen.s))))))

(defun call (V1322 V1323 V1324) (cond ((cons? V1322) (shen.call-help (function (shen.lazyderef (hd V1322) V1323)) (tl V1322) V1323 V1324)) ((shen.pvar? V1322) (call (shen.lazyderef V1322 V1323) V1323 V1324)) (true false)))

(defun shen.call-help (V1329 V1330 V1331 V1332) (cond ((= () V1330) (V1329 V1331 V1332)) ((cons? V1330) (shen.call-help (V1329 (hd V1330)) (tl V1330) V1331 V1332)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V1334) (cond ((and (cons? V1334) (cons? (hd V1334))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1334)) (shen.insert-prolog-variables (cons (tl (hd V1334)) (cons (tl V1334) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V1338 V1339 V1340) (cond ((and (cons? V1339) (and (cons? (tl V1339)) (= () (tl (tl V1339))))) (shen.intprolog-help-help V1338 (hd V1339) (hd (tl V1339)) V1340)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1345 V1346 V1347 V1348) (cond ((= () V1346) (V1345 V1348 (freeze (shen.call-rest V1347 V1348)))) ((cons? V1346) (shen.intprolog-help-help (V1345 (hd V1346)) (tl V1346) V1347 V1348)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V1353 V1354) (cond ((= () V1353) true) ((and (cons? V1353) (and (cons? (hd V1353)) (cons? (tl (hd V1353))))) (shen.call-rest (cons (cons ((hd (hd V1353)) (hd (tl (hd V1353)))) (tl (tl (hd V1353)))) (tl V1353)) V1354)) ((and (cons? V1353) (and (cons? (hd V1353)) (= () (tl (hd V1353))))) ((hd (hd V1353)) V1354 (freeze (shen.call-rest (tl V1353) V1354)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1357 V1358) (shen.insert-prolog-variables-help V1357 (shen.flatten V1357) V1358))

(defun shen.insert-prolog-variables-help (V1366 V1367 V1368) (cond ((= () V1367) V1366) ((and (cons? V1367) (variable? (hd V1367))) (let V (shen.newpv V1368) (let XV/Y (subst V (hd V1367) V1366) (let Z-Y (remove (hd V1367) (tl V1367)) (shen.insert-prolog-variables-help XV/Y Z-Y V1368))))) ((cons? V1367) (shen.insert-prolog-variables-help V1366 (tl V1367) V1368)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1370) (let Vector (address-> (value shen.*prologvectors*) V1370 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1370 1) V1370)))




"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.shen->kl (V94 V95) (compile (lambda X (shen.<define> X)) (cons V94 V95) (lambda X (shen.shen-syntax-error V94 X))))

(defun shen.shen-syntax-error (V102 V103) (cond ((cons? V103) (simple-error (cn "syntax error in " (shen.app V102 (cn " here:

 " (shen.app (shen.next-50 50 (hd V103)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V102 "
" shen.a))))))

(defun shen.<define> (V105) (let YaccParse (let Parse_shen.<name> (shen.<name> V105) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V105) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V107) (if (cons? (hd V107)) (let Parse_X (shen.hdhd V107) (shen.pair (hd (shen.pair (shen.tlhd V107) (shen.hdtl V107))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V109) (element? V109 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V113) (if (and (cons? (hd V113)) (= { (shen.hdhd V113))) (let NewStream110 (shen.pair (shen.tlhd V113) (shen.hdtl V113)) (let Parse_shen.<signature-help> (shen.<signature-help> NewStream110) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (shen.hdhd Parse_shen.<signature-help>))) (let NewStream111 (shen.pair (shen.tlhd Parse_shen.<signature-help>) (shen.hdtl Parse_shen.<signature-help>)) (shen.pair (hd NewStream111) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>))))) (fail)) (fail)))) (fail)))

(defun shen.curry-type (V115) (shen.active-cons (shen.curry-type-h V115)))

(defun shen.active-cons (V117) (cond ((and (cons? V117) (and (cons? (tl V117)) (and (cons? (tl (tl V117))) (and (= () (tl (tl (tl V117)))) (= (hd (tl V117)) bar!))))) (cons (shen.active-cons (hd V117)) (shen.active-cons (hd (tl (tl V117)))))) ((cons? V117) (cons (shen.active-cons (hd V117)) (shen.active-cons (tl V117)))) (true V117)))

(defun shen.curry-type-h (V119) (cond ((and (cons? V119) (and (cons? (tl V119)) (and (= --> (hd (tl V119))) (and (cons? (tl (tl V119))) (and (cons? (tl (tl (tl V119)))) (= --> (hd (tl (tl (tl V119)))))))))) (shen.curry-type-h (cons (hd V119) (cons --> (cons (tl (tl V119)) ()))))) ((and (cons? V119) (and (cons? (tl V119)) (and (= * (hd (tl V119))) (and (cons? (tl (tl V119))) (and (cons? (tl (tl (tl V119)))) (= * (hd (tl (tl (tl V119)))))))))) (shen.curry-type-h (cons (hd V119) (cons * (cons (tl (tl V119)) ()))))) ((cons? V119) (map (lambda Z (shen.curry-type-h Z)) V119)) (true V119)))

(defun shen.<signature-help> (V121) (let YaccParse (if (cons? (hd V121)) (let Parse_X (shen.hdhd V121) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (shen.tlhd V121) (shen.hdtl V121))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V121) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V123) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V123) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V123) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V131) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V131) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (shen.hdhd Parse_shen.<patterns>))) (let NewStream124 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream124) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (shen.hdhd Parse_shen.<action>))) (let NewStream125 (shen.pair (shen.tlhd Parse_shen.<action>) (shen.hdtl Parse_shen.<action>)) (let Parse_shen.<guard> (shen.<guard> NewStream125) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail)))) (fail)) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V131) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (shen.hdhd Parse_shen.<patterns>))) (let NewStream126 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream126) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V131) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (shen.hdhd Parse_shen.<patterns>))) (let NewStream127 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream127) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (shen.hdhd Parse_shen.<action>))) (let NewStream128 (shen.pair (shen.tlhd Parse_shen.<action>) (shen.hdtl Parse_shen.<action>)) (let Parse_shen.<guard> (shen.<guard> NewStream128) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail)))) (fail)) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V131) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (shen.hdhd Parse_shen.<patterns>))) (let NewStream129 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream129) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail)))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V134 V135) (if (V134 V135) (fail) V135))

(defun shen.succeeds? (V141) (cond ((= V141 (fail)) false) (true true)))

(defun shen.custom-pattern-compiler (V144 V145) ((value shen.*custom-pattern-compiler*) V144 V145))

(defun shen.custom-pattern-reducer (V147) ((value shen.*custom-pattern-reducer*) V147))

(defun shen.<patterns> (V149) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V149) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V149) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V162) (let YaccParse (if (and (cons? (hd V162)) (cons? (shen.hdhd V162))) (if (and (cons? (hd (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (= @p (shen.hdhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))))) (let NewStream151 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))) (shen.hdtl (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream151) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V162) (shen.hdtl V162))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V162)) (cons? (shen.hdhd V162))) (if (and (cons? (hd (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (= cons (shen.hdhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))))) (let NewStream153 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))) (shen.hdtl (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream153) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V162) (shen.hdtl V162))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V162)) (cons? (shen.hdhd V162))) (if (and (cons? (hd (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (= @v (shen.hdhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))))) (let NewStream155 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))) (shen.hdtl (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream155) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V162) (shen.hdtl V162))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V162)) (cons? (shen.hdhd V162))) (if (and (cons? (hd (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (= @s (shen.hdhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))))) (let NewStream157 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))) (shen.hdtl (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream157) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V162) (shen.hdtl V162))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V162)) (cons? (shen.hdhd V162))) (if (and (cons? (hd (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (= vector (shen.hdhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))))) (let NewStream159 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V162) (shen.hdtl V162))) (shen.hdtl (shen.pair (shen.hdhd V162) (shen.hdtl V162)))) (if (and (cons? (hd NewStream159)) (= 0 (shen.hdhd NewStream159))) (let NewStream160 (shen.pair (shen.tlhd NewStream159) (shen.hdtl NewStream159)) (shen.pair (hd (shen.pair (shen.tlhd V162) (shen.hdtl V162))) (cons vector (cons 0 ())))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V162)) (let Parse_X (shen.hdhd V162) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V162) (shen.hdtl V162))) (shen.custom-pattern-compiler Parse_X (freeze (shen.constructor-error Parse_X)))) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V162) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V164) (simple-error (shen.app V164 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V166) (let YaccParse (if (cons? (hd V166)) (let Parse_X (shen.hdhd V166) (if (= Parse_X _) (shen.pair (hd (shen.pair (shen.tlhd V166) (shen.hdtl V166))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V166)) (let Parse_X (shen.hdhd V166) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (shen.tlhd V166) (shen.hdtl V166))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V168) (let Parse_shen.<pattern> (shen.<pattern> V168) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V170) (let Parse_shen.<pattern> (shen.<pattern> V170) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V172) (if (cons? (hd V172)) (let Parse_X (shen.hdhd V172) (shen.pair (hd (shen.pair (shen.tlhd V172) (shen.hdtl V172))) Parse_X)) (fail)))

(defun shen.<guard> (V174) (if (cons? (hd V174)) (let Parse_X (shen.hdhd V174) (shen.pair (hd (shen.pair (shen.tlhd V174) (shen.hdtl V174))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V177 V178) (let Lambda+ (shen.compile_to_lambda+ V177 V178) (let KL (shen.compile_to_kl V177 Lambda+) (let Record (shen.record-source V177 KL) KL))))

(defun shen.record-source (V183 V184) (cond ((value shen.*installing-kl*) shen.skip) (true (put V183 shen.source V184 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V187 V188) (let Arity (shen.aritycheck V187 V188) (let UpDateSymbolTable (shen.update-symbol-table V187 Arity) (let Free (shen.for-each (lambda Rule (shen.free_variable_check V187 Rule)) V188) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V188) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V191 V192) (cond ((= 0 V192) shen.skip) (true (put V191 shen.lambda-form (eval-kl (shen.lambda-form V191 V192)) (value *property-vector*)))))

(defun shen.free_variable_check (V195 V196) (cond ((and (cons? V196) (and (cons? (tl V196)) (= () (tl (tl V196))))) (let Bound (shen.extract_vars (hd V196)) (let Free (shen.extract_free_vars Bound (hd (tl V196))) (shen.free_variable_warnings V195 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V198) (cond ((variable? V198) (cons V198 ())) ((cons? V198) (union (shen.extract_vars (hd V198)) (shen.extract_vars (tl V198)))) (true ())))

(defun shen.extract_free_vars (V210 V211) (cond ((and (cons? V211) (and (cons? (tl V211)) (and (= () (tl (tl V211))) (= (hd V211) protect)))) ()) ((and (variable? V211) (not (element? V211 V210))) (cons V211 ())) ((and (cons? V211) (and (= lambda (hd V211)) (and (cons? (tl V211)) (and (cons? (tl (tl V211))) (= () (tl (tl (tl V211)))))))) (shen.extract_free_vars (cons (hd (tl V211)) V210) (hd (tl (tl V211))))) ((and (cons? V211) (and (= let (hd V211)) (and (cons? (tl V211)) (and (cons? (tl (tl V211))) (and (cons? (tl (tl (tl V211)))) (= () (tl (tl (tl (tl V211)))))))))) (union (shen.extract_free_vars V210 (hd (tl (tl V211)))) (shen.extract_free_vars (cons (hd (tl V211)) V210) (hd (tl (tl (tl V211))))))) ((cons? V211) (union (shen.extract_free_vars V210 (hd V211)) (shen.extract_free_vars V210 (tl V211)))) (true ())))

(defun shen.free_variable_warnings (V216 V217) (cond ((= () V217) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V216 (cn ": " (shen.app (shen.list_variables V217) "" shen.a)) shen.a))))))

(defun shen.list_variables (V219) (cond ((and (cons? V219) (= () (tl V219))) (cn (str (hd V219)) ".")) ((cons? V219) (cn (str (hd V219)) (cn ", " (shen.list_variables (tl V219))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V221) (cond ((and (cons? V221) (and (cons? (tl V221)) (and (= () (tl (tl V221))) (= (hd V221) protect)))) (shen.strip-protect (hd (tl V221)))) ((cons? V221) (map (lambda Z (shen.strip-protect Z)) V221)) (true V221)))

(defun shen.linearise (V223) (cond ((and (cons? V223) (and (cons? (tl V223)) (= () (tl (tl V223))))) (shen.linearise_help (shen.flatten (hd V223)) (hd V223) (hd (tl V223)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V225) (cond ((= () V225) ()) ((cons? V225) (append (shen.flatten (hd V225)) (shen.flatten (tl V225)))) (true (cons V225 ()))))

(defun shen.linearise_help (V229 V230 V231) (cond ((= () V229) (cons V230 (cons V231 ()))) ((cons? V229) (if (and (variable? (hd V229)) (element? (hd V229) (tl V229))) (let Var (gensym (hd V229)) (let NewAction (cons where (cons (cons = (cons (hd V229) (cons Var ()))) (cons V231 ()))) (let NewPatts (shen.linearise_X (hd V229) Var V230) (shen.linearise_help (tl V229) NewPatts NewAction)))) (shen.linearise_help (tl V229) V230 V231))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V244 V245 V246) (cond ((= V246 V244) V245) ((cons? V246) (let L (shen.linearise_X V244 V245 (hd V246)) (if (= L (hd V246)) (cons (hd V246) (shen.linearise_X V244 V245 (tl V246))) (cons L (tl V246))))) (true V246)))

(defun shen.aritycheck (V249 V250) (cond ((and (cons? V250) (and (cons? (hd V250)) (and (cons? (tl (hd V250))) (and (= () (tl (tl (hd V250)))) (= () (tl V250)))))) (do (shen.aritycheck-action (hd (tl (hd V250)))) (shen.aritycheck-name V249 (arity V249) (length (hd (hd V250)))))) ((and (cons? V250) (and (cons? (hd V250)) (and (cons? (tl (hd V250))) (and (= () (tl (tl (hd V250)))) (and (cons? (tl V250)) (and (cons? (hd (tl V250))) (and (cons? (tl (hd (tl V250)))) (= () (tl (tl (hd (tl V250)))))))))))) (if (= (length (hd (hd V250))) (length (hd (hd (tl V250))))) (do (shen.aritycheck-action (hd (tl (hd V250)))) (shen.aritycheck V249 (tl V250))) (simple-error (cn "arity error in " (shen.app V249 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V263 V264 V265) (cond ((= -1 V264) V265) ((= V265 V264) V265) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V263 " can cause errors.
" shen.a)) (stoutput)) V265))))

(defun shen.aritycheck-action (V271) (cond ((cons? V271) (do (shen.aah (hd V271) (tl V271)) (shen.for-each (lambda Y (shen.aritycheck-action Y)) V271))) (true shen.skip)))

(defun shen.aah (V274 V275) (let Arity (arity V274) (let Len (length V275) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V274 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V277) (cond ((and (cons? V277) (and (cons? (tl V277)) (= () (tl (tl V277))))) (shen.abstraction_build (hd V277) (hd (tl V277)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V280 V281) (cond ((= () V280) V281) ((cons? V280) (cons /. (cons (hd V280) (cons (shen.abstraction_build (tl V280) V281) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V283) (cond ((= 0 V283) ()) (true (cons (gensym V) (shen.parameters (- V283 1))))))

(defun shen.application_build (V286 V287) (cond ((= () V286) V287) ((cons? V286) (shen.application_build (tl V286) (cons V287 (cons (hd V286) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V290 V291) (cond ((and (cons? V291) (and (cons? (tl V291)) (= () (tl (tl V291))))) (let Arity (shen.store-arity V290 (length (hd V291))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V291))) (let CondExpression (shen.cond-expression V290 (hd V291) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V290) (hd V291)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V291) TypeTable CondExpression) CondExpression) (cons defun (cons V290 (cons (hd V291) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V297) (cond ((cons? V297) shen.skip) (true (let FType (assoc V297 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V308 V309) (cond ((and (cons? V308) (and (cons? (tl V308)) (and (= --> (hd (tl V308))) (and (cons? (tl (tl V308))) (and (= () (tl (tl (tl V308)))) (cons? V309)))))) (if (variable? (hd V308)) (shen.typextable (hd (tl (tl V308))) (tl V309)) (cons (cons (hd V309) (hd V308)) (shen.typextable (hd (tl (tl V308))) (tl V309))))) (true ())))

(defun shen.assign-types (V313 V314 V315) (cond ((and (cons? V315) (and (= let (hd V315)) (and (cons? (tl V315)) (and (cons? (tl (tl V315))) (and (cons? (tl (tl (tl V315)))) (= () (tl (tl (tl (tl V315)))))))))) (cons let (cons (hd (tl V315)) (cons (shen.assign-types V313 V314 (hd (tl (tl V315)))) (cons (shen.assign-types (cons (hd (tl V315)) V313) V314 (hd (tl (tl (tl V315))))) ()))))) ((and (cons? V315) (and (= lambda (hd V315)) (and (cons? (tl V315)) (and (cons? (tl (tl V315))) (= () (tl (tl (tl V315)))))))) (cons lambda (cons (hd (tl V315)) (cons (shen.assign-types (cons (hd (tl V315)) V313) V314 (hd (tl (tl V315)))) ())))) ((and (cons? V315) (= cond (hd V315))) (cons cond (map (lambda Y (cons (shen.assign-types V313 V314 (hd Y)) (cons (shen.assign-types V313 V314 (hd (tl Y))) ()))) (tl V315)))) ((cons? V315) (let NewTable (shen.typextable (shen.get-type (hd V315)) (tl V315)) (cons (hd V315) (map (lambda Y (shen.assign-types V313 (append V314 NewTable) Y)) (tl V315))))) (true (let AtomType (assoc V315 V314) (if (cons? AtomType) (cons type (cons V315 (cons (tl AtomType) ()))) (if (element? V315 V313) V315 (shen.atom-type V315)))))))

(defun shen.atom-type (V317) (if (string? V317) (cons type (cons V317 (cons string ()))) (if (number? V317) (cons type (cons V317 (cons number ()))) (if (boolean? V317) (cons type (cons V317 (cons boolean ()))) (if (symbol? V317) (cons type (cons V317 (cons symbol ()))) V317)))))

(defun shen.store-arity (V322 V323) (cond ((value shen.*installing-kl*) shen.skip) (true (put V322 arity V323 (value *property-vector*)))))

(defun shen.reduce (V325) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V325) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V327) (cond ((and (cons? V327) (and (cons? (hd V327)) (and (= /. (hd (hd V327))) (and (cons? (tl (hd V327))) (and (cons? (hd (tl (hd V327)))) (and (= cons (hd (hd (tl (hd V327))))) (and (cons? (tl (hd (tl (hd V327))))) (and (cons? (tl (tl (hd (tl (hd V327)))))) (and (= () (tl (tl (tl (hd (tl (hd V327))))))) (and (cons? (tl (tl (hd V327)))) (and (= () (tl (tl (tl (hd V327))))) (and (cons? (tl V327)) (= () (tl (tl V327))))))))))))))) (do (shen.add_test (cons cons? (tl V327))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V327))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V327)))))) (cons (shen.ebr (hd (tl V327)) (hd (tl (hd V327))) (hd (tl (tl (hd V327))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V327)) ())) (cons (cons tl (tl V327)) ())) (shen.reduce_help Application))))) ((and (cons? V327) (and (cons? (hd V327)) (and (= /. (hd (hd V327))) (and (cons? (tl (hd V327))) (and (cons? (hd (tl (hd V327)))) (and (= @p (hd (hd (tl (hd V327))))) (and (cons? (tl (hd (tl (hd V327))))) (and (cons? (tl (tl (hd (tl (hd V327)))))) (and (= () (tl (tl (tl (hd (tl (hd V327))))))) (and (cons? (tl (tl (hd V327)))) (and (= () (tl (tl (tl (hd V327))))) (and (cons? (tl V327)) (= () (tl (tl V327))))))))))))))) (do (shen.add_test (cons tuple? (tl V327))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V327))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V327)))))) (cons (shen.ebr (hd (tl V327)) (hd (tl (hd V327))) (hd (tl (tl (hd V327))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V327)) ())) (cons (cons snd (tl V327)) ())) (shen.reduce_help Application))))) ((and (cons? V327) (and (cons? (hd V327)) (and (= /. (hd (hd V327))) (and (cons? (tl (hd V327))) (and (cons? (hd (tl (hd V327)))) (and (= @v (hd (hd (tl (hd V327))))) (and (cons? (tl (hd (tl (hd V327))))) (and (cons? (tl (tl (hd (tl (hd V327)))))) (and (= () (tl (tl (tl (hd (tl (hd V327))))))) (and (cons? (tl (tl (hd V327)))) (and (= () (tl (tl (tl (hd V327))))) (and (cons? (tl V327)) (= () (tl (tl V327))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V327))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V327))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V327)))))) (cons (shen.ebr (hd (tl V327)) (hd (tl (hd V327))) (hd (tl (tl (hd V327))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V327)) ())) (cons (cons tlv (tl V327)) ())) (shen.reduce_help Application))))) ((and (cons? V327) (and (cons? (hd V327)) (and (= /. (hd (hd V327))) (and (cons? (tl (hd V327))) (and (cons? (hd (tl (hd V327)))) (and (= @s (hd (hd (tl (hd V327))))) (and (cons? (tl (hd (tl (hd V327))))) (and (cons? (tl (tl (hd (tl (hd V327)))))) (and (= () (tl (tl (tl (hd (tl (hd V327))))))) (and (cons? (tl (tl (hd V327)))) (and (= () (tl (tl (tl (hd V327))))) (and (cons? (tl V327)) (= () (tl (tl V327))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V327))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V327))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V327)))))) (cons (shen.ebr (hd (tl V327)) (hd (tl (hd V327))) (hd (tl (tl (hd V327))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V327)) (cons 0 ()))) ())) (cons (cons tlstr (tl V327)) ())) (shen.reduce_help Application))))) ((and (cons? V327) (and (cons? (hd V327)) (and (= /. (hd (hd V327))) (and (cons? (tl (hd V327))) (and (cons? (hd (tl (hd V327)))) (and (= vector (hd (hd (tl (hd V327))))) (and (cons? (tl (hd (tl (hd V327))))) (and (= 0 (hd (tl (hd (tl (hd V327)))))) (and (= () (tl (tl (hd (tl (hd V327)))))) (and (cons? (tl (tl (hd V327)))) (and (= () (tl (tl (tl (hd V327))))) (and (cons? (tl V327)) (= () (tl (tl V327))))))))))))))) (do (shen.add_test (cons vector? (tl V327))) (do (shen.add_test (cons = (cons 0 (cons (cons limit (tl V327)) ())))) (shen.reduce_help (shen.ebr (hd (tl V327)) (hd (tl (hd V327))) (hd (tl (tl (hd V327))))))))) ((and (cons? V327) (and (cons? (hd V327)) (and (= /. (hd (hd V327))) (and (cons? (tl (hd V327))) (and (cons? (hd (tl (hd V327)))) (and (cons? (tl (tl (hd V327)))) (and (= () (tl (tl (tl (hd V327))))) (and (cons? (tl V327)) (= () (tl (tl V327))))))))))) (shen.custom-pattern-reducer V327)) ((and (cons? V327) (and (cons? (hd V327)) (and (= /. (hd (hd V327))) (and (cons? (tl (hd V327))) (and (cons? (tl (tl (hd V327)))) (and (= () (tl (tl (tl (hd V327))))) (and (cons? (tl V327)) (and (= () (tl (tl V327))) (not (variable? (hd (tl (hd V327))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V327))) (tl V327)))) (shen.reduce_help (hd (tl (tl (hd V327))))))) ((and (cons? V327) (and (cons? (hd V327)) (and (= /. (hd (hd V327))) (and (cons? (tl (hd V327))) (and (cons? (tl (tl (hd V327)))) (and (= () (tl (tl (tl (hd V327))))) (and (cons? (tl V327)) (= () (tl (tl V327)))))))))) (shen.reduce_help (shen.ebr (hd (tl V327)) (hd (tl (hd V327))) (hd (tl (tl (hd V327))))))) ((and (cons? V327) (and (= where (hd V327)) (and (cons? (tl V327)) (and (cons? (tl (tl V327))) (= () (tl (tl (tl V327)))))))) (do (shen.add_test (hd (tl V327))) (shen.reduce_help (hd (tl (tl V327)))))) ((and (cons? V327) (and (cons? (tl V327)) (= () (tl (tl V327))))) (let Z (shen.reduce_help (hd V327)) (if (= (hd V327) Z) V327 (shen.reduce_help (cons Z (tl V327)))))) (true V327)))

(defun shen.+string? (V329) (cond ((= "" V329) false) (true (string? V329))))

(defun shen.+vector? (V331) (and (absvector? V331) (> (<-address V331 0) 0)))

(defun shen.ebr (V344 V345 V346) (cond ((= V346 V345) V344) ((and (cons? V346) (and (= lambda (hd V346)) (and (cons? (tl V346)) (and (cons? (tl (tl V346))) (and (= () (tl (tl (tl V346)))) (shen.clash? (hd (tl V346)) V345)))))) V346) ((and (cons? V346) (and (= let (hd V346)) (and (cons? (tl V346)) (and (cons? (tl (tl V346))) (and (cons? (tl (tl (tl V346)))) (and (= () (tl (tl (tl (tl V346))))) (shen.clash? (hd (tl V346)) V345))))))) (cons let (cons (hd (tl V346)) (cons (shen.ebr V344 V345 (hd (tl (tl V346)))) (tl (tl (tl V346))))))) ((cons? V346) (cons (shen.ebr V344 V345 (hd V346)) (shen.ebr V344 V345 (tl V346)))) (true V346)))

(defun shen.clash? (V358 V359) (cond ((= V359 V358) true) ((cons? V359) (or (shen.clash? V358 (hd V359)) (shen.clash? V358 (tl V359)))) (true false)))

(defun shen.add_test (V361) (set shen.*teststack* (cons V361 (value shen.*teststack*))))

(defun shen.cond-expression (V365 V366 V367) (let Err (shen.err-condition V365) (let Cases (shen.case-form V367 Err) (let EncodeChoices (shen.encode-choices Cases V365) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V371) (cond ((and (cons? V371) (and (cons? (hd V371)) (and (= true (hd (hd V371))) (and (cons? (tl (hd V371))) (= () (tl (tl (hd V371)))))))) (hd (tl (hd V371)))) (true (cons cond V371))))

(defun shen.encode-choices (V376 V377) (cond ((= () V376) ()) ((and (cons? V376) (and (cons? (hd V376)) (and (= true (hd (hd V376))) (and (cons? (tl (hd V376))) (and (cons? (hd (tl (hd V376)))) (and (= shen.choicepoint! (hd (hd (tl (hd V376))))) (and (cons? (tl (hd (tl (hd V376))))) (and (= () (tl (tl (hd (tl (hd V376)))))) (and (= () (tl (tl (hd V376)))) (= () (tl V376))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V376))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V377 ())) (cons shen.f_error (cons V377 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V376) (and (cons? (hd V376)) (and (= true (hd (hd V376))) (and (cons? (tl (hd V376))) (and (cons? (hd (tl (hd V376)))) (and (= shen.choicepoint! (hd (hd (tl (hd V376))))) (and (cons? (tl (hd (tl (hd V376))))) (and (= () (tl (tl (hd (tl (hd V376)))))) (= () (tl (tl (hd V376)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V376))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V376) V377)) (cons Result ())))) ())))) ())) ())) ((and (cons? V376) (and (cons? (hd V376)) (and (cons? (tl (hd V376))) (and (cons? (hd (tl (hd V376)))) (and (= shen.choicepoint! (hd (hd (tl (hd V376))))) (and (cons? (tl (hd (tl (hd V376))))) (and (= () (tl (tl (hd (tl (hd V376)))))) (= () (tl (tl (hd V376))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V376) V377)) ())) (cons (cons if (cons (hd (hd V376)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V376))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V376) (and (cons? (hd V376)) (and (cons? (tl (hd V376))) (= () (tl (tl (hd V376))))))) (cons (hd V376) (shen.encode-choices (tl V376) V377))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V384 V385) (cond ((= () V384) (cons V385 ())) ((and (cons? V384) (and (cons? (hd V384)) (and (cons? (hd (hd V384))) (and (= : (hd (hd (hd V384)))) (and (cons? (tl (hd (hd V384)))) (and (= shen.tests (hd (tl (hd (hd V384))))) (and (= () (tl (tl (hd (hd V384))))) (and (cons? (tl (hd V384))) (and (cons? (hd (tl (hd V384)))) (and (= shen.choicepoint! (hd (hd (tl (hd V384))))) (and (cons? (tl (hd (tl (hd V384))))) (and (= () (tl (tl (hd (tl (hd V384)))))) (= () (tl (tl (hd V384)))))))))))))))) (cons (cons true (tl (hd V384))) (shen.case-form (tl V384) V385))) ((and (cons? V384) (and (cons? (hd V384)) (and (cons? (hd (hd V384))) (and (= : (hd (hd (hd V384)))) (and (cons? (tl (hd (hd V384)))) (and (= shen.tests (hd (tl (hd (hd V384))))) (and (= () (tl (tl (hd (hd V384))))) (and (cons? (tl (hd V384))) (= () (tl (tl (hd V384)))))))))))) (cons (cons true (tl (hd V384))) ())) ((and (cons? V384) (and (cons? (hd V384)) (and (cons? (hd (hd V384))) (and (= : (hd (hd (hd V384)))) (and (cons? (tl (hd (hd V384)))) (and (= shen.tests (hd (tl (hd (hd V384))))) (and (cons? (tl (hd V384))) (= () (tl (tl (hd V384))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V384))))) (tl (hd V384))) (shen.case-form (tl V384) V385))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V387) (cond ((and (cons? V387) (= () (tl V387))) (hd V387)) ((cons? V387) (cons and (cons (hd V387) (cons (shen.embed-and (tl V387)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V389) (cons true (cons (cons shen.f_error (cons V389 ())) ())))

(defun shen.sys-error (V391) (simple-error (cn "system function " (shen.app V391 ": unexpected argument
" shen.a))))




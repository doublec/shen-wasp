"Copyright (c) 2019 Bruno Deferrari.
BSD 3-Clause License: http://opensource.org/licenses/BSD-3-Clause"

(defun shen.x.expand-dynamic.initialise () (do (set shen.x.expand-dynamic.*external-symbols* ()) (set shen.x.expand-dynamic.*arities* ())))

(defun shen.x.expand-dynamic.expand-dynamic (V5077) (cond ((= () V5077) ()) ((and (cons? V5077) (and (cons? (hd V5077)) (and (= declare (hd (hd V5077))) (and (cons? (tl (hd V5077))) (and (cons? (tl (tl (hd V5077)))) (= () (tl (tl (tl (hd V5077)))))))))) (append (shen.x.expand-dynamic.expand-declare (hd V5077)) (shen.x.expand-dynamic.expand-dynamic (tl V5077)))) ((and (cons? V5077) (and (cons? (hd V5077)) (and (= put (hd (hd V5077))) (and (cons? (tl (hd V5077))) (and (cons? (hd (tl (hd V5077)))) (and (= intern (hd (hd (tl (hd V5077))))) (and (cons? (tl (hd (tl (hd V5077))))) (and (= "shen" (hd (tl (hd (tl (hd V5077)))))) (and (= () (tl (tl (hd (tl (hd V5077)))))) (and (cons? (tl (tl (hd V5077)))) (and (= shen.external-symbols (hd (tl (tl (hd V5077))))) (and (cons? (tl (tl (tl (hd V5077))))) (and (cons? (tl (tl (tl (tl (hd V5077)))))) (= () (tl (tl (tl (tl (tl (hd V5077)))))))))))))))))))) (do (set shen.x.expand-dynamic.*external-symbols* (eval-kl (hd (tl (tl (tl (hd V5077))))))) (cons (hd V5077) (shen.x.expand-dynamic.expand-dynamic (tl V5077))))) ((and (cons? V5077) (and (cons? (hd V5077)) (and (= shen.initialise_arity_table (hd (hd V5077))) (and (cons? (tl (hd V5077))) (= () (tl (tl (hd V5077)))))))) (do (set shen.x.expand-dynamic.*arities* (eval-kl (hd (tl (hd V5077))))) (cons (hd V5077) (shen.x.expand-dynamic.expand-dynamic (tl V5077))))) ((and (cons? V5077) (and (cons? (hd V5077)) (and (= shen.for-each (hd (hd V5077))) (and (cons? (tl (hd V5077))) (and (cons? (hd (tl (hd V5077)))) (and (= lambda (hd (hd (tl (hd V5077))))) (and (cons? (tl (hd (tl (hd V5077))))) (and (cons? (tl (tl (hd (tl (hd V5077)))))) (and (cons? (hd (tl (tl (hd (tl (hd V5077))))))) (and (= shen.set-lambda-form-entry (hd (hd (tl (tl (hd (tl (hd V5077)))))))) (and (cons? (tl (hd (tl (tl (hd (tl (hd V5077)))))))) (and (= () (tl (tl (hd (tl (tl (hd (tl (hd V5077))))))))) (and (= () (tl (tl (tl (hd (tl (hd V5077))))))) (and (cons? (tl (tl (hd V5077)))) (and (= () (tl (tl (tl (hd V5077))))) (= (hd (tl (hd (tl (tl (hd (tl (hd V5077)))))))) (hd (tl (hd (tl (hd V5077))))))))))))))))))))) (append (shen.x.expand-dynamic.expand-lambda-entries (hd (tl (tl (hd V5077))))) (shen.x.expand-dynamic.expand-dynamic (tl V5077)))) ((cons? V5077) (cons (hd V5077) (shen.x.expand-dynamic.expand-dynamic (tl V5077)))) (true (shen.f_error shen.x.expand-dynamic.expand-dynamic))))

(defun shen.x.expand-dynamic.expand-declare (V5079) (cond ((and (cons? V5079) (and (= declare (hd V5079)) (and (cons? (tl V5079)) (and (cons? (tl (tl V5079))) (= () (tl (tl (tl V5079)))))))) (let Eval (eval-kl V5079) (let F* (concat shen.type-signature-of- (hd (tl V5079))) (let KlDef (ps F*) (let RecordSig (cons set (cons shen.*signedfuncs* (cons (cons cons (cons (cons cons (tl V5079)) (cons (cons value (cons shen.*signedfuncs* ())) ()))) ()))) (let RecordLambda (cons shen.set-lambda-form-entry (cons (cons cons (cons F* (cons (shen.lambda-form F* 3) ()))) ())) (cons KlDef (cons RecordSig (cons RecordLambda ()))))))))) (true (shen.f_error shen.x.expand-dynamic.expand-declare))))

(defun shen.x.expand-dynamic.expand-lambda-entries (V5082) (cond ((= () V5082) ()) ((and (cons? V5082) (and (= mapcan (hd V5082)) (and (cons? (tl V5082)) (and (cons? (hd (tl V5082))) (and (= lambda (hd (hd (tl V5082)))) (and (cons? (tl (hd (tl V5082)))) (and (cons? (tl (tl (hd (tl V5082))))) (and (cons? (hd (tl (tl (hd (tl V5082)))))) (and (= shen.lambda-form-entry (hd (hd (tl (tl (hd (tl V5082))))))) (and (cons? (tl (hd (tl (tl (hd (tl V5082))))))) (and (= () (tl (tl (hd (tl (tl (hd (tl V5082)))))))) (and (= () (tl (tl (tl (hd (tl V5082)))))) (and (cons? (tl (tl V5082))) (and (cons? (hd (tl (tl V5082)))) (and (= external (hd (hd (tl (tl V5082))))) (and (cons? (tl (hd (tl (tl V5082))))) (and (cons? (hd (tl (hd (tl (tl V5082)))))) (and (= intern (hd (hd (tl (hd (tl (tl V5082))))))) (and (cons? (tl (hd (tl (hd (tl (tl V5082))))))) (and (= "shen" (hd (tl (hd (tl (hd (tl (tl V5082)))))))) (and (= () (tl (tl (hd (tl (hd (tl (tl V5082)))))))) (and (= () (tl (tl (hd (tl (tl V5082)))))) (and (= () (tl (tl (tl V5082)))) (= (hd (tl (hd (tl (tl (hd (tl V5082))))))) (hd (tl (hd (tl V5082)))))))))))))))))))))))))))) (mapcan (lambda F (shen.x.expand-dynamic.expand-lambda-form-entry F)) (value shen.x.expand-dynamic.*external-symbols*))) ((and (cons? V5082) (and (= cons (hd V5082)) (and (cons? (tl V5082)) (and (cons? (hd (tl V5082))) (and (= cons (hd (hd (tl V5082)))) (and (cons? (tl (hd (tl V5082)))) (and (cons? (tl (tl (hd (tl V5082))))) (and (= () (tl (tl (tl (hd (tl V5082)))))) (and (cons? (tl (tl V5082))) (= () (tl (tl (tl V5082))))))))))))) (cons (cons shen.set-lambda-form-entry (cons (hd (tl V5082)) ())) (shen.x.expand-dynamic.expand-lambda-entries (hd (tl (tl V5082)))))) (true (shen.f_error shen.x.expand-dynamic.expand-lambda-entries))))

(defun shen.x.expand-dynamic.get-arity (V5094 V5095) (cond ((= () V5095) -1) ((and (cons? V5095) (and (cons? (tl V5095)) (= (hd V5095) V5094))) (hd (tl V5095))) ((and (cons? V5095) (cons? (tl V5095))) (shen.x.expand-dynamic.get-arity V5094 (tl (tl V5095)))) (true (shen.f_error shen.x.expand-dynamic.get-arity))))

(defun shen.x.expand-dynamic.expand-lambda-form-entry (V5097) (cond ((= package V5097) ()) ((= receive V5097) ()) (true (let ArityF (shen.x.expand-dynamic.get-arity V5097 (value shen.x.expand-dynamic.*arities*)) (if (= ArityF -1) () (if (= ArityF 0) () (cons (cons shen.set-lambda-form-entry (cons (cons cons (cons V5097 (cons (shen.lambda-form V5097 ArityF) ()))) ())) ())))))))

(defun shen.x.expand-dynamic.split-defuns-h (V5100 V5101) (cond ((and (cons? V5100) (and (cons? (hd V5100)) (and (= defun (hd (hd V5100))) (tuple? V5101)))) (shen.x.expand-dynamic.split-defuns-h (tl V5100) (@p (cons (hd V5100) (fst V5101)) (snd V5101)))) ((and (cons? V5100) (tuple? V5101)) (shen.x.expand-dynamic.split-defuns-h (tl V5100) (@p (fst V5101) (cons (hd V5100) (snd V5101))))) ((and (= () V5100) (tuple? V5101)) (@p (reverse (fst V5101)) (reverse (snd V5101)))) (true (shen.f_error shen.x.expand-dynamic.split-defuns-h))))

(defun shen.x.expand-dynamic.split-defuns (V5103) (shen.x.expand-dynamic.split-defuns-h V5103 (@p () ())))

(defun shen.x.expand-dynamic.wrap-in-defun (V5107 V5108 V5109) (cons defun (cons V5107 (cons V5108 (cons (shen.x.expand-dynamic.to-single-expression V5109) ())))))

(defun shen.x.expand-dynamic.to-single-expression (V5111) (cond ((and (cons? V5111) (= () (tl V5111))) (hd V5111)) ((cons? V5111) (cons do (cons (hd V5111) (cons (shen.x.expand-dynamic.to-single-expression (tl V5111)) ())))) (true (shen.f_error shen.x.expand-dynamic.to-single-expression))))




"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.typecheck (V2673 V2674) (let Curry (shen.curry V2673) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2674)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2676) (cond ((and (cons? V2676) (shen.special? (hd V2676))) (cons (hd V2676) (map (lambda Y (shen.curry Y)) (tl V2676)))) ((and (cons? V2676) (and (cons? (tl V2676)) (shen.extraspecial? (hd V2676)))) V2676) ((and (cons? V2676) (and (= type (hd V2676)) (and (cons? (tl V2676)) (and (cons? (tl (tl V2676))) (= () (tl (tl (tl V2676)))))))) (cons type (cons (shen.curry (hd (tl V2676))) (tl (tl V2676))))) ((and (cons? V2676) (and (cons? (tl V2676)) (cons? (tl (tl V2676))))) (shen.curry (cons (cons (hd V2676) (cons (hd (tl V2676)) ())) (tl (tl V2676))))) ((and (cons? V2676) (and (cons? (tl V2676)) (= () (tl (tl V2676))))) (cons (shen.curry (hd V2676)) (cons (shen.curry (hd (tl V2676))) ()))) (true V2676)))

(defun shen.special? (V2678) (element? V2678 (value shen.*special*)))

(defun shen.extraspecial? (V2680) (element? V2680 (value shen.*extraspecial*)))

(defun shen.t* (V2685 V2686 V2687 V2688) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2687) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2687 (freeze (bind Error (shen.errormaxinfs) V2687 V2688))))) (if (= Case false) (let Case (let V2665 (shen.lazyderef V2685 V2687) (if (= fail V2665) (do (shen.incinfs) (cut Throwcontrol V2687 (freeze (shen.prolog-failure V2687 V2688)))) false)) (if (= Case false) (let Case (let V2666 (shen.lazyderef V2685 V2687) (if (cons? V2666) (let X (hd V2666) (let V2667 (shen.lazyderef (tl V2666) V2687) (if (cons? V2667) (let V2668 (shen.lazyderef (hd V2667) V2687) (if (= : V2668) (let V2669 (shen.lazyderef (tl V2667) V2687) (if (cons? V2669) (let A (hd V2669) (let V2670 (shen.lazyderef (tl V2669) V2687) (if (= () V2670) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2687 (freeze (cut Throwcontrol V2687 (freeze (shen.th* X A V2686 V2687 V2688)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2687) (do (shen.incinfs) (shen.show V2685 V2686 V2687 (freeze (bind Datatypes (value shen.*datatypes*) V2687 (freeze (shen.udefs* V2685 V2686 Datatypes V2687 V2688))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2694) (cond ((= + V2694) (set shen.*shen-type-theory-enabled?* true)) ((= - V2694) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2705 V2706) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2712 V2713 V2714 V2715 V2716) (let Case (let V2661 (shen.lazyderef V2714 V2715) (if (cons? V2661) (let D (hd V2661) (do (shen.incinfs) (call (cons D (cons V2712 (cons V2713 ()))) V2715 V2716))) false)) (if (= Case false) (let V2662 (shen.lazyderef V2714 V2715) (if (cons? V2662) (let Ds (tl V2662) (do (shen.incinfs) (shen.udefs* V2712 V2713 Ds V2715 V2716))) false)) Case)))

(defun shen.th* (V2722 V2723 V2724 V2725 V2726) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2722 (cons : (cons V2723 ()))) V2724 V2725 (freeze (fwhen false V2725 V2726)))) (if (= Case false) (let Case (let F (shen.newpv V2725) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2722 V2725)) V2725 (freeze (bind F (shen.sigf (shen.lazyderef V2722 V2725)) V2725 (freeze (call (cons F (cons V2723 ())) V2725 V2726))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2722 V2723 V2725 V2726)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2722 V2723 V2724 V2725 V2726)) (if (= Case false) (let Case (let V2557 (shen.lazyderef V2722 V2725) (if (cons? V2557) (let F (hd V2557) (let V2558 (shen.lazyderef (tl V2557) V2725) (if (= () V2558) (do (shen.incinfs) (shen.th* F (cons --> (cons V2723 ())) V2724 V2725 V2726)) false))) false)) (if (= Case false) (let Case (let V2559 (shen.lazyderef V2722 V2725) (if (cons? V2559) (let F (hd V2559) (let V2560 (shen.lazyderef (tl V2559) V2725) (if (cons? V2560) (let X (hd V2560) (let V2561 (shen.lazyderef (tl V2560) V2725) (if (= () V2561) (let B (shen.newpv V2725) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2723 ()))) V2724 V2725 (freeze (shen.th* X B V2724 V2725 V2726))))) false))) false))) false)) (if (= Case false) (let Case (let V2562 (shen.lazyderef V2722 V2725) (if (cons? V2562) (let V2563 (shen.lazyderef (hd V2562) V2725) (if (= cons V2563) (let V2564 (shen.lazyderef (tl V2562) V2725) (if (cons? V2564) (let X (hd V2564) (let V2565 (shen.lazyderef (tl V2564) V2725) (if (cons? V2565) (let Y (hd V2565) (let V2566 (shen.lazyderef (tl V2565) V2725) (if (= () V2566) (let V2567 (shen.lazyderef V2723 V2725) (if (cons? V2567) (let V2568 (shen.lazyderef (hd V2567) V2725) (if (= list V2568) (let V2569 (shen.lazyderef (tl V2567) V2725) (if (cons? V2569) (let A (hd V2569) (let V2570 (shen.lazyderef (tl V2569) V2725) (if (= () V2570) (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons list (cons A ())) V2724 V2725 V2726)))) (if (shen.pvar? V2570) (do (shen.bindv V2570 () V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons list (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2570 V2725) Result))) false)))) (if (shen.pvar? V2569) (let A (shen.newpv V2725) (do (shen.bindv V2569 (cons A ()) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons list (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2569 V2725) Result)))) false))) (if (shen.pvar? V2568) (do (shen.bindv V2568 list V2725) (let Result (let V2571 (shen.lazyderef (tl V2567) V2725) (if (cons? V2571) (let A (hd V2571) (let V2572 (shen.lazyderef (tl V2571) V2725) (if (= () V2572) (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons list (cons A ())) V2724 V2725 V2726)))) (if (shen.pvar? V2572) (do (shen.bindv V2572 () V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons list (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2572 V2725) Result))) false)))) (if (shen.pvar? V2571) (let A (shen.newpv V2725) (do (shen.bindv V2571 (cons A ()) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons list (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2571 V2725) Result)))) false))) (do (shen.unbindv V2568 V2725) Result))) false))) (if (shen.pvar? V2567) (let A (shen.newpv V2725) (do (shen.bindv V2567 (cons list (cons A ())) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons list (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2567 V2725) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2573 (shen.lazyderef V2722 V2725) (if (cons? V2573) (let V2574 (shen.lazyderef (hd V2573) V2725) (if (= @p V2574) (let V2575 (shen.lazyderef (tl V2573) V2725) (if (cons? V2575) (let X (hd V2575) (let V2576 (shen.lazyderef (tl V2575) V2725) (if (cons? V2576) (let Y (hd V2576) (let V2577 (shen.lazyderef (tl V2576) V2725) (if (= () V2577) (let V2578 (shen.lazyderef V2723 V2725) (if (cons? V2578) (let A (hd V2578) (let V2579 (shen.lazyderef (tl V2578) V2725) (if (cons? V2579) (let V2580 (shen.lazyderef (hd V2579) V2725) (if (= * V2580) (let V2581 (shen.lazyderef (tl V2579) V2725) (if (cons? V2581) (let B (hd V2581) (let V2582 (shen.lazyderef (tl V2581) V2725) (if (= () V2582) (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y B V2724 V2725 V2726)))) (if (shen.pvar? V2582) (do (shen.bindv V2582 () V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y B V2724 V2725 V2726)))) (do (shen.unbindv V2582 V2725) Result))) false)))) (if (shen.pvar? V2581) (let B (shen.newpv V2725) (do (shen.bindv V2581 (cons B ()) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y B V2724 V2725 V2726)))) (do (shen.unbindv V2581 V2725) Result)))) false))) (if (shen.pvar? V2580) (do (shen.bindv V2580 * V2725) (let Result (let V2583 (shen.lazyderef (tl V2579) V2725) (if (cons? V2583) (let B (hd V2583) (let V2584 (shen.lazyderef (tl V2583) V2725) (if (= () V2584) (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y B V2724 V2725 V2726)))) (if (shen.pvar? V2584) (do (shen.bindv V2584 () V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y B V2724 V2725 V2726)))) (do (shen.unbindv V2584 V2725) Result))) false)))) (if (shen.pvar? V2583) (let B (shen.newpv V2725) (do (shen.bindv V2583 (cons B ()) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y B V2724 V2725 V2726)))) (do (shen.unbindv V2583 V2725) Result)))) false))) (do (shen.unbindv V2580 V2725) Result))) false))) (if (shen.pvar? V2579) (let B (shen.newpv V2725) (do (shen.bindv V2579 (cons * (cons B ())) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y B V2724 V2725 V2726)))) (do (shen.unbindv V2579 V2725) Result)))) false)))) (if (shen.pvar? V2578) (let A (shen.newpv V2725) (let B (shen.newpv V2725) (do (shen.bindv V2578 (cons A (cons * (cons B ()))) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y B V2724 V2725 V2726)))) (do (shen.unbindv V2578 V2725) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2585 (shen.lazyderef V2722 V2725) (if (cons? V2585) (let V2586 (shen.lazyderef (hd V2585) V2725) (if (= @v V2586) (let V2587 (shen.lazyderef (tl V2585) V2725) (if (cons? V2587) (let X (hd V2587) (let V2588 (shen.lazyderef (tl V2587) V2725) (if (cons? V2588) (let Y (hd V2588) (let V2589 (shen.lazyderef (tl V2588) V2725) (if (= () V2589) (let V2590 (shen.lazyderef V2723 V2725) (if (cons? V2590) (let V2591 (shen.lazyderef (hd V2590) V2725) (if (= vector V2591) (let V2592 (shen.lazyderef (tl V2590) V2725) (if (cons? V2592) (let A (hd V2592) (let V2593 (shen.lazyderef (tl V2592) V2725) (if (= () V2593) (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons vector (cons A ())) V2724 V2725 V2726)))) (if (shen.pvar? V2593) (do (shen.bindv V2593 () V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons vector (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2593 V2725) Result))) false)))) (if (shen.pvar? V2592) (let A (shen.newpv V2725) (do (shen.bindv V2592 (cons A ()) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons vector (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2592 V2725) Result)))) false))) (if (shen.pvar? V2591) (do (shen.bindv V2591 vector V2725) (let Result (let V2594 (shen.lazyderef (tl V2590) V2725) (if (cons? V2594) (let A (hd V2594) (let V2595 (shen.lazyderef (tl V2594) V2725) (if (= () V2595) (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons vector (cons A ())) V2724 V2725 V2726)))) (if (shen.pvar? V2595) (do (shen.bindv V2595 () V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons vector (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2595 V2725) Result))) false)))) (if (shen.pvar? V2594) (let A (shen.newpv V2725) (do (shen.bindv V2594 (cons A ()) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons vector (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2594 V2725) Result)))) false))) (do (shen.unbindv V2591 V2725) Result))) false))) (if (shen.pvar? V2590) (let A (shen.newpv V2725) (do (shen.bindv V2590 (cons vector (cons A ())) V2725) (let Result (do (shen.incinfs) (shen.th* X A V2724 V2725 (freeze (shen.th* Y (cons vector (cons A ())) V2724 V2725 V2726)))) (do (shen.unbindv V2590 V2725) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2596 (shen.lazyderef V2722 V2725) (if (cons? V2596) (let V2597 (shen.lazyderef (hd V2596) V2725) (if (= @s V2597) (let V2598 (shen.lazyderef (tl V2596) V2725) (if (cons? V2598) (let X (hd V2598) (let V2599 (shen.lazyderef (tl V2598) V2725) (if (cons? V2599) (let Y (hd V2599) (let V2600 (shen.lazyderef (tl V2599) V2725) (if (= () V2600) (let V2601 (shen.lazyderef V2723 V2725) (if (= string V2601) (do (shen.incinfs) (shen.th* X string V2724 V2725 (freeze (shen.th* Y string V2724 V2725 V2726)))) (if (shen.pvar? V2601) (do (shen.bindv V2601 string V2725) (let Result (do (shen.incinfs) (shen.th* X string V2724 V2725 (freeze (shen.th* Y string V2724 V2725 V2726)))) (do (shen.unbindv V2601 V2725) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2602 (shen.lazyderef V2722 V2725) (if (cons? V2602) (let V2603 (shen.lazyderef (hd V2602) V2725) (if (= lambda V2603) (let V2604 (shen.lazyderef (tl V2602) V2725) (if (cons? V2604) (let X (hd V2604) (let V2605 (shen.lazyderef (tl V2604) V2725) (if (cons? V2605) (let Y (hd V2605) (let V2606 (shen.lazyderef (tl V2605) V2725) (if (= () V2606) (let V2607 (shen.lazyderef V2723 V2725) (if (cons? V2607) (let A (hd V2607) (let V2608 (shen.lazyderef (tl V2607) V2725) (if (cons? V2608) (let V2609 (shen.lazyderef (hd V2608) V2725) (if (= --> V2609) (let V2610 (shen.lazyderef (tl V2608) V2725) (if (cons? V2610) (let B (hd V2610) (let V2611 (shen.lazyderef (tl V2610) V2725) (if (= () V2611) (let Z (shen.newpv V2725) (let X&& (shen.newpv V2725) (do (shen.incinfs) (bind X&& (shen.placeholder) V2725 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Y V2725)) V2725 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2724) V2725 V2726)))))))) (if (shen.pvar? V2611) (do (shen.bindv V2611 () V2725) (let Result (let Z (shen.newpv V2725) (let X&& (shen.newpv V2725) (do (shen.incinfs) (bind X&& (shen.placeholder) V2725 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Y V2725)) V2725 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2724) V2725 V2726)))))))) (do (shen.unbindv V2611 V2725) Result))) false)))) (if (shen.pvar? V2610) (let B (shen.newpv V2725) (do (shen.bindv V2610 (cons B ()) V2725) (let Result (let Z (shen.newpv V2725) (let X&& (shen.newpv V2725) (do (shen.incinfs) (bind X&& (shen.placeholder) V2725 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Y V2725)) V2725 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2724) V2725 V2726)))))))) (do (shen.unbindv V2610 V2725) Result)))) false))) (if (shen.pvar? V2609) (do (shen.bindv V2609 --> V2725) (let Result (let V2612 (shen.lazyderef (tl V2608) V2725) (if (cons? V2612) (let B (hd V2612) (let V2613 (shen.lazyderef (tl V2612) V2725) (if (= () V2613) (let Z (shen.newpv V2725) (let X&& (shen.newpv V2725) (do (shen.incinfs) (bind X&& (shen.placeholder) V2725 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Y V2725)) V2725 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2724) V2725 V2726)))))))) (if (shen.pvar? V2613) (do (shen.bindv V2613 () V2725) (let Result (let Z (shen.newpv V2725) (let X&& (shen.newpv V2725) (do (shen.incinfs) (bind X&& (shen.placeholder) V2725 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Y V2725)) V2725 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2724) V2725 V2726)))))))) (do (shen.unbindv V2613 V2725) Result))) false)))) (if (shen.pvar? V2612) (let B (shen.newpv V2725) (do (shen.bindv V2612 (cons B ()) V2725) (let Result (let Z (shen.newpv V2725) (let X&& (shen.newpv V2725) (do (shen.incinfs) (bind X&& (shen.placeholder) V2725 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Y V2725)) V2725 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2724) V2725 V2726)))))))) (do (shen.unbindv V2612 V2725) Result)))) false))) (do (shen.unbindv V2609 V2725) Result))) false))) (if (shen.pvar? V2608) (let B (shen.newpv V2725) (do (shen.bindv V2608 (cons --> (cons B ())) V2725) (let Result (let Z (shen.newpv V2725) (let X&& (shen.newpv V2725) (do (shen.incinfs) (bind X&& (shen.placeholder) V2725 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Y V2725)) V2725 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2724) V2725 V2726)))))))) (do (shen.unbindv V2608 V2725) Result)))) false)))) (if (shen.pvar? V2607) (let A (shen.newpv V2725) (let B (shen.newpv V2725) (do (shen.bindv V2607 (cons A (cons --> (cons B ()))) V2725) (let Result (let Z (shen.newpv V2725) (let X&& (shen.newpv V2725) (do (shen.incinfs) (bind X&& (shen.placeholder) V2725 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Y V2725)) V2725 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2724) V2725 V2726)))))))) (do (shen.unbindv V2607 V2725) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2614 (shen.lazyderef V2722 V2725) (if (cons? V2614) (let V2615 (shen.lazyderef (hd V2614) V2725) (if (= let V2615) (let V2616 (shen.lazyderef (tl V2614) V2725) (if (cons? V2616) (let X (hd V2616) (let V2617 (shen.lazyderef (tl V2616) V2725) (if (cons? V2617) (let Y (hd V2617) (let V2618 (shen.lazyderef (tl V2617) V2725) (if (cons? V2618) (let Z (hd V2618) (let V2619 (shen.lazyderef (tl V2618) V2725) (if (= () V2619) (let W (shen.newpv V2725) (let X&& (shen.newpv V2725) (let B (shen.newpv V2725) (do (shen.incinfs) (shen.th* Y B V2724 V2725 (freeze (bind X&& (shen.placeholder) V2725 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2725) (shen.lazyderef X V2725) (shen.lazyderef Z V2725)) V2725 (freeze (shen.th* W V2723 (cons (cons X&& (cons : (cons B ()))) V2724) V2725 V2726))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2620 (shen.lazyderef V2722 V2725) (if (cons? V2620) (let V2621 (shen.lazyderef (hd V2620) V2725) (if (= open V2621) (let V2622 (shen.lazyderef (tl V2620) V2725) (if (cons? V2622) (let FileName (hd V2622) (let V2623 (shen.lazyderef (tl V2622) V2725) (if (cons? V2623) (let Direction2553 (hd V2623) (let V2624 (shen.lazyderef (tl V2623) V2725) (if (= () V2624) (let V2625 (shen.lazyderef V2723 V2725) (if (cons? V2625) (let V2626 (shen.lazyderef (hd V2625) V2725) (if (= stream V2626) (let V2627 (shen.lazyderef (tl V2625) V2725) (if (cons? V2627) (let Direction (hd V2627) (let V2628 (shen.lazyderef (tl V2627) V2725) (if (= () V2628) (do (shen.incinfs) (unify! Direction Direction2553 V2725 (freeze (cut Throwcontrol V2725 (freeze (fwhen (element? (shen.lazyderef Direction V2725) (cons in (cons out ()))) V2725 (freeze (shen.th* FileName string V2724 V2725 V2726)))))))) (if (shen.pvar? V2628) (do (shen.bindv V2628 () V2725) (let Result (do (shen.incinfs) (unify! Direction Direction2553 V2725 (freeze (cut Throwcontrol V2725 (freeze (fwhen (element? (shen.lazyderef Direction V2725) (cons in (cons out ()))) V2725 (freeze (shen.th* FileName string V2724 V2725 V2726)))))))) (do (shen.unbindv V2628 V2725) Result))) false)))) (if (shen.pvar? V2627) (let Direction (shen.newpv V2725) (do (shen.bindv V2627 (cons Direction ()) V2725) (let Result (do (shen.incinfs) (unify! Direction Direction2553 V2725 (freeze (cut Throwcontrol V2725 (freeze (fwhen (element? (shen.lazyderef Direction V2725) (cons in (cons out ()))) V2725 (freeze (shen.th* FileName string V2724 V2725 V2726)))))))) (do (shen.unbindv V2627 V2725) Result)))) false))) (if (shen.pvar? V2626) (do (shen.bindv V2626 stream V2725) (let Result (let V2629 (shen.lazyderef (tl V2625) V2725) (if (cons? V2629) (let Direction (hd V2629) (let V2630 (shen.lazyderef (tl V2629) V2725) (if (= () V2630) (do (shen.incinfs) (unify! Direction Direction2553 V2725 (freeze (cut Throwcontrol V2725 (freeze (fwhen (element? (shen.lazyderef Direction V2725) (cons in (cons out ()))) V2725 (freeze (shen.th* FileName string V2724 V2725 V2726)))))))) (if (shen.pvar? V2630) (do (shen.bindv V2630 () V2725) (let Result (do (shen.incinfs) (unify! Direction Direction2553 V2725 (freeze (cut Throwcontrol V2725 (freeze (fwhen (element? (shen.lazyderef Direction V2725) (cons in (cons out ()))) V2725 (freeze (shen.th* FileName string V2724 V2725 V2726)))))))) (do (shen.unbindv V2630 V2725) Result))) false)))) (if (shen.pvar? V2629) (let Direction (shen.newpv V2725) (do (shen.bindv V2629 (cons Direction ()) V2725) (let Result (do (shen.incinfs) (unify! Direction Direction2553 V2725 (freeze (cut Throwcontrol V2725 (freeze (fwhen (element? (shen.lazyderef Direction V2725) (cons in (cons out ()))) V2725 (freeze (shen.th* FileName string V2724 V2725 V2726)))))))) (do (shen.unbindv V2629 V2725) Result)))) false))) (do (shen.unbindv V2626 V2725) Result))) false))) (if (shen.pvar? V2625) (let Direction (shen.newpv V2725) (do (shen.bindv V2625 (cons stream (cons Direction ())) V2725) (let Result (do (shen.incinfs) (unify! Direction Direction2553 V2725 (freeze (cut Throwcontrol V2725 (freeze (fwhen (element? (shen.lazyderef Direction V2725) (cons in (cons out ()))) V2725 (freeze (shen.th* FileName string V2724 V2725 V2726)))))))) (do (shen.unbindv V2625 V2725) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2631 (shen.lazyderef V2722 V2725) (if (cons? V2631) (let V2632 (shen.lazyderef (hd V2631) V2725) (if (= type V2632) (let V2633 (shen.lazyderef (tl V2631) V2725) (if (cons? V2633) (let X (hd V2633) (let V2634 (shen.lazyderef (tl V2633) V2725) (if (cons? V2634) (let A (hd V2634) (let V2635 (shen.lazyderef (tl V2634) V2725) (if (= () V2635) (do (shen.incinfs) (cut Throwcontrol V2725 (freeze (unify A V2723 V2725 (freeze (shen.th* X A V2724 V2725 V2726)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2636 (shen.lazyderef V2722 V2725) (if (cons? V2636) (let V2637 (shen.lazyderef (hd V2636) V2725) (if (= input+ V2637) (let V2638 (shen.lazyderef (tl V2636) V2725) (if (cons? V2638) (let A (hd V2638) (let V2639 (shen.lazyderef (tl V2638) V2725) (if (cons? V2639) (let Stream (hd V2639) (let V2640 (shen.lazyderef (tl V2639) V2725) (if (= () V2640) (let C (shen.newpv V2725) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2725)) V2725 (freeze (unify V2723 C V2725 (freeze (shen.th* Stream (cons stream (cons in ())) V2724 V2725 V2726))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2641 (shen.lazyderef V2722 V2725) (if (cons? V2641) (let V2642 (shen.lazyderef (hd V2641) V2725) (if (= set V2642) (let V2643 (shen.lazyderef (tl V2641) V2725) (if (cons? V2643) (let Var (hd V2643) (let V2644 (shen.lazyderef (tl V2643) V2725) (if (cons? V2644) (let Val (hd V2644) (let V2645 (shen.lazyderef (tl V2644) V2725) (if (= () V2645) (do (shen.incinfs) (cut Throwcontrol V2725 (freeze (shen.th* Var symbol V2724 V2725 (freeze (cut Throwcontrol V2725 (freeze (shen.th* (cons value (cons Var ())) V2723 V2724 V2725 (freeze (shen.th* Val V2723 V2724 V2725 V2726)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2725) (do (shen.incinfs) (shen.t*-hyps V2724 NewHyp V2725 (freeze (shen.th* V2722 V2723 NewHyp V2725 V2726))))) (if (= Case false) (let Case (let V2646 (shen.lazyderef V2722 V2725) (if (cons? V2646) (let V2647 (shen.lazyderef (hd V2646) V2725) (if (= define V2647) (let V2648 (shen.lazyderef (tl V2646) V2725) (if (cons? V2648) (let F (hd V2648) (let X (tl V2648) (do (shen.incinfs) (cut Throwcontrol V2725 (freeze (shen.t*-def (cons define (cons F X)) V2723 V2724 V2725 V2726)))))) false)) false)) false)) (if (= Case false) (let Case (let V2649 (shen.lazyderef V2722 V2725) (if (cons? V2649) (let V2650 (shen.lazyderef (hd V2649) V2725) (if (= defmacro V2650) (let V2651 (shen.lazyderef V2723 V2725) (if (= unit V2651) (do (shen.incinfs) (cut Throwcontrol V2725 V2726)) (if (shen.pvar? V2651) (do (shen.bindv V2651 unit V2725) (let Result (do (shen.incinfs) (cut Throwcontrol V2725 V2726)) (do (shen.unbindv V2651 V2725) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2652 (shen.lazyderef V2722 V2725) (if (cons? V2652) (let V2653 (shen.lazyderef (hd V2652) V2725) (if (= shen.process-datatype V2653) (let V2654 (shen.lazyderef V2723 V2725) (if (= symbol V2654) (do (shen.incinfs) (thaw V2726)) (if (shen.pvar? V2654) (do (shen.bindv V2654 symbol V2725) (let Result (do (shen.incinfs) (thaw V2726)) (do (shen.unbindv V2654 V2725) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2655 (shen.lazyderef V2722 V2725) (if (cons? V2655) (let V2656 (shen.lazyderef (hd V2655) V2725) (if (= shen.synonyms-help V2656) (let V2657 (shen.lazyderef V2723 V2725) (if (= symbol V2657) (do (shen.incinfs) (thaw V2726)) (if (shen.pvar? V2657) (do (shen.bindv V2657 symbol V2725) (let Result (do (shen.incinfs) (thaw V2726)) (do (shen.unbindv V2657 V2725) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2725) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2725 (freeze (shen.udefs* (cons V2722 (cons : (cons V2723 ()))) V2724 Datatypes V2725 V2726))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2731 V2732 V2733 V2734) (let Case (let V2468 (shen.lazyderef V2731 V2733) (if (cons? V2468) (let V2469 (shen.lazyderef (hd V2468) V2733) (if (cons? V2469) (let V2470 (shen.lazyderef (hd V2469) V2733) (if (cons? V2470) (let V2471 (shen.lazyderef (hd V2470) V2733) (if (= cons V2471) (let V2472 (shen.lazyderef (tl V2470) V2733) (if (cons? V2472) (let X (hd V2472) (let V2473 (shen.lazyderef (tl V2472) V2733) (if (cons? V2473) (let Y (hd V2473) (let V2474 (shen.lazyderef (tl V2473) V2733) (if (= () V2474) (let V2475 (shen.lazyderef (tl V2469) V2733) (if (cons? V2475) (let V2476 (shen.lazyderef (hd V2475) V2733) (if (= : V2476) (let V2477 (shen.lazyderef (tl V2475) V2733) (if (cons? V2477) (let V2478 (shen.lazyderef (hd V2477) V2733) (if (cons? V2478) (let V2479 (shen.lazyderef (hd V2478) V2733) (if (= list V2479) (let V2480 (shen.lazyderef (tl V2478) V2733) (if (cons? V2480) (let A (hd V2480) (let V2481 (shen.lazyderef (tl V2480) V2733) (if (= () V2481) (let V2482 (shen.lazyderef (tl V2477) V2733) (if (= () V2482) (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2482) (do (shen.bindv V2482 () V2733) (let Result (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2482 V2733) Result))) false))) (if (shen.pvar? V2481) (do (shen.bindv V2481 () V2733) (let Result (let V2483 (shen.lazyderef (tl V2477) V2733) (if (= () V2483) (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2483) (do (shen.bindv V2483 () V2733) (let Result (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2483 V2733) Result))) false))) (do (shen.unbindv V2481 V2733) Result))) false)))) (if (shen.pvar? V2480) (let A (shen.newpv V2733) (do (shen.bindv V2480 (cons A ()) V2733) (let Result (let V2484 (shen.lazyderef (tl V2477) V2733) (if (= () V2484) (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2484) (do (shen.bindv V2484 () V2733) (let Result (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2484 V2733) Result))) false))) (do (shen.unbindv V2480 V2733) Result)))) false))) (if (shen.pvar? V2479) (do (shen.bindv V2479 list V2733) (let Result (let V2485 (shen.lazyderef (tl V2478) V2733) (if (cons? V2485) (let A (hd V2485) (let V2486 (shen.lazyderef (tl V2485) V2733) (if (= () V2486) (let V2487 (shen.lazyderef (tl V2477) V2733) (if (= () V2487) (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2487) (do (shen.bindv V2487 () V2733) (let Result (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2487 V2733) Result))) false))) (if (shen.pvar? V2486) (do (shen.bindv V2486 () V2733) (let Result (let V2488 (shen.lazyderef (tl V2477) V2733) (if (= () V2488) (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2488) (do (shen.bindv V2488 () V2733) (let Result (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2488 V2733) Result))) false))) (do (shen.unbindv V2486 V2733) Result))) false)))) (if (shen.pvar? V2485) (let A (shen.newpv V2733) (do (shen.bindv V2485 (cons A ()) V2733) (let Result (let V2489 (shen.lazyderef (tl V2477) V2733) (if (= () V2489) (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2489) (do (shen.bindv V2489 () V2733) (let Result (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2489 V2733) Result))) false))) (do (shen.unbindv V2485 V2733) Result)))) false))) (do (shen.unbindv V2479 V2733) Result))) false))) (if (shen.pvar? V2478) (let A (shen.newpv V2733) (do (shen.bindv V2478 (cons list (cons A ())) V2733) (let Result (let V2490 (shen.lazyderef (tl V2477) V2733) (if (= () V2490) (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2490) (do (shen.bindv V2490 () V2733) (let Result (let Hyp (tl V2468) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons list (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2490 V2733) Result))) false))) (do (shen.unbindv V2478 V2733) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2491 (shen.lazyderef V2731 V2733) (if (cons? V2491) (let V2492 (shen.lazyderef (hd V2491) V2733) (if (cons? V2492) (let V2493 (shen.lazyderef (hd V2492) V2733) (if (cons? V2493) (let V2494 (shen.lazyderef (hd V2493) V2733) (if (= @p V2494) (let V2495 (shen.lazyderef (tl V2493) V2733) (if (cons? V2495) (let X (hd V2495) (let V2496 (shen.lazyderef (tl V2495) V2733) (if (cons? V2496) (let Y (hd V2496) (let V2497 (shen.lazyderef (tl V2496) V2733) (if (= () V2497) (let V2498 (shen.lazyderef (tl V2492) V2733) (if (cons? V2498) (let V2499 (shen.lazyderef (hd V2498) V2733) (if (= : V2499) (let V2500 (shen.lazyderef (tl V2498) V2733) (if (cons? V2500) (let V2501 (shen.lazyderef (hd V2500) V2733) (if (cons? V2501) (let A (hd V2501) (let V2502 (shen.lazyderef (tl V2501) V2733) (if (cons? V2502) (let V2503 (shen.lazyderef (hd V2502) V2733) (if (= * V2503) (let V2504 (shen.lazyderef (tl V2502) V2733) (if (cons? V2504) (let B (hd V2504) (let V2505 (shen.lazyderef (tl V2504) V2733) (if (= () V2505) (let V2506 (shen.lazyderef (tl V2500) V2733) (if (= () V2506) (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2506) (do (shen.bindv V2506 () V2733) (let Result (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2506 V2733) Result))) false))) (if (shen.pvar? V2505) (do (shen.bindv V2505 () V2733) (let Result (let V2507 (shen.lazyderef (tl V2500) V2733) (if (= () V2507) (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2507) (do (shen.bindv V2507 () V2733) (let Result (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2507 V2733) Result))) false))) (do (shen.unbindv V2505 V2733) Result))) false)))) (if (shen.pvar? V2504) (let B (shen.newpv V2733) (do (shen.bindv V2504 (cons B ()) V2733) (let Result (let V2508 (shen.lazyderef (tl V2500) V2733) (if (= () V2508) (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2508) (do (shen.bindv V2508 () V2733) (let Result (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2508 V2733) Result))) false))) (do (shen.unbindv V2504 V2733) Result)))) false))) (if (shen.pvar? V2503) (do (shen.bindv V2503 * V2733) (let Result (let V2509 (shen.lazyderef (tl V2502) V2733) (if (cons? V2509) (let B (hd V2509) (let V2510 (shen.lazyderef (tl V2509) V2733) (if (= () V2510) (let V2511 (shen.lazyderef (tl V2500) V2733) (if (= () V2511) (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2511) (do (shen.bindv V2511 () V2733) (let Result (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2511 V2733) Result))) false))) (if (shen.pvar? V2510) (do (shen.bindv V2510 () V2733) (let Result (let V2512 (shen.lazyderef (tl V2500) V2733) (if (= () V2512) (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2512) (do (shen.bindv V2512 () V2733) (let Result (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2512 V2733) Result))) false))) (do (shen.unbindv V2510 V2733) Result))) false)))) (if (shen.pvar? V2509) (let B (shen.newpv V2733) (do (shen.bindv V2509 (cons B ()) V2733) (let Result (let V2513 (shen.lazyderef (tl V2500) V2733) (if (= () V2513) (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2513) (do (shen.bindv V2513 () V2733) (let Result (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2513 V2733) Result))) false))) (do (shen.unbindv V2509 V2733) Result)))) false))) (do (shen.unbindv V2503 V2733) Result))) false))) (if (shen.pvar? V2502) (let B (shen.newpv V2733) (do (shen.bindv V2502 (cons * (cons B ())) V2733) (let Result (let V2514 (shen.lazyderef (tl V2500) V2733) (if (= () V2514) (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2514) (do (shen.bindv V2514 () V2733) (let Result (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2514 V2733) Result))) false))) (do (shen.unbindv V2502 V2733) Result)))) false)))) (if (shen.pvar? V2501) (let A (shen.newpv V2733) (let B (shen.newpv V2733) (do (shen.bindv V2501 (cons A (cons * (cons B ()))) V2733) (let Result (let V2515 (shen.lazyderef (tl V2500) V2733) (if (= () V2515) (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2515) (do (shen.bindv V2515 () V2733) (let Result (let Hyp (tl V2491) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (shen.lazyderef B V2733) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2515 V2733) Result))) false))) (do (shen.unbindv V2501 V2733) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2516 (shen.lazyderef V2731 V2733) (if (cons? V2516) (let V2517 (shen.lazyderef (hd V2516) V2733) (if (cons? V2517) (let V2518 (shen.lazyderef (hd V2517) V2733) (if (cons? V2518) (let V2519 (shen.lazyderef (hd V2518) V2733) (if (= @v V2519) (let V2520 (shen.lazyderef (tl V2518) V2733) (if (cons? V2520) (let X (hd V2520) (let V2521 (shen.lazyderef (tl V2520) V2733) (if (cons? V2521) (let Y (hd V2521) (let V2522 (shen.lazyderef (tl V2521) V2733) (if (= () V2522) (let V2523 (shen.lazyderef (tl V2517) V2733) (if (cons? V2523) (let V2524 (shen.lazyderef (hd V2523) V2733) (if (= : V2524) (let V2525 (shen.lazyderef (tl V2523) V2733) (if (cons? V2525) (let V2526 (shen.lazyderef (hd V2525) V2733) (if (cons? V2526) (let V2527 (shen.lazyderef (hd V2526) V2733) (if (= vector V2527) (let V2528 (shen.lazyderef (tl V2526) V2733) (if (cons? V2528) (let A (hd V2528) (let V2529 (shen.lazyderef (tl V2528) V2733) (if (= () V2529) (let V2530 (shen.lazyderef (tl V2525) V2733) (if (= () V2530) (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2530) (do (shen.bindv V2530 () V2733) (let Result (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2530 V2733) Result))) false))) (if (shen.pvar? V2529) (do (shen.bindv V2529 () V2733) (let Result (let V2531 (shen.lazyderef (tl V2525) V2733) (if (= () V2531) (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2531) (do (shen.bindv V2531 () V2733) (let Result (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2531 V2733) Result))) false))) (do (shen.unbindv V2529 V2733) Result))) false)))) (if (shen.pvar? V2528) (let A (shen.newpv V2733) (do (shen.bindv V2528 (cons A ()) V2733) (let Result (let V2532 (shen.lazyderef (tl V2525) V2733) (if (= () V2532) (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2532) (do (shen.bindv V2532 () V2733) (let Result (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2532 V2733) Result))) false))) (do (shen.unbindv V2528 V2733) Result)))) false))) (if (shen.pvar? V2527) (do (shen.bindv V2527 vector V2733) (let Result (let V2533 (shen.lazyderef (tl V2526) V2733) (if (cons? V2533) (let A (hd V2533) (let V2534 (shen.lazyderef (tl V2533) V2733) (if (= () V2534) (let V2535 (shen.lazyderef (tl V2525) V2733) (if (= () V2535) (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2535) (do (shen.bindv V2535 () V2733) (let Result (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2535 V2733) Result))) false))) (if (shen.pvar? V2534) (do (shen.bindv V2534 () V2733) (let Result (let V2536 (shen.lazyderef (tl V2525) V2733) (if (= () V2536) (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2536) (do (shen.bindv V2536 () V2733) (let Result (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2536 V2733) Result))) false))) (do (shen.unbindv V2534 V2733) Result))) false)))) (if (shen.pvar? V2533) (let A (shen.newpv V2733) (do (shen.bindv V2533 (cons A ()) V2733) (let Result (let V2537 (shen.lazyderef (tl V2525) V2733) (if (= () V2537) (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2537) (do (shen.bindv V2537 () V2733) (let Result (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2537 V2733) Result))) false))) (do (shen.unbindv V2533 V2733) Result)))) false))) (do (shen.unbindv V2527 V2733) Result))) false))) (if (shen.pvar? V2526) (let A (shen.newpv V2733) (do (shen.bindv V2526 (cons vector (cons A ())) V2733) (let Result (let V2538 (shen.lazyderef (tl V2525) V2733) (if (= () V2538) (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2538) (do (shen.bindv V2538 () V2733) (let Result (let Hyp (tl V2516) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons (shen.lazyderef A V2733) ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons (cons vector (cons (shen.lazyderef A V2733) ())) ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2538 V2733) Result))) false))) (do (shen.unbindv V2526 V2733) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2539 (shen.lazyderef V2731 V2733) (if (cons? V2539) (let V2540 (shen.lazyderef (hd V2539) V2733) (if (cons? V2540) (let V2541 (shen.lazyderef (hd V2540) V2733) (if (cons? V2541) (let V2542 (shen.lazyderef (hd V2541) V2733) (if (= @s V2542) (let V2543 (shen.lazyderef (tl V2541) V2733) (if (cons? V2543) (let X (hd V2543) (let V2544 (shen.lazyderef (tl V2543) V2733) (if (cons? V2544) (let Y (hd V2544) (let V2545 (shen.lazyderef (tl V2544) V2733) (if (= () V2545) (let V2546 (shen.lazyderef (tl V2540) V2733) (if (cons? V2546) (let V2547 (shen.lazyderef (hd V2546) V2733) (if (= : V2547) (let V2548 (shen.lazyderef (tl V2546) V2733) (if (cons? V2548) (let V2549 (shen.lazyderef (hd V2548) V2733) (if (= string V2549) (let V2550 (shen.lazyderef (tl V2548) V2733) (if (= () V2550) (let Hyp (tl V2539) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons string ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2550) (do (shen.bindv V2550 () V2733) (let Result (let Hyp (tl V2539) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons string ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2550 V2733) Result))) false))) (if (shen.pvar? V2549) (do (shen.bindv V2549 string V2733) (let Result (let V2551 (shen.lazyderef (tl V2548) V2733) (if (= () V2551) (let Hyp (tl V2539) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons string ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (if (shen.pvar? V2551) (do (shen.bindv V2551 () V2733) (let Result (let Hyp (tl V2539) (do (shen.incinfs) (bind V2732 (cons (cons (shen.lazyderef X V2733) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2733) (cons : (cons string ()))) (shen.lazyderef Hyp V2733))) V2733 V2734))) (do (shen.unbindv V2551 V2733) Result))) false))) (do (shen.unbindv V2549 V2733) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2552 (shen.lazyderef V2731 V2733) (if (cons? V2552) (let X (hd V2552) (let Hyp (tl V2552) (let NewHyps (shen.newpv V2733) (do (shen.incinfs) (bind V2732 (cons (shen.lazyderef X V2733) (shen.lazyderef NewHyps V2733)) V2733 (freeze (shen.t*-hyps Hyp NewHyps V2733 V2734))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2751 V2752 V2753 V2754) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2751 V2753)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2752 V2753) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2754))))))))) (true (thaw V2754))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2756) (cond ((and (cons? V2756) (and (cons? (tl V2756)) (and (= : (hd (tl V2756))) (and (cons? (tl (tl V2756))) (= () (tl (tl (tl V2756)))))))) (shen.prhush (shen.app (hd V2756) (cn " : " (shen.app (hd (tl (tl V2756))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2756 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2761 V2762) (cond ((= () V2761) shen.skip) ((cons? V2761) (do (shen.prhush (shen.app V2762 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2761)) (do (nl 1) (shen.show-assumptions (tl V2761) (+ V2762 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2764) (cons? (assoc V2764 (value shen.*signedfuncs*))))

(defun shen.sigf (V2766) (concat shen.type-signature-of- V2766))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2771 V2772 V2773 V2774) (let Case (let V2455 (shen.lazyderef V2772 V2773) (if (= number V2455) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2771 V2773)) V2773 V2774)) (if (shen.pvar? V2455) (do (shen.bindv V2455 number V2773) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2771 V2773)) V2773 V2774)) (do (shen.unbindv V2455 V2773) Result))) false))) (if (= Case false) (let Case (let V2456 (shen.lazyderef V2772 V2773) (if (= boolean V2456) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2771 V2773)) V2773 V2774)) (if (shen.pvar? V2456) (do (shen.bindv V2456 boolean V2773) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2771 V2773)) V2773 V2774)) (do (shen.unbindv V2456 V2773) Result))) false))) (if (= Case false) (let Case (let V2457 (shen.lazyderef V2772 V2773) (if (= string V2457) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2771 V2773)) V2773 V2774)) (if (shen.pvar? V2457) (do (shen.bindv V2457 string V2773) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2771 V2773)) V2773 V2774)) (do (shen.unbindv V2457 V2773) Result))) false))) (if (= Case false) (let Case (let V2458 (shen.lazyderef V2772 V2773) (if (= symbol V2458) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2771 V2773)) V2773 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2771 V2773))) V2773 V2774)))) (if (shen.pvar? V2458) (do (shen.bindv V2458 symbol V2773) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2771 V2773)) V2773 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2771 V2773))) V2773 V2774)))) (do (shen.unbindv V2458 V2773) Result))) false))) (if (= Case false) (let V2459 (shen.lazyderef V2771 V2773) (if (= () V2459) (let V2460 (shen.lazyderef V2772 V2773) (if (cons? V2460) (let V2461 (shen.lazyderef (hd V2460) V2773) (if (= list V2461) (let V2462 (shen.lazyderef (tl V2460) V2773) (if (cons? V2462) (let A (hd V2462) (let V2463 (shen.lazyderef (tl V2462) V2773) (if (= () V2463) (do (shen.incinfs) (thaw V2774)) (if (shen.pvar? V2463) (do (shen.bindv V2463 () V2773) (let Result (do (shen.incinfs) (thaw V2774)) (do (shen.unbindv V2463 V2773) Result))) false)))) (if (shen.pvar? V2462) (let A (shen.newpv V2773) (do (shen.bindv V2462 (cons A ()) V2773) (let Result (do (shen.incinfs) (thaw V2774)) (do (shen.unbindv V2462 V2773) Result)))) false))) (if (shen.pvar? V2461) (do (shen.bindv V2461 list V2773) (let Result (let V2464 (shen.lazyderef (tl V2460) V2773) (if (cons? V2464) (let A (hd V2464) (let V2465 (shen.lazyderef (tl V2464) V2773) (if (= () V2465) (do (shen.incinfs) (thaw V2774)) (if (shen.pvar? V2465) (do (shen.bindv V2465 () V2773) (let Result (do (shen.incinfs) (thaw V2774)) (do (shen.unbindv V2465 V2773) Result))) false)))) (if (shen.pvar? V2464) (let A (shen.newpv V2773) (do (shen.bindv V2464 (cons A ()) V2773) (let Result (do (shen.incinfs) (thaw V2774)) (do (shen.unbindv V2464 V2773) Result)))) false))) (do (shen.unbindv V2461 V2773) Result))) false))) (if (shen.pvar? V2460) (let A (shen.newpv V2773) (do (shen.bindv V2460 (cons list (cons A ())) V2773) (let Result (do (shen.incinfs) (thaw V2774)) (do (shen.unbindv V2460 V2773) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2780 V2781 V2782 V2783 V2784) (let Case (let V2446 (shen.lazyderef V2782 V2783) (if (cons? V2446) (let V2447 (shen.lazyderef (hd V2446) V2783) (if (cons? V2447) (let Y (hd V2447) (let V2448 (shen.lazyderef (tl V2447) V2783) (if (cons? V2448) (let V2449 (shen.lazyderef (hd V2448) V2783) (if (= : V2449) (let V2450 (shen.lazyderef (tl V2448) V2783) (if (cons? V2450) (let B (hd V2450) (let V2451 (shen.lazyderef (tl V2450) V2783) (if (= () V2451) (do (shen.incinfs) (identical V2780 Y V2783 (freeze (unify! V2781 B V2783 V2784)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2452 (shen.lazyderef V2782 V2783) (if (cons? V2452) (let Hyp (tl V2452) (do (shen.incinfs) (shen.by_hypothesis V2780 V2781 Hyp V2783 V2784))) false)) Case)))

(defun shen.t*-def (V2790 V2791 V2792 V2793 V2794) (let V2440 (shen.lazyderef V2790 V2793) (if (cons? V2440) (let V2441 (shen.lazyderef (hd V2440) V2793) (if (= define V2441) (let V2442 (shen.lazyderef (tl V2440) V2793) (if (cons? V2442) (let F (hd V2442) (let X (tl V2442) (let Y (shen.newpv V2793) (let E (shen.newpv V2793) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2791 V2792 V2793 V2794)))))) false)) false)) false)))

(defun shen.t*-defh (V2801 V2802 V2803 V2804 V2805 V2806) (let V2436 (shen.lazyderef V2801 V2805) (if (cons? V2436) (let Sig (hd V2436) (let Rules (tl V2436) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2802 V2803 V2804 Rules V2805 V2806)))) false)))

(defun shen.t*-defhh (V2815 V2816 V2817 V2818 V2819 V2820 V2821 V2822) (do (shen.incinfs) (shen.t*-rules V2820 V2816 1 V2817 (cons (cons V2817 (cons : (cons V2816 ()))) V2819) V2821 (freeze (shen.memo V2817 V2815 V2818 V2821 V2822)))))

(defun shen.memo (V2828 V2829 V2830 V2831 V2832) (let Jnk (shen.newpv V2831) (do (shen.incinfs) (unify! V2830 V2829 V2831 (freeze (bind Jnk (declare (shen.lazyderef V2828 V2831) (shen.lazyderef V2830 V2831)) V2831 V2832))))))

(defun shen.<sig+rules> (V2834) (let Parse_shen.<signature> (shen.<signature> V2834) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V2836) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V2836) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V2836) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V2838) (cond ((and (cons? V2838) (and (cons? (tl V2838)) (and (= () (tl (tl V2838))) (= (hd V2838) protect)))) V2838) ((cons? V2838) (map (lambda Z (shen.ue Z)) V2838)) ((variable? V2838) (concat && V2838)) (true V2838)))

(defun shen.ue-sig (V2840) (cond ((cons? V2840) (map (lambda Z (shen.ue-sig Z)) V2840)) ((variable? V2840) (concat &&& V2840)) (true V2840)))

(defun shen.ues (V2846) (cond ((shen.ue? V2846) (cons V2846 ())) ((cons? V2846) (union (shen.ues (hd V2846)) (shen.ues (tl V2846)))) (true ())))

(defun shen.ue? (V2848) (and (symbol? V2848) (shen.ue-h? (str V2848))))

(defun shen.ue-h? (V2856) (cond ((and (shen.+string? V2856) (and (= "&" (pos V2856 0)) (and (shen.+string? (tlstr V2856)) (= "&" (pos (tlstr V2856) 0))))) true) (true false)))

(defun shen.t*-rules (V2864 V2865 V2866 V2867 V2868 V2869 V2870) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2420 (shen.lazyderef V2864 V2869) (if (= () V2420) (do (shen.incinfs) (thaw V2870)) false)) (if (= Case false) (let Case (let V2421 (shen.lazyderef V2864 V2869) (if (cons? V2421) (let Rule (hd V2421) (let Rules (tl V2421) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2865 V2868 V2869 (freeze (cut Throwcontrol V2869 (freeze (shen.t*-rules Rules V2865 (+ V2866 1) V2867 V2868 V2869 V2870)))))))) false)) (if (= Case false) (let Err (shen.newpv V2869) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2866 V2869) (cn " of " (shen.app (shen.lazyderef V2867 V2869) "" shen.a)) shen.a))) V2869 V2870))) Case)) Case)))))

(defun shen.t*-rule (V2876 V2877 V2878 V2879 V2880) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2412 (shen.lazyderef V2876 V2879) (if (cons? V2412) (let Patterns (hd V2412) (let V2413 (shen.lazyderef (tl V2412) V2879) (if (cons? V2413) (let Action (hd V2413) (let V2414 (shen.lazyderef (tl V2413) V2879) (if (= () V2414) (let NewHyps (shen.newpv V2879) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V2878 NewHyps V2879 (freeze (shen.t*-patterns Patterns V2877 NewHyps V2879 (freeze (cut Throwcontrol V2879 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V2877) (shen.patthyps Patterns V2877 V2878) V2879 V2880))))))))) false))) false))) false)))))

(defun shen.placeholders (V2886) (cond ((shen.ue? V2886) (cons V2886 ())) ((cons? V2886) (union (shen.placeholders (hd V2886)) (shen.placeholders (tl V2886)))) (true ())))

(defun shen.newhyps (V2892 V2893 V2894 V2895 V2896) (let Case (let V2399 (shen.lazyderef V2892 V2895) (if (= () V2399) (do (shen.incinfs) (unify! V2894 V2893 V2895 V2896)) false)) (if (= Case false) (let V2400 (shen.lazyderef V2892 V2895) (if (cons? V2400) (let V2395 (hd V2400) (let Vs (tl V2400) (let V2401 (shen.lazyderef V2894 V2895) (if (cons? V2401) (let V2402 (shen.lazyderef (hd V2401) V2895) (if (cons? V2402) (let V (hd V2402) (let V2403 (shen.lazyderef (tl V2402) V2895) (if (cons? V2403) (let V2404 (shen.lazyderef (hd V2403) V2895) (if (= : V2404) (let V2405 (shen.lazyderef (tl V2403) V2895) (if (cons? V2405) (let A (hd V2405) (let V2406 (shen.lazyderef (tl V2405) V2895) (if (= () V2406) (let NewHyp (tl V2401) (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (if (shen.pvar? V2406) (do (shen.bindv V2406 () V2895) (let Result (let NewHyp (tl V2401) (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (do (shen.unbindv V2406 V2895) Result))) false)))) (if (shen.pvar? V2405) (let A (shen.newpv V2895) (do (shen.bindv V2405 (cons A ()) V2895) (let Result (let NewHyp (tl V2401) (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (do (shen.unbindv V2405 V2895) Result)))) false))) (if (shen.pvar? V2404) (do (shen.bindv V2404 : V2895) (let Result (let V2407 (shen.lazyderef (tl V2403) V2895) (if (cons? V2407) (let A (hd V2407) (let V2408 (shen.lazyderef (tl V2407) V2895) (if (= () V2408) (let NewHyp (tl V2401) (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (if (shen.pvar? V2408) (do (shen.bindv V2408 () V2895) (let Result (let NewHyp (tl V2401) (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (do (shen.unbindv V2408 V2895) Result))) false)))) (if (shen.pvar? V2407) (let A (shen.newpv V2895) (do (shen.bindv V2407 (cons A ()) V2895) (let Result (let NewHyp (tl V2401) (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (do (shen.unbindv V2407 V2895) Result)))) false))) (do (shen.unbindv V2404 V2895) Result))) false))) (if (shen.pvar? V2403) (let A (shen.newpv V2895) (do (shen.bindv V2403 (cons : (cons A ())) V2895) (let Result (let NewHyp (tl V2401) (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (do (shen.unbindv V2403 V2895) Result)))) false)))) (if (shen.pvar? V2402) (let V (shen.newpv V2895) (let A (shen.newpv V2895) (do (shen.bindv V2402 (cons V (cons : (cons A ()))) V2895) (let Result (let NewHyp (tl V2401) (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (do (shen.unbindv V2402 V2895) Result))))) false))) (if (shen.pvar? V2401) (let V (shen.newpv V2895) (let A (shen.newpv V2895) (let NewHyp (shen.newpv V2895) (do (shen.bindv V2401 (cons (cons V (cons : (cons A ()))) NewHyp) V2895) (let Result (do (shen.incinfs) (unify! V V2395 V2895 (freeze (shen.newhyps Vs V2893 NewHyp V2895 V2896)))) (do (shen.unbindv V2401 V2895) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V2902 V2903 V2904) (cond ((= () V2902) V2904) ((and (cons? V2902) (and (cons? V2903) (and (cons? (tl V2903)) (and (= --> (hd (tl V2903))) (and (cons? (tl (tl V2903))) (= () (tl (tl (tl V2903))))))))) (adjoin (cons (shen.curry (hd V2902)) (cons : (cons (hd V2903) ()))) (shen.patthyps (tl V2902) (hd (tl (tl V2903))) V2904))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V2911 V2912) (cond ((and (= () V2911) (and (cons? V2912) (and (= --> (hd V2912)) (and (cons? (tl V2912)) (= () (tl (tl V2912))))))) (hd (tl V2912))) ((= () V2911) V2912) ((and (cons? V2911) (and (cons? V2912) (and (cons? (tl V2912)) (and (= --> (hd (tl V2912))) (and (cons? (tl (tl V2912))) (= () (tl (tl (tl V2912))))))))) (shen.result-type (tl V2911) (hd (tl (tl V2912))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V2918 V2919 V2920 V2921 V2922) (let Case (let V2387 (shen.lazyderef V2918 V2921) (if (= () V2387) (do (shen.incinfs) (thaw V2922)) false)) (if (= Case false) (let V2388 (shen.lazyderef V2918 V2921) (if (cons? V2388) (let Pattern (hd V2388) (let Patterns (tl V2388) (let V2389 (shen.lazyderef V2919 V2921) (if (cons? V2389) (let A (hd V2389) (let V2390 (shen.lazyderef (tl V2389) V2921) (if (cons? V2390) (let V2391 (shen.lazyderef (hd V2390) V2921) (if (= --> V2391) (let V2392 (shen.lazyderef (tl V2390) V2921) (if (cons? V2392) (let B (hd V2392) (let V2393 (shen.lazyderef (tl V2392) V2921) (if (= () V2393) (do (shen.incinfs) (shen.t* (cons (shen.curry Pattern) (cons : (cons A ()))) V2920 V2921 (freeze (shen.t*-patterns Patterns B V2920 V2921 V2922)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V2928 V2929 V2930 V2931 V2932) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2364 (shen.lazyderef V2928 V2931) (if (cons? V2364) (let V2365 (shen.lazyderef (hd V2364) V2931) (if (= where V2365) (let V2366 (shen.lazyderef (tl V2364) V2931) (if (cons? V2366) (let P (hd V2366) (let V2367 (shen.lazyderef (tl V2366) V2931) (if (cons? V2367) (let Action (hd V2367) (let V2368 (shen.lazyderef (tl V2367) V2931) (if (= () V2368) (do (shen.incinfs) (cut Throwcontrol V2931 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2930 V2931 (freeze (cut Throwcontrol V2931 (freeze (shen.t*-action Action V2929 (cons (cons P (cons : (cons verified ()))) V2930) V2931 V2932)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2369 (shen.lazyderef V2928 V2931) (if (cons? V2369) (let V2370 (shen.lazyderef (hd V2369) V2931) (if (= shen.choicepoint! V2370) (let V2371 (shen.lazyderef (tl V2369) V2931) (if (cons? V2371) (let V2372 (shen.lazyderef (hd V2371) V2931) (if (cons? V2372) (let V2373 (shen.lazyderef (hd V2372) V2931) (if (cons? V2373) (let V2374 (shen.lazyderef (hd V2373) V2931) (if (= fail-if V2374) (let V2375 (shen.lazyderef (tl V2373) V2931) (if (cons? V2375) (let F (hd V2375) (let V2376 (shen.lazyderef (tl V2375) V2931) (if (= () V2376) (let V2377 (shen.lazyderef (tl V2372) V2931) (if (cons? V2377) (let Action (hd V2377) (let V2378 (shen.lazyderef (tl V2377) V2931) (if (= () V2378) (let V2379 (shen.lazyderef (tl V2371) V2931) (if (= () V2379) (do (shen.incinfs) (cut Throwcontrol V2931 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2929 V2930 V2931 V2932)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2380 (shen.lazyderef V2928 V2931) (if (cons? V2380) (let V2381 (shen.lazyderef (hd V2380) V2931) (if (= shen.choicepoint! V2381) (let V2382 (shen.lazyderef (tl V2380) V2931) (if (cons? V2382) (let Action (hd V2382) (let V2383 (shen.lazyderef (tl V2382) V2931) (if (= () V2383) (do (shen.incinfs) (cut Throwcontrol V2931 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2929 V2930 V2931 V2932)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2928 (cons : (cons V2929 ()))) V2930 V2931 V2932)) Case)) Case)) Case)))))

(defun findall (V2938 V2939 V2940 V2941 V2942) (let B (shen.newpv V2941) (let A (shen.newpv V2941) (do (shen.incinfs) (bind A (gensym shen.a) V2941 (freeze (bind B (set (shen.lazyderef A V2941) ()) V2941 (freeze (shen.findallhelp V2938 V2939 V2940 A V2941 V2942)))))))))

(defun shen.findallhelp (V2949 V2950 V2951 V2952 V2953 V2954) (let Case (do (shen.incinfs) (call V2950 V2953 (freeze (shen.remember V2952 V2949 V2953 (freeze (fwhen false V2953 V2954)))))) (if (= Case false) (do (shen.incinfs) (bind V2951 (value (shen.lazyderef V2952 V2953)) V2953 V2954)) Case)))

(defun shen.remember (V2959 V2960 V2961 V2962) (let B (shen.newpv V2961) (do (shen.incinfs) (bind B (set (shen.deref V2959 V2961) (cons (shen.deref V2960 V2961) (value (shen.deref V2959 V2961)))) V2961 V2962))))




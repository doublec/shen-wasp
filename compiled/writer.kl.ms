(module "compiled/writer.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote pr) 2) (define (kl:pr V4536 V4537) (guard (lambda (E) V4536) (kl:shen.prh V4536 V4537 0))) (export pr) (quote pr))
(begin (register-function-arity (quote shen.prh) 3) (define (kl:shen.prh V4541 V4542 V4543) (kl:shen.prh V4541 V4542 (kl:shen.write-char-and-inc V4541 V4542 V4543))) (export shen.prh) (quote shen.prh))
(begin (register-function-arity (quote shen.write-char-and-inc) 3) (define (kl:shen.write-char-and-inc V4547 V4548 V4549) (begin (write-u8 (string-ref (make-string 1 (string-ref V4547 V4549)) 0) V4548) (+ V4549 1))) (export shen.write-char-and-inc) (quote shen.write-char-and-inc))
(begin (register-function-arity (quote print) 1) (define (kl:print V4551) (let ((String (kl:shen.insert V4551 "~S"))) (let ((Print (kl:shen.prhush String (kl:stoutput)))) V4551))) (export print) (quote print))
(begin (register-function-arity (quote shen.prhush) 2) (define (kl:shen.prhush V4554 V4555) (if (assert-boolean (kl:value (quote *hush*))) V4554 (kl:pr V4554 V4555))) (export shen.prhush) (quote shen.prhush))
(begin (register-function-arity (quote shen.mkstr) 2) (define (kl:shen.mkstr V4558 V4559) (cond ((string? V4558) (kl:shen.mkstr-l (kl:shen.proc-nl V4558) V4559)) (#t (kl:shen.mkstr-r (cons (quote shen.proc-nl) (cons V4558 (quote ()))) V4559)))) (export shen.mkstr) (quote shen.mkstr))
(begin (register-function-arity (quote shen.mkstr-l) 2) (define (kl:shen.mkstr-l V4562 V4563) (cond ((null? V4563) V4562) ((pair? V4563) (kl:shen.mkstr-l (kl:shen.insert-l (car V4563) V4562) (cdr V4563))) (#t (kl:shen.f_error (quote shen.mkstr-l))))) (export shen.mkstr-l) (quote shen.mkstr-l))
(begin (register-function-arity (quote shen.insert-l) 2) (define (kl:shen.insert-l V4568 V4569) (cond ((equal? "" V4569) "") ((and (assert-boolean (kl:shen.+string? V4569)) (and (equal? "~" (make-string 1 (string-ref V4569 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4569 1))) (equal? "A" (make-string 1 (string-ref (string-tail V4569 1) 0)))))) (cons (quote shen.app) (cons V4568 (cons (string-tail (string-tail V4569 1) 1) (cons (quote shen.a) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V4569)) (and (equal? "~" (make-string 1 (string-ref V4569 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4569 1))) (equal? "R" (make-string 1 (string-ref (string-tail V4569 1) 0)))))) (cons (quote shen.app) (cons V4568 (cons (string-tail (string-tail V4569 1) 1) (cons (quote shen.r) (quote ())))))) ((and (assert-boolean (kl:shen.+string? V4569)) (and (equal? "~" (make-string 1 (string-ref V4569 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4569 1))) (equal? "S" (make-string 1 (string-ref (string-tail V4569 1) 0)))))) (cons (quote shen.app) (cons V4568 (cons (string-tail (string-tail V4569 1) 1) (cons (quote shen.s) (quote ())))))) ((assert-boolean (kl:shen.+string? V4569)) (kl:shen.factor-cn (cons (quote cn) (cons (make-string 1 (string-ref V4569 0)) (cons (kl:shen.insert-l V4568 (string-tail V4569 1)) (quote ())))))) ((and (pair? V4569) (and (eq? (quote cn) (car V4569)) (and (pair? (cdr V4569)) (and (pair? (cdr (cdr V4569))) (null? (cdr (cdr (cdr V4569)))))))) (cons (quote cn) (cons (car (cdr V4569)) (cons (kl:shen.insert-l V4568 (car (cdr (cdr V4569)))) (quote ()))))) ((and (pair? V4569) (and (eq? (quote shen.app) (car V4569)) (and (pair? (cdr V4569)) (and (pair? (cdr (cdr V4569))) (and (pair? (cdr (cdr (cdr V4569)))) (null? (cdr (cdr (cdr (cdr V4569)))))))))) (cons (quote shen.app) (cons (car (cdr V4569)) (cons (kl:shen.insert-l V4568 (car (cdr (cdr V4569)))) (cdr (cdr (cdr V4569))))))) (#t (kl:shen.f_error (quote shen.insert-l))))) (export shen.insert-l) (quote shen.insert-l))
(begin (register-function-arity (quote shen.factor-cn) 1) (define (kl:shen.factor-cn V4571) (cond ((and (pair? V4571) (and (eq? (quote cn) (car V4571)) (and (pair? (cdr V4571)) (and (pair? (cdr (cdr V4571))) (and (pair? (car (cdr (cdr V4571)))) (and (eq? (quote cn) (car (car (cdr (cdr V4571))))) (and (pair? (cdr (car (cdr (cdr V4571))))) (and (pair? (cdr (cdr (car (cdr (cdr V4571)))))) (and (null? (cdr (cdr (cdr (car (cdr (cdr V4571))))))) (and (null? (cdr (cdr (cdr V4571)))) (and (string? (car (cdr V4571))) (string? (car (cdr (car (cdr (cdr V4571))))))))))))))))) (cons (quote cn) (cons (string-append (car (cdr V4571)) (car (cdr (car (cdr (cdr V4571)))))) (cdr (cdr (car (cdr (cdr V4571)))))))) (#t V4571))) (export shen.factor-cn) (quote shen.factor-cn))
(begin (register-function-arity (quote shen.proc-nl) 1) (define (kl:shen.proc-nl V4573) (cond ((equal? "" V4573) "") ((and (assert-boolean (kl:shen.+string? V4573)) (and (equal? "~" (make-string 1 (string-ref V4573 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4573 1))) (equal? "%" (make-string 1 (string-ref (string-tail V4573 1) 0)))))) (string-append (make-string 1 10) (kl:shen.proc-nl (string-tail (string-tail V4573 1) 1)))) ((assert-boolean (kl:shen.+string? V4573)) (string-append (make-string 1 (string-ref V4573 0)) (kl:shen.proc-nl (string-tail V4573 1)))) (#t (kl:shen.f_error (quote shen.proc-nl))))) (export shen.proc-nl) (quote shen.proc-nl))
(begin (register-function-arity (quote shen.mkstr-r) 2) (define (kl:shen.mkstr-r V4576 V4577) (cond ((null? V4577) V4576) ((pair? V4577) (kl:shen.mkstr-r (cons (quote shen.insert) (cons (car V4577) (cons V4576 (quote ())))) (cdr V4577))) (#t (kl:shen.f_error (quote shen.mkstr-r))))) (export shen.mkstr-r) (quote shen.mkstr-r))
(begin (register-function-arity (quote shen.insert) 2) (define (kl:shen.insert V4580 V4581) (kl:shen.insert-h V4580 V4581 "")) (export shen.insert) (quote shen.insert))
(begin (register-function-arity (quote shen.insert-h) 3) (define (kl:shen.insert-h V4587 V4588 V4589) (cond ((equal? "" V4588) V4589) ((and (assert-boolean (kl:shen.+string? V4588)) (and (equal? "~" (make-string 1 (string-ref V4588 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4588 1))) (equal? "A" (make-string 1 (string-ref (string-tail V4588 1) 0)))))) (string-append V4589 (kl:shen.app V4587 (string-tail (string-tail V4588 1) 1) (quote shen.a)))) ((and (assert-boolean (kl:shen.+string? V4588)) (and (equal? "~" (make-string 1 (string-ref V4588 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4588 1))) (equal? "R" (make-string 1 (string-ref (string-tail V4588 1) 0)))))) (string-append V4589 (kl:shen.app V4587 (string-tail (string-tail V4588 1) 1) (quote shen.r)))) ((and (assert-boolean (kl:shen.+string? V4588)) (and (equal? "~" (make-string 1 (string-ref V4588 0))) (and (assert-boolean (kl:shen.+string? (string-tail V4588 1))) (equal? "S" (make-string 1 (string-ref (string-tail V4588 1) 0)))))) (string-append V4589 (kl:shen.app V4587 (string-tail (string-tail V4588 1) 1) (quote shen.s)))) ((assert-boolean (kl:shen.+string? V4588)) (kl:shen.insert-h V4587 (string-tail V4588 1) (string-append V4589 (make-string 1 (string-ref V4588 0))))) (#t (kl:shen.f_error (quote shen.insert-h))))) (export shen.insert-h) (quote shen.insert-h))
(begin (register-function-arity (quote shen.app) 3) (define (kl:shen.app V4593 V4594 V4595) (string-append (kl:shen.arg->str V4593 V4595) V4594)) (export shen.app) (quote shen.app))
(begin (register-function-arity (quote shen.arg->str) 2) (define (kl:shen.arg->str V4603 V4604) (cond ((kl:= V4603 (kl:fail)) "...") ((assert-boolean (kl:shen.list? V4603)) (kl:shen.list->str V4603 V4604)) ((string? V4603) (kl:shen.str->str V4603 V4604)) ((vector? V4603) (kl:shen.vector->str V4603 V4604)) (#t (kl:shen.atom->str V4603)))) (export shen.arg->str) (quote shen.arg->str))
(begin (register-function-arity (quote shen.list->str) 2) (define (kl:shen.list->str V4607 V4608) (cond ((eq? (quote shen.r) V4608) (kl:_waspvm_at_s "(" (kl:_waspvm_at_s (kl:shen.iter-list V4607 (quote shen.r) (kl:shen.maxseq)) ")"))) (#t (kl:_waspvm_at_s "[" (kl:_waspvm_at_s (kl:shen.iter-list V4607 V4608 (kl:shen.maxseq)) "]"))))) (export shen.list->str) (quote shen.list->str))
(begin (register-function-arity (quote shen.maxseq) 0) (define (kl:shen.maxseq) (kl:value (quote *maximum-print-sequence-size*))) (export shen.maxseq) (quote shen.maxseq))
(begin (register-function-arity (quote shen.iter-list) 3) (define (kl:shen.iter-list V4622 V4623 V4624) (cond ((null? V4622) "") ((kl:= 0 V4624) "... etc") ((and (pair? V4622) (null? (cdr V4622))) (kl:shen.arg->str (car V4622) V4623)) ((pair? V4622) (kl:_waspvm_at_s (kl:shen.arg->str (car V4622) V4623) (kl:_waspvm_at_s " " (kl:shen.iter-list (cdr V4622) V4623 (- V4624 1))))) (#t (kl:_waspvm_at_s "|" (kl:_waspvm_at_s " " (kl:shen.arg->str V4622 V4623)))))) (export shen.iter-list) (quote shen.iter-list))
(begin (register-function-arity (quote shen.str->str) 2) (define (kl:shen.str->str V4631 V4632) (cond ((eq? (quote shen.a) V4632) V4631) (#t (kl:_waspvm_at_s (make-string 1 34) (kl:_waspvm_at_s V4631 (make-string 1 34)))))) (export shen.str->str) (quote shen.str->str))
(begin (register-function-arity (quote shen.vector->str) 2) (define (kl:shen.vector->str V4635 V4636) (if (assert-boolean (kl:shen.print-vector? V4635)) ((kl:function (vector-ref V4635 0)) V4635) (if (assert-boolean (kl:vector? V4635)) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V4635 1 V4636 (kl:shen.maxseq)) ">")) (kl:_waspvm_at_s "<" (kl:_waspvm_at_s "<" (kl:_waspvm_at_s (kl:shen.iter-vector V4635 0 V4636 (kl:shen.maxseq)) ">>")))))) (export shen.vector->str) (quote shen.vector->str))
(begin (register-function-arity (quote shen.empty-absvector?) 1) (define (kl:shen.empty-absvector? V4638) (kl:= V4638 (kl:value (quote shen.*empty-absvector*)))) (export shen.empty-absvector?) (quote shen.empty-absvector?))
(begin (register-function-arity (quote shen.print-vector?) 1) (define (kl:shen.print-vector? V4640) (and (kl:not (kl:shen.empty-absvector? V4640)) (assert-boolean (let ((First (vector-ref V4640 0))) (or (eq? First (quote shen.tuple)) (or (eq? First (quote shen.pvar)) (or (eq? First (quote shen.dictionary)) (and (kl:not (number? First)) (assert-boolean (kl:shen.fbound? First)))))))))) (export shen.print-vector?) (quote shen.print-vector?))
(begin (register-function-arity (quote shen.fbound?) 1) (define (kl:shen.fbound? V4642) (guard (lambda (E) #f) (begin (kl:shen.lookup-func V4642) #t))) (export shen.fbound?) (quote shen.fbound?))
(begin (register-function-arity (quote shen.tuple) 1) (define (kl:shen.tuple V4644) (string-append "(@p " (kl:shen.app (vector-ref V4644 1) (string-append " " (kl:shen.app (vector-ref V4644 2) ")" (quote shen.s))) (quote shen.s)))) (export shen.tuple) (quote shen.tuple))
(begin (register-function-arity (quote shen.dictionary) 1) (define (kl:shen.dictionary V4646) "(dict ...)") (export shen.dictionary) (quote shen.dictionary))
(begin (register-function-arity (quote shen.iter-vector) 4) (define (kl:shen.iter-vector V4657 V4658 V4659 V4660) (cond ((kl:= 0 V4660) "... etc") (#t (let ((Item (guard (lambda (E) (quote shen.out-of-bounds)) (vector-ref V4657 V4658)))) (let ((Next (guard (lambda (E) (quote shen.out-of-bounds)) (vector-ref V4657 (+ V4658 1))))) (if (eq? Item (quote shen.out-of-bounds)) "" (if (eq? Next (quote shen.out-of-bounds)) (kl:shen.arg->str Item V4659) (kl:_waspvm_at_s (kl:shen.arg->str Item V4659) (kl:_waspvm_at_s " " (kl:shen.iter-vector V4657 (+ V4658 1) V4659 (- V4660 1))))))))))) (export shen.iter-vector) (quote shen.iter-vector))
(begin (register-function-arity (quote shen.atom->str) 1) (define (kl:shen.atom->str V4662) (guard (lambda (E) (kl:shen.funexstring)) (kl:str V4662))) (export shen.atom->str) (quote shen.atom->str))
(begin (register-function-arity (quote shen.funexstring) 0) (define (kl:shen.funexstring) (kl:_waspvm_at_s "\016" (kl:_waspvm_at_s "f" (kl:_waspvm_at_s "u" (kl:_waspvm_at_s "n" (kl:_waspvm_at_s "e" (kl:_waspvm_at_s (kl:shen.arg->str (kl:gensym (kl:intern "x")) (quote shen.a)) "\017"))))))) (export shen.funexstring) (quote shen.funexstring))
(begin (register-function-arity (quote shen.list?) 1) (define (kl:shen.list? V4664) (or (kl:empty? V4664) (pair? V4664))) (export shen.list?) (quote shen.list?))

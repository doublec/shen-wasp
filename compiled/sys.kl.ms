(module "compiled/sys.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote thaw) 1) (define (kl:thaw V1862) (V1862)) (export thaw) (quote thaw))
(begin (register-function-arity (quote eval) 1) (define (kl:eval V1864) (let ((Macroexpand (kl:shen.walk (lambda (Y) (kl:macroexpand Y)) V1864))) (if (assert-boolean (kl:shen.packaged? Macroexpand)) (kl:map (lambda (Z) (kl:shen.eval-without-macros Z)) (kl:shen.package-contents Macroexpand)) (kl:shen.eval-without-macros Macroexpand)))) (export eval) (quote eval))
(begin (register-function-arity (quote shen.eval-without-macros) 1) (define (kl:shen.eval-without-macros V1866) (kl:eval-kl (kl:shen.elim-def (kl:shen.proc-input+ V1866)))) (export shen.eval-without-macros) (quote shen.eval-without-macros))
(begin (register-function-arity (quote shen.proc-input+) 1) (define (kl:shen.proc-input+ V1868) (cond ((and (pair? V1868) (and (eq? (quote input+) (car V1868)) (and (pair? (cdr V1868)) (and (pair? (cdr (cdr V1868))) (null? (cdr (cdr (cdr V1868)))))))) (cons (quote input+) (cons (kl:shen.rcons_form (car (cdr V1868))) (cdr (cdr V1868))))) ((and (pair? V1868) (and (eq? (quote shen.read+) (car V1868)) (and (pair? (cdr V1868)) (and (pair? (cdr (cdr V1868))) (null? (cdr (cdr (cdr V1868)))))))) (cons (quote shen.read+) (cons (kl:shen.rcons_form (car (cdr V1868))) (cdr (cdr V1868))))) ((pair? V1868) (kl:map (lambda (Z) (kl:shen.proc-input+ Z)) V1868)) (#t V1868))) (export shen.proc-input+) (quote shen.proc-input+))
(begin (register-function-arity (quote shen.elim-def) 1) (define (kl:shen.elim-def V1870) (cond ((and (pair? V1870) (and (eq? (quote define) (car V1870)) (pair? (cdr V1870)))) (kl:shen.shen->kl (car (cdr V1870)) (cdr (cdr V1870)))) ((and (pair? V1870) (and (eq? (quote defmacro) (car V1870)) (pair? (cdr V1870)))) (let ((Default (cons (quote X) (cons (quote ->) (cons (quote X) (quote ())))))) (let ((Def (kl:shen.elim-def (cons (quote define) (cons (car (cdr V1870)) (kl:append (cdr (cdr V1870)) Default)))))) (let ((MacroAdd (kl:shen.add-macro (car (cdr V1870))))) Def)))) ((and (pair? V1870) (and (eq? (quote defcc) (car V1870)) (pair? (cdr V1870)))) (kl:shen.elim-def (kl:shen.yacc V1870))) ((pair? V1870) (kl:map (lambda (Z) (kl:shen.elim-def Z)) V1870)) (#t V1870))) (export shen.elim-def) (quote shen.elim-def))
(begin (register-function-arity (quote shen.add-macro) 1) (define (kl:shen.add-macro V1872) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((NewMacroReg (kl:set (quote shen.*macroreg*) (kl:adjoin V1872 (kl:value (quote shen.*macroreg*)))))) (if (kl:= MacroReg NewMacroReg) (quote shen.skip) (kl:set (quote *macros*) (cons (kl:function V1872) (kl:value (quote *macros*)))))))) (export shen.add-macro) (quote shen.add-macro))
(begin (register-function-arity (quote shen.packaged?) 1) (define (kl:shen.packaged? V1880) (cond ((and (pair? V1880) (and (eq? (quote package) (car V1880)) (and (pair? (cdr V1880)) (pair? (cdr (cdr V1880)))))) #t) (#t #f))) (export shen.packaged?) (quote shen.packaged?))
(begin (register-function-arity (quote external) 1) (define (kl:external V1882) (guard (lambda (E) (simple-error (string-append "package " (kl:shen.app V1882 " has not been used.\n" (quote shen.a))))) (kl:get V1882 (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (export external) (quote external))
(begin (register-function-arity (quote internal) 1) (define (kl:internal V1884) (guard (lambda (E) (simple-error (string-append "package " (kl:shen.app V1884 " has not been used.\n" (quote shen.a))))) (kl:get V1884 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (export internal) (quote internal))
(begin (register-function-arity (quote shen.package-contents) 1) (define (kl:shen.package-contents V1888) (cond ((and (pair? V1888) (and (eq? (quote package) (car V1888)) (and (pair? (cdr V1888)) (and (eq? (quote null) (car (cdr V1888))) (pair? (cdr (cdr V1888))))))) (cdr (cdr (cdr V1888)))) ((and (pair? V1888) (and (eq? (quote package) (car V1888)) (and (pair? (cdr V1888)) (pair? (cdr (cdr V1888)))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V1888))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (kl:shen.packageh (car (cdr V1888)) (car (cdr (cdr V1888))) (cdr (cdr (cdr V1888))) ExpPackageNameDot)))) (#t (kl:shen.f_error (quote shen.package-contents))))) (export shen.package-contents) (quote shen.package-contents))
(begin (register-function-arity (quote shen.walk) 2) (define (kl:shen.walk V1891 V1892) (cond ((pair? V1892) (V1891 (kl:map (lambda (Z) (kl:shen.walk V1891 Z)) V1892))) (#t (V1891 V1892)))) (export shen.walk) (quote shen.walk))
(begin (register-function-arity (quote compile) 3) (define (kl:compile V1896 V1897 V1898) (let ((O (V1896 (cons V1897 (cons (quote ()) (quote ())))))) (if (or (kl:= (kl:fail) O) (kl:not (kl:empty? (car O)))) (V1898 O) (kl:shen.hdtl O)))) (export compile) (quote compile))
(begin (register-function-arity (quote fail-if) 2) (define (kl:fail-if V1901 V1902) (if (assert-boolean (V1901 V1902)) (kl:fail) V1902)) (export fail-if) (quote fail-if))
(begin (register-function-arity (quote _waspvm_at_s) 2) (define (kl:_waspvm_at_s V1905 V1906) (string-append V1905 V1906)) (export _waspvm_at_s) (quote _waspvm_at_s))
(begin (register-function-arity (quote tc?) 0) (define (kl:tc?) (kl:value (quote shen.*tc*))) (export tc?) (quote tc?))
(begin (register-function-arity (quote ps) 1) (define (kl:ps V1908) (guard (lambda (E) (simple-error (kl:shen.app V1908 " not found.\n" (quote shen.a)))) (kl:get V1908 (quote shen.source) (kl:value (quote *property-vector*))))) (export ps) (quote ps))
(begin (register-function-arity (quote stinput) 0) (define (kl:stinput) (kl:value (quote *stinput*))) (export stinput) (quote stinput))
(begin (register-function-arity (quote vector) 1) (define (kl:vector V1910) (let ((Vector (make-vector (+ V1910 1) (quote (quote shen.fail!))))) (let ((ZeroStamp (let ((_tmp Vector)) (vector-set! _tmp 0 V1910) _tmp))) (let ((Standard (if (kl:= V1910 0) ZeroStamp (kl:shen.fillvector ZeroStamp 1 V1910 (kl:fail))))) Standard)))) (export vector) (quote vector))
(begin (register-function-arity (quote shen.fillvector) 4) (define (kl:shen.fillvector V1916 V1917 V1918 V1919) (cond ((kl:= V1918 V1917) (let ((_tmp V1916)) (vector-set! _tmp V1918 V1919) _tmp)) (#t (kl:shen.fillvector (let ((_tmp V1916)) (vector-set! _tmp V1917 V1919) _tmp) (+ 1 V1917) V1918 V1919)))) (export shen.fillvector) (quote shen.fillvector))
(begin (register-function-arity (quote vector?) 1) (define (kl:vector? V1921) (and (vector? V1921) (assert-boolean (let ((X (guard (lambda (E) -1) (vector-ref V1921 0)))) (and (number? X) (>= X 0)))))) (export vector?) (quote vector?))
(begin (register-function-arity (quote vector->) 3) (define (kl:vector-> V1925 V1926 V1927) (if (kl:= V1926 0) (simple-error "cannot access 0th element of a vector\n") (let ((_tmp V1925)) (vector-set! _tmp V1926 V1927) _tmp))) (export vector->) (quote vector->))
(begin (register-function-arity (quote <-vector) 2) (define (kl:<-vector V1930 V1931) (if (kl:= V1931 0) (simple-error "cannot access 0th element of a vector\n") (let ((VectorElement (vector-ref V1930 V1931))) (if (kl:= VectorElement (kl:fail)) (simple-error "vector element not found\n") VectorElement)))) (export <-vector) (quote <-vector))
(begin (register-function-arity (quote shen.posint?) 1) (define (kl:shen.posint? V1933) (and (assert-boolean (kl:integer? V1933)) (>= V1933 0))) (export shen.posint?) (quote shen.posint?))
(begin (register-function-arity (quote limit) 1) (define (kl:limit V1935) (vector-ref V1935 0)) (export limit) (quote limit))
(begin (register-function-arity (quote symbol?) 1) (define (kl:symbol? V1937) (cond ((or (kl:boolean? V1937) (or (number? V1937) (string? V1937))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V1937))) (kl:shen.analyse-symbol? String)))))) (export symbol?) (quote symbol?))
(begin (register-function-arity (quote shen.analyse-symbol?) 1) (define (kl:shen.analyse-symbol? V1939) (cond ((equal? "" V1939) #f) ((assert-boolean (kl:shen.+string? V1939)) (and (assert-boolean (kl:shen.alpha? (make-string 1 (string-ref V1939 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V1939 1))))) (#t (kl:shen.f_error (quote shen.analyse-symbol?))))) (export shen.analyse-symbol?) (quote shen.analyse-symbol?))
(begin (register-function-arity (quote shen.alpha?) 1) (define (kl:shen.alpha? V1941) (kl:element? V1941 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." (quote ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (export shen.alpha?) (quote shen.alpha?))
(begin (register-function-arity (quote shen.alphanums?) 1) (define (kl:shen.alphanums? V1943) (cond ((equal? "" V1943) #t) ((assert-boolean (kl:shen.+string? V1943)) (and (assert-boolean (kl:shen.alphanum? (make-string 1 (string-ref V1943 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V1943 1))))) (#t (kl:shen.f_error (quote shen.alphanums?))))) (export shen.alphanums?) (quote shen.alphanums?))
(begin (register-function-arity (quote shen.alphanum?) 1) (define (kl:shen.alphanum? V1945) (or (assert-boolean (kl:shen.alpha? V1945)) (assert-boolean (kl:shen.digit? V1945)))) (export shen.alphanum?) (quote shen.alphanum?))
(begin (register-function-arity (quote shen.digit?) 1) (define (kl:shen.digit? V1947) (kl:element? V1947 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ()))))))))))))) (export shen.digit?) (quote shen.digit?))
(begin (register-function-arity (quote variable?) 1) (define (kl:variable? V1949) (cond ((or (kl:boolean? V1949) (or (number? V1949) (string? V1949))) #f) (#t (guard (lambda (E) #f) (let ((String (kl:str V1949))) (kl:shen.analyse-variable? String)))))) (export variable?) (quote variable?))
(begin (register-function-arity (quote shen.analyse-variable?) 1) (define (kl:shen.analyse-variable? V1951) (cond ((assert-boolean (kl:shen.+string? V1951)) (and (assert-boolean (kl:shen.uppercase? (make-string 1 (string-ref V1951 0)))) (assert-boolean (kl:shen.alphanums? (string-tail V1951 1))))) (#t (kl:shen.f_error (quote shen.analyse-variable?))))) (export shen.analyse-variable?) (quote shen.analyse-variable?))
(begin (register-function-arity (quote shen.uppercase?) 1) (define (kl:shen.uppercase? V1953) (kl:element? V1953 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (quote ()))))))))))))))))))))))))))))) (export shen.uppercase?) (quote shen.uppercase?))
(begin (register-function-arity (quote gensym) 1) (define (kl:gensym V1955) (kl:concat V1955 (kl:set (quote shen.*gensym*) (+ 1 (kl:value (quote shen.*gensym*)))))) (export gensym) (quote gensym))
(begin (register-function-arity (quote concat) 2) (define (kl:concat V1958 V1959) (kl:intern (string-append (kl:str V1958) (kl:str V1959)))) (export concat) (quote concat))
(begin (register-function-arity (quote _waspvm_at_p) 2) (define (kl:_waspvm_at_p V1962 V1963) (let ((Vector (make-vector 3 (quote (quote shen.fail!))))) (let ((Tag (let ((_tmp Vector)) (vector-set! _tmp 0 (quote shen.tuple)) _tmp))) (let ((Fst (let ((_tmp Vector)) (vector-set! _tmp 1 V1962) _tmp))) (let ((Snd (let ((_tmp Vector)) (vector-set! _tmp 2 V1963) _tmp))) Vector))))) (export _waspvm_at_p) (quote _waspvm_at_p))
(begin (register-function-arity (quote fst) 1) (define (kl:fst V1965) (vector-ref V1965 1)) (export fst) (quote fst))
(begin (register-function-arity (quote snd) 1) (define (kl:snd V1967) (vector-ref V1967 2)) (export snd) (quote snd))
(begin (register-function-arity (quote tuple?) 1) (define (kl:tuple? V1969) (and (vector? V1969) (eq? (quote shen.tuple) (guard (lambda (E) (quote shen.not-tuple)) (vector-ref V1969 0))))) (export tuple?) (quote tuple?))
(begin (register-function-arity (quote append) 2) (define (kl:append V1972 V1973) (cond ((null? V1972) V1973) ((pair? V1972) (cons (car V1972) (kl:append (cdr V1972) V1973))) (#t (kl:shen.f_error (quote append))))) (export append) (quote append))
(begin (register-function-arity (quote _waspvm_at_v) 2) (define (kl:_waspvm_at_v V1976 V1977) (let ((Limit (kl:limit V1977))) (let ((NewVector (kl:vector (+ Limit 1)))) (let ((X+NewVector (kl:vector-> NewVector 1 V1976))) (if (kl:= Limit 0) X+NewVector (kl:shen._waspvm_at_v-help V1977 1 Limit X+NewVector)))))) (export _waspvm_at_v) (quote _waspvm_at_v))
(begin (register-function-arity (quote shen._waspvm_at_v-help) 4) (define (kl:shen._waspvm_at_v-help V1983 V1984 V1985 V1986) (cond ((kl:= V1985 V1984) (kl:shen.copyfromvector V1983 V1986 V1985 (+ V1985 1))) (#t (kl:shen._waspvm_at_v-help V1983 (+ V1984 1) V1985 (kl:shen.copyfromvector V1983 V1986 V1984 (+ V1984 1)))))) (export shen._waspvm_at_v-help) (quote shen._waspvm_at_v-help))
(begin (register-function-arity (quote shen.copyfromvector) 4) (define (kl:shen.copyfromvector V1991 V1992 V1993 V1994) (guard (lambda (E) V1992) (kl:vector-> V1992 V1994 (kl:<-vector V1991 V1993)))) (export shen.copyfromvector) (quote shen.copyfromvector))
(begin (register-function-arity (quote hdv) 1) (define (kl:hdv V1996) (guard (lambda (E) (simple-error (string-append "hdv needs a non-empty vector as an argument; not " (kl:shen.app V1996 "\n" (quote shen.s))))) (kl:<-vector V1996 1))) (export hdv) (quote hdv))
(begin (register-function-arity (quote tlv) 1) (define (kl:tlv V1998) (let ((Limit (kl:limit V1998))) (if (kl:= Limit 0) (simple-error "cannot take the tail of the empty vector\n") (if (kl:= Limit 1) (kl:vector 0) (let ((NewVector (kl:vector (- Limit 1)))) (kl:shen.tlv-help V1998 2 Limit (kl:vector (- Limit 1)))))))) (export tlv) (quote tlv))
(begin (register-function-arity (quote shen.tlv-help) 4) (define (kl:shen.tlv-help V2004 V2005 V2006 V2007) (cond ((kl:= V2006 V2005) (kl:shen.copyfromvector V2004 V2007 V2006 (- V2006 1))) (#t (kl:shen.tlv-help V2004 (+ V2005 1) V2006 (kl:shen.copyfromvector V2004 V2007 V2005 (- V2005 1)))))) (export shen.tlv-help) (quote shen.tlv-help))
(begin (register-function-arity (quote assoc) 2) (define (kl:assoc V2019 V2020) (cond ((null? V2020) (quote ())) ((and (pair? V2020) (and (pair? (car V2020)) (kl:= (car (car V2020)) V2019))) (car V2020)) ((pair? V2020) (kl:assoc V2019 (cdr V2020))) (#t (kl:shen.f_error (quote assoc))))) (export assoc) (quote assoc))
(begin (register-function-arity (quote shen.assoc-set) 3) (define (kl:shen.assoc-set V2027 V2028 V2029) (cond ((null? V2029) (cons (cons V2027 V2028) (quote ()))) ((and (pair? V2029) (and (pair? (car V2029)) (kl:= (car (car V2029)) V2027))) (cons (cons (car (car V2029)) V2028) (cdr V2029))) ((pair? V2029) (cons (car V2029) (kl:shen.assoc-set V2027 V2028 (cdr V2029)))) (#t (kl:shen.f_error (quote shen.assoc-set))))) (export shen.assoc-set) (quote shen.assoc-set))
(begin (register-function-arity (quote shen.assoc-rm) 2) (define (kl:shen.assoc-rm V2035 V2036) (cond ((null? V2036) (quote ())) ((and (pair? V2036) (and (pair? (car V2036)) (kl:= (car (car V2036)) V2035))) (cdr V2036)) ((pair? V2036) (cons (car V2036) (kl:shen.assoc-rm V2035 (cdr V2036)))) (#t (kl:shen.f_error (quote shen.assoc-rm))))) (export shen.assoc-rm) (quote shen.assoc-rm))
(begin (register-function-arity (quote boolean?) 1) (define (kl:boolean? V2042) (cond ((kl:= #t V2042) #t) ((kl:= #f V2042) #t) (#t #f))) (export boolean?) (quote boolean?))
(begin (register-function-arity (quote nl) 1) (define (kl:nl V2044) (cond ((kl:= 0 V2044) 0) (#t (begin (kl:shen.prhush "\n" (kl:stoutput)) (kl:nl (- V2044 1)))))) (export nl) (quote nl))
(begin (register-function-arity (quote difference) 2) (define (kl:difference V2049 V2050) (cond ((null? V2049) (quote ())) ((pair? V2049) (if (kl:element? (car V2049) V2050) (kl:difference (cdr V2049) V2050) (cons (car V2049) (kl:difference (cdr V2049) V2050)))) (#t (kl:shen.f_error (quote difference))))) (export difference) (quote difference))
(begin (register-function-arity (quote do) 2) (define (kl:do V2053 V2054) V2054) (export do) (quote do))
(begin (register-function-arity (quote element?) 2) (define (kl:element? V2066 V2067) (cond ((null? V2067) #f) ((and (pair? V2067) (kl:= (car V2067) V2066)) #t) ((pair? V2067) (kl:element? V2066 (cdr V2067))) (#t (kl:shen.f_error (quote element?))))) (export element?) (quote element?))
(begin (register-function-arity (quote empty?) 1) (define (kl:empty? V2073) (cond ((null? V2073) #t) (#t #f))) (export empty?) (quote empty?))
(begin (register-function-arity (quote fix) 2) (define (kl:fix V2076 V2077) (kl:shen.fix-help V2076 V2077 (V2076 V2077))) (export fix) (quote fix))
(begin (register-function-arity (quote shen.fix-help) 3) (define (kl:shen.fix-help V2088 V2089 V2090) (cond ((kl:= V2090 V2089) V2090) (#t (kl:shen.fix-help V2088 V2090 (V2088 V2090))))) (export shen.fix-help) (quote shen.fix-help))
(begin (register-function-arity (quote put) 4) (define (kl:put V2095 V2096 V2097 V2098) (let ((Curr (guard (lambda (E) (quote ())) (kl:shen.<-dict V2098 V2095)))) (let ((Added (kl:shen.assoc-set V2096 V2097 Curr))) (let ((Update (kl:shen.dict-> V2098 V2095 Added))) V2097)))) (export put) (quote put))
(begin (register-function-arity (quote unput) 3) (define (kl:unput V2102 V2103 V2104) (let ((Curr (guard (lambda (E) (quote ())) (kl:shen.<-dict V2104 V2102)))) (let ((Removed (kl:shen.assoc-rm V2103 Curr))) (let ((Update (kl:shen.dict-> V2104 V2102 Removed))) V2102)))) (export unput) (quote unput))
(begin (register-function-arity (quote get) 3) (define (kl:get V2108 V2109 V2110) (let ((Entry (guard (lambda (E) (quote ())) (kl:shen.<-dict V2110 V2108)))) (let ((Result (kl:assoc V2109 Entry))) (if (kl:empty? Result) (simple-error "value not found\n") (cdr Result))))) (export get) (quote get))
(begin (register-function-arity (quote hash) 2) (define (kl:hash V2113 V2114) (kl:shen.mod (kl:sum (kl:map (lambda (X) (string-ref X 0)) (kl:explode V2113))) V2114)) (export hash) (quote hash))
(begin (register-function-arity (quote shen.mod) 2) (define (kl:shen.mod V2117 V2118) (kl:shen.modh V2117 (kl:shen.multiples V2117 (cons V2118 (quote ()))))) (export shen.mod) (quote shen.mod))
(begin (register-function-arity (quote shen.multiples) 2) (define (kl:shen.multiples V2121 V2122) (cond ((and (pair? V2122) (> (car V2122) V2121)) (cdr V2122)) ((pair? V2122) (kl:shen.multiples V2121 (cons (* 2 (car V2122)) V2122))) (#t (kl:shen.f_error (quote shen.multiples))))) (export shen.multiples) (quote shen.multiples))
(begin (register-function-arity (quote shen.modh) 2) (define (kl:shen.modh V2127 V2128) (cond ((kl:= 0 V2127) 0) ((null? V2128) V2127) ((and (pair? V2128) (> (car V2128) V2127)) (if (kl:empty? (cdr V2128)) V2127 (kl:shen.modh V2127 (cdr V2128)))) ((pair? V2128) (kl:shen.modh (- V2127 (car V2128)) V2128)) (#t (kl:shen.f_error (quote shen.modh))))) (export shen.modh) (quote shen.modh))
(begin (register-function-arity (quote sum) 1) (define (kl:sum V2130) (cond ((null? V2130) 0) ((pair? V2130) (+ (car V2130) (kl:sum (cdr V2130)))) (#t (kl:shen.f_error (quote sum))))) (export sum) (quote sum))
(begin (register-function-arity (quote head) 1) (define (kl:head V2138) (cond ((pair? V2138) (car V2138)) (#t (simple-error "head expects a non-empty list")))) (export head) (quote head))
(begin (register-function-arity (quote tail) 1) (define (kl:tail V2146) (cond ((pair? V2146) (cdr V2146)) (#t (simple-error "tail expects a non-empty list")))) (export tail) (quote tail))
(begin (register-function-arity (quote hdstr) 1) (define (kl:hdstr V2148) (make-string 1 (string-ref V2148 0))) (export hdstr) (quote hdstr))
(begin (register-function-arity (quote intersection) 2) (define (kl:intersection V2153 V2154) (cond ((null? V2153) (quote ())) ((pair? V2153) (if (kl:element? (car V2153) V2154) (cons (car V2153) (kl:intersection (cdr V2153) V2154)) (kl:intersection (cdr V2153) V2154))) (#t (kl:shen.f_error (quote intersection))))) (export intersection) (quote intersection))
(begin (register-function-arity (quote reverse) 1) (define (kl:reverse V2156) (kl:shen.reverse_help V2156 (quote ()))) (export reverse) (quote reverse))
(begin (register-function-arity (quote shen.reverse_help) 2) (define (kl:shen.reverse_help V2159 V2160) (cond ((null? V2159) V2160) ((pair? V2159) (kl:shen.reverse_help (cdr V2159) (cons (car V2159) V2160))) (#t (kl:shen.f_error (quote shen.reverse_help))))) (export shen.reverse_help) (quote shen.reverse_help))
(begin (register-function-arity (quote union) 2) (define (kl:union V2163 V2164) (cond ((null? V2163) V2164) ((pair? V2163) (if (kl:element? (car V2163) V2164) (kl:union (cdr V2163) V2164) (cons (car V2163) (kl:union (cdr V2163) V2164)))) (#t (kl:shen.f_error (quote union))))) (export union) (quote union))
(begin (register-function-arity (quote y-or-n?) 1) (define (kl:y-or-n? V2166) (let ((Message (kl:shen.prhush (kl:shen.proc-nl V2166) (kl:stoutput)))) (let ((Y-or-N (kl:shen.prhush " (y/n) " (kl:stoutput)))) (let ((Input (kl:shen.app (kl:read (kl:stinput)) "" (quote shen.s)))) (if (equal? "y" Input) #t (if (equal? "n" Input) #f (begin (kl:shen.prhush "please answer y or n\n" (kl:stoutput)) (kl:y-or-n? V2166)))))))) (export y-or-n?) (quote y-or-n?))
(begin (register-function-arity (quote not) 1) (define (kl:not V2168) (if (assert-boolean V2168) #f #t)) (export not) (quote not))
(begin (register-function-arity (quote subst) 3) (define (kl:subst V2181 V2182 V2183) (cond ((kl:= V2183 V2182) V2181) ((pair? V2183) (kl:map (lambda (W) (kl:subst V2181 V2182 W)) V2183)) (#t V2183))) (export subst) (quote subst))
(begin (register-function-arity (quote explode) 1) (define (kl:explode V2185) (kl:shen.explode-h (kl:shen.app V2185 "" (quote shen.a)))) (export explode) (quote explode))
(begin (register-function-arity (quote shen.explode-h) 1) (define (kl:shen.explode-h V2187) (cond ((equal? "" V2187) (quote ())) ((assert-boolean (kl:shen.+string? V2187)) (cons (make-string 1 (string-ref V2187 0)) (kl:shen.explode-h (string-tail V2187 1)))) (#t (kl:shen.f_error (quote shen.explode-h))))) (export shen.explode-h) (quote shen.explode-h))
(begin (register-function-arity (quote cd) 1) (define (kl:cd V2189) (kl:set (quote *home-directory*) (if (equal? V2189 "") "" (kl:shen.app V2189 "/" (quote shen.a))))) (export cd) (quote cd))
(begin (register-function-arity (quote shen.for-each) 2) (define (kl:shen.for-each V2192 V2193) (cond ((null? V2193) #t) ((pair? V2193) (let ((_ (V2192 (car V2193)))) (kl:shen.for-each V2192 (cdr V2193)))) (#t (kl:shen.f_error (quote shen.for-each))))) (export shen.for-each) (quote shen.for-each))
(begin (register-function-arity (quote map) 2) (define (kl:map V2198 V2199) (cond ((null? V2199) (quote ())) ((pair? V2199) (cons (V2198 (car V2199)) (kl:map V2198 (cdr V2199)))) (#t (V2198 V2199)))) (export map) (quote map))
(begin (register-function-arity (quote length) 1) (define (kl:length V2201) (kl:shen.length-h V2201 0)) (export length) (quote length))
(begin (register-function-arity (quote shen.length-h) 2) (define (kl:shen.length-h V2204 V2205) (cond ((null? V2204) V2205) (#t (kl:shen.length-h (cdr V2204) (+ V2205 1))))) (export shen.length-h) (quote shen.length-h))
(begin (register-function-arity (quote occurrences) 2) (define (kl:occurrences V2217 V2218) (cond ((kl:= V2218 V2217) 1) ((pair? V2218) (+ (kl:occurrences V2217 (car V2218)) (kl:occurrences V2217 (cdr V2218)))) (#t 0))) (export occurrences) (quote occurrences))
(begin (register-function-arity (quote nth) 2) (define (kl:nth V2225 V2226) (cond ((and (kl:= 1 V2225) (pair? V2226)) (car V2226)) ((pair? V2226) (kl:nth (- V2225 1) (cdr V2226))) (#t (simple-error (string-append "nth applied to " (kl:shen.app V2225 (string-append ", " (kl:shen.app V2226 "\n" (quote shen.a))) (quote shen.a))))))) (export nth) (quote nth))
(begin (register-function-arity (quote integer?) 1) (define (kl:integer? V2228) (and (number? V2228) (assert-boolean (let ((Abs (kl:shen.abs V2228))) (kl:shen.integer-test? Abs (kl:shen.magless Abs 1)))))) (export integer?) (quote integer?))
(begin (register-function-arity (quote shen.abs) 1) (define (kl:shen.abs V2230) (if (> V2230 0) V2230 (- 0 V2230))) (export shen.abs) (quote shen.abs))
(begin (register-function-arity (quote shen.magless) 2) (define (kl:shen.magless V2233 V2234) (let ((Nx2 (* V2234 2))) (if (> Nx2 V2233) V2234 (kl:shen.magless V2233 Nx2)))) (export shen.magless) (quote shen.magless))
(begin (register-function-arity (quote shen.integer-test?) 2) (define (kl:shen.integer-test? V2240 V2241) (cond ((kl:= 0 V2240) #t) ((> 1 V2240) #f) (#t (let ((Abs-N (- V2240 V2241))) (if (> 0 Abs-N) (kl:integer? V2240) (kl:shen.integer-test? Abs-N V2241)))))) (export shen.integer-test?) (quote shen.integer-test?))
(begin (register-function-arity (quote mapcan) 2) (define (kl:mapcan V2246 V2247) (cond ((null? V2247) (quote ())) ((pair? V2247) (kl:append (V2246 (car V2247)) (kl:mapcan V2246 (cdr V2247)))) (#t (kl:shen.f_error (quote mapcan))))) (export mapcan) (quote mapcan))
(begin (register-function-arity (quote ==) 2) (define (kl:== V2259 V2260) (cond ((kl:= V2260 V2259) #t) (#t #f))) (export ==) (quote ==))
(begin (register-function-arity (quote abort) 0) (define (kl:abort) (simple-error "")) (export abort) (quote abort))
(begin (register-function-arity (quote bound?) 1) (define (kl:bound? V2262) (and (kl:symbol? V2262) (assert-boolean (let ((Val (guard (lambda (E) (quote shen.this-symbol-is-unbound)) (kl:value V2262)))) (if (eq? Val (quote shen.this-symbol-is-unbound)) #f #t))))) (export bound?) (quote bound?))
(begin (register-function-arity (quote shen.string->bytes) 1) (define (kl:shen.string->bytes V2264) (cond ((equal? "" V2264) (quote ())) (#t (cons (string-ref (make-string 1 (string-ref V2264 0)) 0) (kl:shen.string->bytes (string-tail V2264 1)))))) (export shen.string->bytes) (quote shen.string->bytes))
(begin (register-function-arity (quote maxinferences) 1) (define (kl:maxinferences V2266) (kl:set (quote shen.*maxinferences*) V2266)) (export maxinferences) (quote maxinferences))
(begin (register-function-arity (quote inferences) 0) (define (kl:inferences) (kl:value (quote shen.*infs*))) (export inferences) (quote inferences))
(begin (register-function-arity (quote protect) 1) (define (kl:protect V2268) V2268) (export protect) (quote protect))
(begin (register-function-arity (quote stoutput) 0) (define (kl:stoutput) (kl:value (quote *stoutput*))) (export stoutput) (quote stoutput))
(begin (register-function-arity (quote sterror) 0) (define (kl:sterror) (kl:value (quote *sterror*))) (export sterror) (quote sterror))
(begin (register-function-arity (quote string->symbol) 1) (define (kl:string->symbol V2270) (let ((Symbol (kl:intern V2270))) (if (kl:symbol? Symbol) Symbol (simple-error (string-append "cannot intern " (kl:shen.app V2270 " to a symbol" (quote shen.s))))))) (export string->symbol) (quote string->symbol))
(begin (register-function-arity (quote optimise) 1) (define (kl:optimise V2276) (cond ((eq? (quote +) V2276) (kl:set (quote shen.*optimise*) #t)) ((eq? (quote -) V2276) (kl:set (quote shen.*optimise*) #f)) (#t (simple-error "optimise expects a + or a -.\n")))) (export optimise) (quote optimise))
(begin (register-function-arity (quote os) 0) (define (kl:os) (kl:value (quote *os*))) (export os) (quote os))
(begin (register-function-arity (quote language) 0) (define (kl:language) (kl:value (quote *language*))) (export language) (quote language))
(begin (register-function-arity (quote version) 0) (define (kl:version) (kl:value (quote *version*))) (export version) (quote version))
(begin (register-function-arity (quote port) 0) (define (kl:port) (kl:value (quote *port*))) (export port) (quote port))
(begin (register-function-arity (quote porters) 0) (define (kl:porters) (kl:value (quote *porters*))) (export porters) (quote porters))
(begin (register-function-arity (quote implementation) 0) (define (kl:implementation) (kl:value (quote *implementation*))) (export implementation) (quote implementation))
(begin (register-function-arity (quote release) 0) (define (kl:release) (kl:value (quote *release*))) (export release) (quote release))
(begin (register-function-arity (quote package?) 1) (define (kl:package? V2278) (guard (lambda (E) #f) (begin (kl:external V2278) #t))) (export package?) (quote package?))
(begin (register-function-arity (quote function) 1) (define (kl:function V2280) (kl:shen.lookup-func V2280)) (export function) (quote function))
(begin (register-function-arity (quote shen.lookup-func) 1) (define (kl:shen.lookup-func V2282) (guard (lambda (E) (simple-error (kl:shen.app V2282 " has no lambda expansion\n" (quote shen.a)))) (kl:get V2282 (quote shen.lambda-form) (kl:value (quote *property-vector*))))) (export shen.lookup-func) (quote shen.lookup-func))

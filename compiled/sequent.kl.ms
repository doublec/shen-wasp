(module "compiled/sequent.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.datatype-error) 1) (define (kl:shen.datatype-error V1664) (cond ((and (pair? V1664) (and (pair? (cdr V1664)) (null? (cdr (cdr V1664))))) (simple-error (string-append "datatype syntax error here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V1664)) "\n" (quote shen.a))))) (#t (kl:shen.f_error (quote shen.datatype-error))))) (export shen.datatype-error) (quote shen.datatype-error))
(begin (register-function-arity (quote shen.<datatype-rules>) 1) (define (kl:shen.<datatype-rules> V1666) (let ((YaccParse (let ((Parse_shen.<datatype-rule> (kl:shen.<datatype-rule> V1666))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rule>)) (let ((Parse_shen.<datatype-rules> (kl:shen.<datatype-rules> Parse_shen.<datatype-rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<datatype-rules>)) (kl:shen.pair (car Parse_shen.<datatype-rules>) (cons (kl:shen.hdtl Parse_shen.<datatype-rule>) (kl:shen.hdtl Parse_shen.<datatype-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1666))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<datatype-rules>) (quote shen.<datatype-rules>))
(begin (register-function-arity (quote shen.<datatype-rule>) 1) (define (kl:shen.<datatype-rule> V1668) (let ((YaccParse (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V1668))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<singleunderline> (kl:shen.<singleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<singleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.single) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> V1668))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<side-conditions>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (let ((Parse_shen.<doubleunderline> (kl:shen.<doubleunderline> Parse_shen.<premises>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<doubleunderline>)) (let ((Parse_shen.<conclusion> (kl:shen.<conclusion> Parse_shen.<doubleunderline>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<conclusion>)) (kl:shen.pair (car Parse_shen.<conclusion>) (kl:shen.sequent (quote shen.double) (cons (kl:shen.hdtl Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<conclusion>) (quote ())))))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) YaccParse))) (export shen.<datatype-rule>) (quote shen.<datatype-rule>))
(begin (register-function-arity (quote shen.<side-conditions>) 1) (define (kl:shen.<side-conditions> V1670) (let ((YaccParse (let ((Parse_shen.<side-condition> (kl:shen.<side-condition> V1670))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-condition>)) (let ((Parse_shen.<side-conditions> (kl:shen.<side-conditions> Parse_shen.<side-condition>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<side-conditions>)) (kl:shen.pair (car Parse_shen.<side-conditions>) (cons (kl:shen.hdtl Parse_shen.<side-condition>) (kl:shen.hdtl Parse_shen.<side-conditions>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1670))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<side-conditions>) (quote shen.<side-conditions>))
(begin (register-function-arity (quote shen.<side-condition>) 1) (define (kl:shen.<side-condition> V1674) (let ((YaccParse (if (and (pair? (car V1674)) (eq? (quote if) (kl:shen.hdhd V1674))) (let ((NewStream1671 (kl:shen.pair (kl:shen.tlhd V1674) (kl:shen.hdtl V1674)))) (let ((Parse_shen.<expr> (kl:shen.<expr> NewStream1671))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote if) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ())))) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (and (pair? (car V1674)) (eq? (quote let) (kl:shen.hdhd V1674))) (let ((NewStream1672 (kl:shen.pair (kl:shen.tlhd V1674) (kl:shen.hdtl V1674)))) (let ((Parse_shen.<variable?> (kl:shen.<variable?> NewStream1672))) (if (kl:not (kl:= (kl:fail) Parse_shen.<variable?>)) (let ((Parse_shen.<expr> (kl:shen.<expr> Parse_shen.<variable?>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (cons (quote let) (cons (kl:shen.hdtl Parse_shen.<variable?>) (cons (kl:shen.hdtl Parse_shen.<expr>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) YaccParse))) (export shen.<side-condition>) (quote shen.<side-condition>))
(begin (register-function-arity (quote shen.<variable?>) 1) (define (kl:shen.<variable?> V1676) (if (pair? (car V1676)) (let ((Parse_X (kl:shen.hdhd V1676))) (if (kl:variable? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1676) (kl:shen.hdtl V1676))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<variable?>) (quote shen.<variable?>))
(begin (register-function-arity (quote shen.<expr>) 1) (define (kl:shen.<expr> V1678) (if (pair? (car V1678)) (let ((Parse_X (kl:shen.hdhd V1678))) (if (kl:not (or (kl:element? Parse_X (cons (quote >>) (cons (quote _waspvm_sc_) (quote ())))) (or (assert-boolean (kl:shen.singleunderline? Parse_X)) (assert-boolean (kl:shen.doubleunderline? Parse_X))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1678) (kl:shen.hdtl V1678))) (kl:shen.remove-bar Parse_X)) (kl:fail))) (kl:fail))) (export shen.<expr>) (quote shen.<expr>))
(begin (register-function-arity (quote shen.remove-bar) 1) (define (kl:shen.remove-bar V1680) (cond ((and (pair? V1680) (and (pair? (cdr V1680)) (and (pair? (cdr (cdr V1680))) (and (null? (cdr (cdr (cdr V1680)))) (eq? (car (cdr V1680)) (quote bar!)))))) (cons (car V1680) (car (cdr (cdr V1680))))) ((pair? V1680) (cons (kl:shen.remove-bar (car V1680)) (kl:shen.remove-bar (cdr V1680)))) (#t V1680))) (export shen.remove-bar) (quote shen.remove-bar))
(begin (register-function-arity (quote shen.<premises>) 1) (define (kl:shen.<premises> V1682) (let ((YaccParse (let ((Parse_shen.<premise> (kl:shen.<premise> V1682))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premise>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<premise>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (let ((Parse_shen.<premises> (kl:shen.<premises> Parse_shen.<semicolon-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<premises>)) (kl:shen.pair (car Parse_shen.<premises>) (cons (kl:shen.hdtl Parse_shen.<premise>) (kl:shen.hdtl Parse_shen.<premises>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1682))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<premises>) (quote shen.<premises>))
(begin (register-function-arity (quote shen.<semicolon-symbol>) 1) (define (kl:shen.<semicolon-symbol> V1684) (if (pair? (car V1684)) (let ((Parse_X (kl:shen.hdhd V1684))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1684) (kl:shen.hdtl V1684))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<semicolon-symbol>) (quote shen.<semicolon-symbol>))
(begin (register-function-arity (quote shen.<premise>) 1) (define (kl:shen.<premise> V1688) (let ((YaccParse (if (and (pair? (car V1688)) (eq? (quote !) (kl:shen.hdhd V1688))) (let ((NewStream1685 (kl:shen.pair (kl:shen.tlhd V1688) (kl:shen.hdtl V1688)))) (kl:shen.pair (car NewStream1685) (quote !))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V1688))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (kl:shen.hdhd Parse_shen.<formulae>))) (let ((NewStream1686 (kl:shen.pair (kl:shen.tlhd Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> NewStream1686))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V1688))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) YaccParse)) YaccParse))) (export shen.<premise>) (quote shen.<premise>))
(begin (register-function-arity (quote shen.<conclusion>) 1) (define (kl:shen.<conclusion> V1691) (let ((YaccParse (let ((Parse_shen.<formulae> (kl:shen.<formulae> V1691))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (if (and (pair? (car Parse_shen.<formulae>)) (eq? (quote >>) (kl:shen.hdhd Parse_shen.<formulae>))) (let ((NewStream1689 (kl:shen.pair (kl:shen.tlhd Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formulae>)))) (let ((Parse_shen.<formula> (kl:shen.<formula> NewStream1689))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (kl:shen.hdtl Parse_shen.<formulae>) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<formula> (kl:shen.<formula> V1691))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<semicolon-symbol> (kl:shen.<semicolon-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon-symbol>)) (kl:shen.pair (car Parse_shen.<semicolon-symbol>) (kl:shen.sequent (quote ()) (kl:shen.hdtl Parse_shen.<formula>))) (kl:fail))) (kl:fail))) YaccParse))) (export shen.<conclusion>) (quote shen.<conclusion>))
(begin (register-function-arity (quote shen.sequent) 2) (define (kl:shen.sequent V1694 V1695) (kl:_waspvm_at_p V1694 V1695)) (export shen.sequent) (quote shen.sequent))
(begin (register-function-arity (quote shen.<formulae>) 1) (define (kl:shen.<formulae> V1697) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V1697))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (let ((Parse_shen.<comma-symbol> (kl:shen.<comma-symbol> Parse_shen.<formula>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma-symbol>)) (let ((Parse_shen.<formulae> (kl:shen.<formulae> Parse_shen.<comma-symbol>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formulae>)) (kl:shen.pair (car Parse_shen.<formulae>) (cons (kl:shen.hdtl Parse_shen.<formula>) (kl:shen.hdtl Parse_shen.<formulae>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<formula> (kl:shen.<formula> V1697))) (if (kl:not (kl:= (kl:fail) Parse_shen.<formula>)) (kl:shen.pair (car Parse_shen.<formula>) (cons (kl:shen.hdtl Parse_shen.<formula>) (quote ()))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1697))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse))) (export shen.<formulae>) (quote shen.<formulae>))
(begin (register-function-arity (quote shen.<comma-symbol>) 1) (define (kl:shen.<comma-symbol> V1699) (if (pair? (car V1699)) (let ((Parse_X (kl:shen.hdhd V1699))) (if (kl:= Parse_X (kl:intern ",")) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1699) (kl:shen.hdtl V1699))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<comma-symbol>) (quote shen.<comma-symbol>))
(begin (register-function-arity (quote shen.<formula>) 1) (define (kl:shen.<formula> V1702) (let ((YaccParse (let ((Parse_shen.<expr> (kl:shen.<expr> V1702))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (if (and (pair? (car Parse_shen.<expr>)) (eq? (quote :) (kl:shen.hdhd Parse_shen.<expr>))) (let ((NewStream1700 (kl:shen.pair (kl:shen.tlhd Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)))) (let ((Parse_shen.<type> (kl:shen.<type> NewStream1700))) (if (kl:not (kl:= (kl:fail) Parse_shen.<type>)) (kl:shen.pair (car Parse_shen.<type>) (cons (kl:shen.curry (kl:shen.hdtl Parse_shen.<expr>)) (cons (quote :) (cons (kl:shen.demodulate (kl:shen.hdtl Parse_shen.<type>)) (quote ()))))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<expr> (kl:shen.<expr> V1702))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.hdtl Parse_shen.<expr>)) (kl:fail))) YaccParse))) (export shen.<formula>) (quote shen.<formula>))
(begin (register-function-arity (quote shen.<type>) 1) (define (kl:shen.<type> V1704) (let ((Parse_shen.<expr> (kl:shen.<expr> V1704))) (if (kl:not (kl:= (kl:fail) Parse_shen.<expr>)) (kl:shen.pair (car Parse_shen.<expr>) (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<expr>))) (kl:fail)))) (export shen.<type>) (quote shen.<type>))
(begin (register-function-arity (quote shen.<doubleunderline>) 1) (define (kl:shen.<doubleunderline> V1706) (if (pair? (car V1706)) (let ((Parse_X (kl:shen.hdhd V1706))) (if (assert-boolean (kl:shen.doubleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1706) (kl:shen.hdtl V1706))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<doubleunderline>) (quote shen.<doubleunderline>))
(begin (register-function-arity (quote shen.<singleunderline>) 1) (define (kl:shen.<singleunderline> V1708) (if (pair? (car V1708)) (let ((Parse_X (kl:shen.hdhd V1708))) (if (assert-boolean (kl:shen.singleunderline? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1708) (kl:shen.hdtl V1708))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<singleunderline>) (quote shen.<singleunderline>))
(begin (register-function-arity (quote shen.singleunderline?) 1) (define (kl:shen.singleunderline? V1710) (and (kl:symbol? V1710) (assert-boolean (kl:shen.sh? (kl:str V1710))))) (export shen.singleunderline?) (quote shen.singleunderline?))
(begin (register-function-arity (quote shen.sh?) 1) (define (kl:shen.sh? V1712) (cond ((equal? "_" V1712) #t) (#t (and (equal? (make-string 1 (string-ref V1712 0)) "_") (assert-boolean (kl:shen.sh? (string-tail V1712 1))))))) (export shen.sh?) (quote shen.sh?))
(begin (register-function-arity (quote shen.doubleunderline?) 1) (define (kl:shen.doubleunderline? V1714) (and (kl:symbol? V1714) (assert-boolean (kl:shen.dh? (kl:str V1714))))) (export shen.doubleunderline?) (quote shen.doubleunderline?))
(begin (register-function-arity (quote shen.dh?) 1) (define (kl:shen.dh? V1716) (cond ((equal? "=" V1716) #t) (#t (and (equal? (make-string 1 (string-ref V1716 0)) "=") (assert-boolean (kl:shen.dh? (string-tail V1716 1))))))) (export shen.dh?) (quote shen.dh?))
(begin (register-function-arity (quote shen.process-datatype) 2) (define (kl:shen.process-datatype V1719 V1720) (kl:shen.remember-datatype (kl:shen.s-prolog (kl:shen.rules->horn-clauses V1719 V1720)))) (export shen.process-datatype) (quote shen.process-datatype))
(begin (register-function-arity (quote shen.remember-datatype) 1) (define (kl:shen.remember-datatype V1726) (cond ((pair? V1726) (begin (kl:set (quote shen.*datatypes*) (kl:adjoin (car V1726) (kl:value (quote shen.*datatypes*)))) (begin (kl:set (quote shen.*alldatatypes*) (kl:adjoin (car V1726) (kl:value (quote shen.*alldatatypes*)))) (car V1726)))) (#t (kl:shen.f_error (quote shen.remember-datatype))))) (export shen.remember-datatype) (quote shen.remember-datatype))
(begin (register-function-arity (quote shen.rules->horn-clauses) 2) (define (kl:shen.rules->horn-clauses V1731 V1732) (cond ((null? V1732) (quote ())) ((and (pair? V1732) (and (kl:tuple? (car V1732)) (eq? (quote shen.single) (kl:fst (car V1732))))) (cons (kl:shen.rule->horn-clause V1731 (kl:snd (car V1732))) (kl:shen.rules->horn-clauses V1731 (cdr V1732)))) ((and (pair? V1732) (and (kl:tuple? (car V1732)) (eq? (quote shen.double) (kl:fst (car V1732))))) (kl:shen.rules->horn-clauses V1731 (kl:append (kl:shen.double->singles (kl:snd (car V1732))) (cdr V1732)))) (#t (kl:shen.f_error (quote shen.rules->horn-clauses))))) (export shen.rules->horn-clauses) (quote shen.rules->horn-clauses))
(begin (register-function-arity (quote shen.double->singles) 1) (define (kl:shen.double->singles V1734) (cons (kl:shen.right-rule V1734) (cons (kl:shen.left-rule V1734) (quote ())))) (export shen.double->singles) (quote shen.double->singles))
(begin (register-function-arity (quote shen.right-rule) 1) (define (kl:shen.right-rule V1736) (kl:_waspvm_at_p (quote shen.single) V1736)) (export shen.right-rule) (quote shen.right-rule))
(begin (register-function-arity (quote shen.left-rule) 1) (define (kl:shen.left-rule V1738) (cond ((and (pair? V1738) (and (pair? (cdr V1738)) (and (pair? (cdr (cdr V1738))) (and (kl:tuple? (car (cdr (cdr V1738)))) (and (null? (kl:fst (car (cdr (cdr V1738))))) (null? (cdr (cdr (cdr V1738))))))))) (let ((Q (kl:gensym (quote Qv)))) (let ((NewConclusion (kl:_waspvm_at_p (cons (kl:snd (car (cdr (cdr V1738)))) (quote ())) Q))) (let ((NewPremises (cons (kl:_waspvm_at_p (kl:map (lambda (X) (kl:shen.right->left X)) (car (cdr V1738))) Q) (quote ())))) (kl:_waspvm_at_p (quote shen.single) (cons (car V1738) (cons NewPremises (cons NewConclusion (quote ()))))))))) (#t (kl:shen.f_error (quote shen.left-rule))))) (export shen.left-rule) (quote shen.left-rule))
(begin (register-function-arity (quote shen.right->left) 1) (define (kl:shen.right->left V1744) (cond ((and (kl:tuple? V1744) (null? (kl:fst V1744))) (kl:snd V1744)) (#t (simple-error "syntax error with ==========\n")))) (export shen.right->left) (quote shen.right->left))
(begin (register-function-arity (quote shen.rule->horn-clause) 2) (define (kl:shen.rule->horn-clause V1747 V1748) (cond ((and (pair? V1748) (and (pair? (cdr V1748)) (and (pair? (cdr (cdr V1748))) (and (kl:tuple? (car (cdr (cdr V1748)))) (null? (cdr (cdr (cdr V1748)))))))) (cons (kl:shen.rule->horn-clause-head V1747 (kl:snd (car (cdr (cdr V1748))))) (cons (quote :-) (cons (kl:shen.rule->horn-clause-body (car V1748) (car (cdr V1748)) (kl:fst (car (cdr (cdr V1748))))) (quote ()))))) (#t (kl:shen.f_error (quote shen.rule->horn-clause))))) (export shen.rule->horn-clause) (quote shen.rule->horn-clause))
(begin (register-function-arity (quote shen.rule->horn-clause-head) 2) (define (kl:shen.rule->horn-clause-head V1751 V1752) (cons V1751 (cons (kl:shen.mode-ify V1752) (cons (quote Context_1957) (quote ()))))) (export shen.rule->horn-clause-head) (quote shen.rule->horn-clause-head))
(begin (register-function-arity (quote shen.mode-ify) 1) (define (kl:shen.mode-ify V1754) (cond ((and (pair? V1754) (and (pair? (cdr V1754)) (and (eq? (quote :) (car (cdr V1754))) (and (pair? (cdr (cdr V1754))) (null? (cdr (cdr (cdr V1754)))))))) (cons (quote mode) (cons (cons (car V1754) (cons (quote :) (cons (cons (quote mode) (cons (car (cdr (cdr V1754))) (cons (quote +) (quote ())))) (quote ())))) (cons (quote -) (quote ()))))) (#t V1754))) (export shen.mode-ify) (quote shen.mode-ify))
(begin (register-function-arity (quote shen.rule->horn-clause-body) 3) (define (kl:shen.rule->horn-clause-body V1758 V1759 V1760) (let ((Variables (kl:map (lambda (X) (kl:shen.extract_vars X)) V1760))) (let ((Predicates (kl:map (lambda (X) (kl:gensym (quote shen.cl))) V1760))) (let ((SearchLiterals (kl:shen.construct-search-literals Predicates Variables (quote Context_1957) (quote Context1_1957)))) (let ((SearchClauses (kl:shen.construct-search-clauses Predicates V1760 Variables))) (let ((SideLiterals (kl:shen.construct-side-literals V1758))) (let ((PremissLiterals (kl:map (lambda (X) (kl:shen.construct-premiss-literal X (kl:empty? V1760))) V1759))) (kl:append SearchLiterals (kl:append SideLiterals PremissLiterals))))))))) (export shen.rule->horn-clause-body) (quote shen.rule->horn-clause-body))
(begin (register-function-arity (quote shen.construct-search-literals) 4) (define (kl:shen.construct-search-literals V1769 V1770 V1771 V1772) (cond ((and (null? V1769) (null? V1770)) (quote ())) (#t (kl:shen.csl-help V1769 V1770 V1771 V1772)))) (export shen.construct-search-literals) (quote shen.construct-search-literals))
(begin (register-function-arity (quote shen.csl-help) 4) (define (kl:shen.csl-help V1779 V1780 V1781 V1782) (cond ((and (null? V1779) (null? V1780)) (cons (cons (quote bind) (cons (quote ContextOut_1957) (cons V1781 (quote ())))) (quote ()))) ((and (pair? V1779) (pair? V1780)) (cons (cons (car V1779) (cons V1781 (cons V1782 (car V1780)))) (kl:shen.csl-help (cdr V1779) (cdr V1780) V1782 (kl:gensym (quote Context))))) (#t (kl:shen.f_error (quote shen.csl-help))))) (export shen.csl-help) (quote shen.csl-help))
(begin (register-function-arity (quote shen.construct-search-clauses) 3) (define (kl:shen.construct-search-clauses V1786 V1787 V1788) (cond ((and (null? V1786) (and (null? V1787) (null? V1788))) (quote shen.skip)) ((and (pair? V1786) (and (pair? V1787) (pair? V1788))) (begin (kl:shen.construct-search-clause (car V1786) (car V1787) (car V1788)) (kl:shen.construct-search-clauses (cdr V1786) (cdr V1787) (cdr V1788)))) (#t (kl:shen.f_error (quote shen.construct-search-clauses))))) (export shen.construct-search-clauses) (quote shen.construct-search-clauses))
(begin (register-function-arity (quote shen.construct-search-clause) 3) (define (kl:shen.construct-search-clause V1792 V1793 V1794) (kl:shen.s-prolog (cons (kl:shen.construct-base-search-clause V1792 V1793 V1794) (cons (kl:shen.construct-recursive-search-clause V1792 V1793 V1794) (quote ()))))) (export shen.construct-search-clause) (quote shen.construct-search-clause))
(begin (register-function-arity (quote shen.construct-base-search-clause) 3) (define (kl:shen.construct-base-search-clause V1798 V1799 V1800) (cons (cons V1798 (cons (cons (kl:shen.mode-ify V1799) (quote In_1957)) (cons (quote In_1957) V1800))) (cons (quote :-) (cons (quote ()) (quote ()))))) (export shen.construct-base-search-clause) (quote shen.construct-base-search-clause))
(begin (register-function-arity (quote shen.construct-recursive-search-clause) 3) (define (kl:shen.construct-recursive-search-clause V1804 V1805 V1806) (cons (cons V1804 (cons (cons (quote Assumption_1957) (quote Assumptions_1957)) (cons (cons (quote Assumption_1957) (quote Out_1957)) V1806))) (cons (quote :-) (cons (cons (cons V1804 (cons (quote Assumptions_1957) (cons (quote Out_1957) V1806))) (quote ())) (quote ()))))) (export shen.construct-recursive-search-clause) (quote shen.construct-recursive-search-clause))
(begin (register-function-arity (quote shen.construct-side-literals) 1) (define (kl:shen.construct-side-literals V1812) (cond ((null? V1812) (quote ())) ((and (pair? V1812) (and (pair? (car V1812)) (and (eq? (quote if) (car (car V1812))) (and (pair? (cdr (car V1812))) (null? (cdr (cdr (car V1812)))))))) (cons (cons (quote when) (cdr (car V1812))) (kl:shen.construct-side-literals (cdr V1812)))) ((and (pair? V1812) (and (pair? (car V1812)) (and (eq? (quote let) (car (car V1812))) (and (pair? (cdr (car V1812))) (and (pair? (cdr (cdr (car V1812)))) (null? (cdr (cdr (cdr (car V1812)))))))))) (cons (cons (quote is) (cdr (car V1812))) (kl:shen.construct-side-literals (cdr V1812)))) ((pair? V1812) (kl:shen.construct-side-literals (cdr V1812))) (#t (kl:shen.f_error (quote shen.construct-side-literals))))) (export shen.construct-side-literals) (quote shen.construct-side-literals))
(begin (register-function-arity (quote shen.construct-premiss-literal) 2) (define (kl:shen.construct-premiss-literal V1819 V1820) (cond ((kl:tuple? V1819) (cons (quote shen.t*) (cons (kl:shen.recursive_cons_form (kl:snd V1819)) (cons (kl:shen.construct-context V1820 (kl:fst V1819)) (quote ()))))) ((eq? (quote !) V1819) (cons (quote cut) (cons (quote Throwcontrol) (quote ())))) (#t (kl:shen.f_error (quote shen.construct-premiss-literal))))) (export shen.construct-premiss-literal) (quote shen.construct-premiss-literal))
(begin (register-function-arity (quote shen.construct-context) 2) (define (kl:shen.construct-context V1823 V1824) (cond ((and (kl:= #t V1823) (null? V1824)) (quote Context_1957)) ((and (kl:= #f V1823) (null? V1824)) (quote ContextOut_1957)) ((pair? V1824) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V1824)) (cons (kl:shen.construct-context V1823 (cdr V1824)) (quote ()))))) (#t (kl:shen.f_error (quote shen.construct-context))))) (export shen.construct-context) (quote shen.construct-context))
(begin (register-function-arity (quote shen.recursive_cons_form) 1) (define (kl:shen.recursive_cons_form V1826) (cond ((pair? V1826) (cons (quote cons) (cons (kl:shen.recursive_cons_form (car V1826)) (cons (kl:shen.recursive_cons_form (cdr V1826)) (quote ()))))) (#t V1826))) (export shen.recursive_cons_form) (quote shen.recursive_cons_form))
(begin (register-function-arity (quote preclude) 1) (define (kl:preclude V1828) (kl:shen.preclude-h (kl:map (lambda (X) (kl:shen.intern-type X)) V1828))) (export preclude) (quote preclude))
(begin (register-function-arity (quote shen.preclude-h) 1) (define (kl:shen.preclude-h V1830) (let ((FilterDatatypes (kl:set (quote shen.*datatypes*) (kl:difference (kl:value (quote shen.*datatypes*)) V1830)))) (kl:value (quote shen.*datatypes*)))) (export shen.preclude-h) (quote shen.preclude-h))
(begin (register-function-arity (quote include) 1) (define (kl:include V1832) (kl:shen.include-h (kl:map (lambda (X) (kl:shen.intern-type X)) V1832))) (export include) (quote include))
(begin (register-function-arity (quote shen.include-h) 1) (define (kl:shen.include-h V1834) (let ((ValidTypes (kl:intersection V1834 (kl:value (quote shen.*alldatatypes*))))) (let ((NewDatatypes (kl:set (quote shen.*datatypes*) (kl:union ValidTypes (kl:value (quote shen.*datatypes*)))))) (kl:value (quote shen.*datatypes*))))) (export shen.include-h) (quote shen.include-h))
(begin (register-function-arity (quote preclude-all-but) 1) (define (kl:preclude-all-but V1836) (kl:shen.preclude-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V1836)))) (export preclude-all-but) (quote preclude-all-but))
(begin (register-function-arity (quote include-all-but) 1) (define (kl:include-all-but V1838) (kl:shen.include-h (kl:difference (kl:value (quote shen.*alldatatypes*)) (kl:map (lambda (X) (kl:shen.intern-type X)) V1838)))) (export include-all-but) (quote include-all-but))
(begin (register-function-arity (quote shen.synonyms-help) 1) (define (kl:shen.synonyms-help V1844) (cond ((null? V1844) (kl:shen.update-demodulation-function (kl:value (quote shen.*tc*)) (kl:mapcan (lambda (X) (kl:shen.demod-rule X)) (kl:value (quote shen.*synonyms*))))) ((and (pair? V1844) (pair? (cdr V1844))) (let ((Vs (kl:difference (kl:shen.extract_vars (car (cdr V1844))) (kl:shen.extract_vars (car V1844))))) (if (kl:empty? Vs) (begin (kl:shen.pushnew (cons (car V1844) (cons (car (cdr V1844)) (quote ()))) (quote shen.*synonyms*)) (kl:shen.synonyms-help (cdr (cdr V1844)))) (kl:shen.free_variable_warnings (car (cdr V1844)) Vs)))) (#t (simple-error "odd number of synonyms\n")))) (export shen.synonyms-help) (quote shen.synonyms-help))
(begin (register-function-arity (quote shen.pushnew) 2) (define (kl:shen.pushnew V1847 V1848) (if (kl:element? V1847 (kl:value V1848)) (kl:value V1848) (kl:set V1848 (cons V1847 (kl:value V1848))))) (export shen.pushnew) (quote shen.pushnew))
(begin (register-function-arity (quote shen.demod-rule) 1) (define (kl:shen.demod-rule V1850) (cond ((and (pair? V1850) (and (pair? (cdr V1850)) (null? (cdr (cdr V1850))))) (cons (kl:shen.rcons_form (car V1850)) (cons (quote ->) (cons (kl:shen.rcons_form (car (cdr V1850))) (quote ()))))) (#t (kl:shen.f_error (quote shen.demod-rule))))) (export shen.demod-rule) (quote shen.demod-rule))
(begin (register-function-arity (quote shen.lambda-of-defun) 1) (define (kl:shen.lambda-of-defun V1856) (cond ((and (pair? V1856) (and (eq? (quote defun) (car V1856)) (and (pair? (cdr V1856)) (and (pair? (cdr (cdr V1856))) (and (pair? (car (cdr (cdr V1856)))) (and (null? (cdr (car (cdr (cdr V1856))))) (and (pair? (cdr (cdr (cdr V1856)))) (null? (cdr (cdr (cdr (cdr V1856)))))))))))) (kl:eval (cons (quote /.) (cons (car (car (cdr (cdr V1856)))) (cdr (cdr (cdr V1856))))))) (#t (kl:shen.f_error (quote shen.lambda-of-defun))))) (export shen.lambda-of-defun) (quote shen.lambda-of-defun))
(begin (register-function-arity (quote shen.update-demodulation-function) 2) (define (kl:shen.update-demodulation-function V1859 V1860) (begin (kl:tc (quote -)) (begin (kl:set (quote shen.*demodulation-function*) (kl:shen.lambda-of-defun (kl:shen.elim-def (cons (quote define) (cons (quote shen.demod) (kl:append V1860 (kl:shen.default-rule))))))) (begin (if (assert-boolean V1859) (kl:tc (quote +)) (quote shen.skip)) (quote synonyms))))) (export shen.update-demodulation-function) (quote shen.update-demodulation-function))
(begin (register-function-arity (quote shen.default-rule) 0) (define (kl:shen.default-rule) (cons (quote X) (cons (quote ->) (cons (quote X) (quote ()))))) (export shen.default-rule) (quote shen.default-rule))

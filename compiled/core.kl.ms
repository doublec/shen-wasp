(module "compiled/core.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.shen->kl) 2) (define (kl:shen.shen->kl V94 V95) (kl:compile (lambda (X) (kl:shen.<define> X)) (cons V94 V95) (lambda (X) (kl:shen.shen-syntax-error V94 X)))) (export shen.shen->kl) (quote shen.shen->kl))
(begin (register-function-arity (quote shen.shen-syntax-error) 2) (define (kl:shen.shen-syntax-error V102 V103) (cond ((pair? V103) (simple-error (string-append "syntax error in " (kl:shen.app V102 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V103)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "syntax error in " (kl:shen.app V102 "\n" (quote shen.a))))))) (export shen.shen-syntax-error) (quote shen.shen-syntax-error))
(begin (register-function-arity (quote shen.<define>) 1) (define (kl:shen.<define> V105) (let ((YaccParse (let ((Parse_shen.<name> (kl:shen.<name> V105))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<signature> (kl:shen.<signature> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<name> (kl:shen.<name> V105))) (if (kl:not (kl:= (kl:fail) Parse_shen.<name>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<name>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (kl:shen.compile_to_machine_code (kl:shen.hdtl Parse_shen.<name>) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))) YaccParse))) (export shen.<define>) (quote shen.<define>))
(begin (register-function-arity (quote shen.<name>) 1) (define (kl:shen.<name> V107) (if (pair? (car V107)) (let ((Parse_X (kl:shen.hdhd V107))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V107) (kl:shen.hdtl V107))) (if (and (kl:symbol? Parse_X) (kl:not (kl:shen.sysfunc? Parse_X))) Parse_X (simple-error (kl:shen.app Parse_X " is not a legitimate function name.\n" (quote shen.a)))))) (kl:fail))) (export shen.<name>) (quote shen.<name>))
(begin (register-function-arity (quote shen.sysfunc?) 1) (define (kl:shen.sysfunc? V109) (kl:element? V109 (kl:get (kl:intern "shen") (quote shen.external-symbols) (kl:value (quote *property-vector*))))) (export shen.sysfunc?) (quote shen.sysfunc?))
(begin (register-function-arity (quote shen.<signature>) 1) (define (kl:shen.<signature> V113) (if (and (pair? (car V113)) (eq? (quote {) (kl:shen.hdhd V113))) (let ((NewStream110 (kl:shen.pair (kl:shen.tlhd V113) (kl:shen.hdtl V113)))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> NewStream110))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (and (pair? (car Parse_shen.<signature-help>)) (eq? (quote }) (kl:shen.hdhd Parse_shen.<signature-help>))) (let ((NewStream111 (kl:shen.pair (kl:shen.tlhd Parse_shen.<signature-help>) (kl:shen.hdtl Parse_shen.<signature-help>)))) (kl:shen.pair (car NewStream111) (kl:shen.demodulate (kl:shen.curry-type (kl:shen.hdtl Parse_shen.<signature-help>))))) (kl:fail)) (kl:fail)))) (kl:fail))) (export shen.<signature>) (quote shen.<signature>))
(begin (register-function-arity (quote shen.curry-type) 1) (define (kl:shen.curry-type V115) (kl:shen.active-cons (kl:shen.curry-type-h V115))) (export shen.curry-type) (quote shen.curry-type))
(begin (register-function-arity (quote shen.active-cons) 1) (define (kl:shen.active-cons V117) (cond ((and (pair? V117) (and (pair? (cdr V117)) (and (pair? (cdr (cdr V117))) (and (null? (cdr (cdr (cdr V117)))) (eq? (car (cdr V117)) (quote bar!)))))) (cons (kl:shen.active-cons (car V117)) (kl:shen.active-cons (car (cdr (cdr V117)))))) ((pair? V117) (cons (kl:shen.active-cons (car V117)) (kl:shen.active-cons (cdr V117)))) (#t V117))) (export shen.active-cons) (quote shen.active-cons))
(begin (register-function-arity (quote shen.curry-type-h) 1) (define (kl:shen.curry-type-h V119) (cond ((and (pair? V119) (and (pair? (cdr V119)) (and (eq? (quote -->) (car (cdr V119))) (and (pair? (cdr (cdr V119))) (and (pair? (cdr (cdr (cdr V119)))) (eq? (quote -->) (car (cdr (cdr (cdr V119)))))))))) (kl:shen.curry-type-h (cons (car V119) (cons (quote -->) (cons (cdr (cdr V119)) (quote ())))))) ((and (pair? V119) (and (pair? (cdr V119)) (and (eq? (quote *) (car (cdr V119))) (and (pair? (cdr (cdr V119))) (and (pair? (cdr (cdr (cdr V119)))) (eq? (quote *) (car (cdr (cdr (cdr V119)))))))))) (kl:shen.curry-type-h (cons (car V119) (cons (quote *) (cons (cdr (cdr V119)) (quote ())))))) ((pair? V119) (kl:map (lambda (Z) (kl:shen.curry-type-h Z)) V119)) (#t V119))) (export shen.curry-type-h) (quote shen.curry-type-h))
(begin (register-function-arity (quote shen.<signature-help>) 1) (define (kl:shen.<signature-help> V121) (let ((YaccParse (if (pair? (car V121)) (let ((Parse_X (kl:shen.hdhd V121))) (let ((Parse_shen.<signature-help> (kl:shen.<signature-help> (kl:shen.pair (kl:shen.tlhd V121) (kl:shen.hdtl V121))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature-help>)) (if (kl:not (kl:element? Parse_X (cons (quote {) (cons (quote }) (quote ()))))) (kl:shen.pair (car Parse_shen.<signature-help>) (cons Parse_X (kl:shen.hdtl Parse_shen.<signature-help>))) (kl:fail)) (kl:fail)))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V121))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<signature-help>) (quote shen.<signature-help>))
(begin (register-function-arity (quote shen.<rules>) 1) (define (kl:shen.<rules> V123) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V123))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<rules> (kl:shen.<rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rules>)) (kl:shen.pair (car Parse_shen.<rules>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (kl:shen.hdtl Parse_shen.<rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V123))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.linearise (kl:shen.hdtl Parse_shen.<rule>)) (quote ()))) (kl:fail))) YaccParse))) (export shen.<rules>) (quote shen.<rules>))
(begin (register-function-arity (quote shen.<rule>) 1) (define (kl:shen.<rule> V131) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V131))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream124 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream124))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (kl:shen.hdhd Parse_shen.<action>))) (let ((NewStream125 (kl:shen.pair (kl:shen.tlhd Parse_shen.<action>) (kl:shen.hdtl Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> NewStream125))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V131))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote ->) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream126 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream126))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<patterns> (kl:shen.<patterns> V131))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream127 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream127))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (if (and (pair? (car Parse_shen.<action>)) (eq? (quote where) (kl:shen.hdhd Parse_shen.<action>))) (let ((NewStream128 (kl:shen.pair (kl:shen.tlhd Parse_shen.<action>) (kl:shen.hdtl Parse_shen.<action>)))) (let ((Parse_shen.<guard> (kl:shen.<guard> NewStream128))) (if (kl:not (kl:= (kl:fail) Parse_shen.<guard>)) (kl:shen.pair (car Parse_shen.<guard>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote where) (cons (kl:shen.hdtl Parse_shen.<guard>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail)))) (kl:fail)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> V131))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (if (and (pair? (car Parse_shen.<patterns>)) (eq? (quote <-) (kl:shen.hdhd Parse_shen.<patterns>))) (let ((NewStream129 (kl:shen.pair (kl:shen.tlhd Parse_shen.<patterns>) (kl:shen.hdtl Parse_shen.<patterns>)))) (let ((Parse_shen.<action> (kl:shen.<action> NewStream129))) (if (kl:not (kl:= (kl:fail) Parse_shen.<action>)) (kl:shen.pair (car Parse_shen.<action>) (cons (kl:shen.hdtl Parse_shen.<patterns>) (cons (cons (quote shen.choicepoint!) (cons (kl:shen.hdtl Parse_shen.<action>) (quote ()))) (quote ())))) (kl:fail)))) (kl:fail)) (kl:fail))) YaccParse)) YaccParse)) YaccParse))) (export shen.<rule>) (quote shen.<rule>))
(begin (register-function-arity (quote shen.fail_if) 2) (define (kl:shen.fail_if V134 V135) (if (assert-boolean (V134 V135)) (kl:fail) V135)) (export shen.fail_if) (quote shen.fail_if))
(begin (register-function-arity (quote shen.succeeds?) 1) (define (kl:shen.succeeds? V141) (cond ((kl:= V141 (kl:fail)) #f) (#t #t))) (export shen.succeeds?) (quote shen.succeeds?))
(begin (register-function-arity (quote shen.custom-pattern-compiler) 2) (define (kl:shen.custom-pattern-compiler V144 V145) (((kl:value (quote shen.*custom-pattern-compiler*)) V144) V145)) (export shen.custom-pattern-compiler) (quote shen.custom-pattern-compiler))
(begin (register-function-arity (quote shen.custom-pattern-reducer) 1) (define (kl:shen.custom-pattern-reducer V147) ((kl:value (quote shen.*custom-pattern-reducer*)) V147)) (export shen.custom-pattern-reducer) (quote shen.custom-pattern-reducer))
(begin (register-function-arity (quote shen.<patterns>) 1) (define (kl:shen.<patterns> V149) (let ((YaccParse (let ((Parse_shen.<pattern> (kl:shen.<pattern> V149))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (let ((Parse_shen.<patterns> (kl:shen.<patterns> Parse_shen.<pattern>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<patterns>)) (kl:shen.pair (car Parse_shen.<patterns>) (cons (kl:shen.hdtl Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<patterns>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V149))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<patterns>) (quote shen.<patterns>))
(begin (register-function-arity (quote shen.<pattern>) 1) (define (kl:shen.<pattern> V162) (let ((YaccParse (if (and (pair? (car V162)) (pair? (kl:shen.hdhd V162))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))) (eq? (quote _waspvm_at_p) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))))) (let ((NewStream151 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream151))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V162) (kl:shen.hdtl V162))) (cons (quote _waspvm_at_p) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V162)) (pair? (kl:shen.hdhd V162))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))) (eq? (quote cons) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))))) (let ((NewStream153 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream153))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V162) (kl:shen.hdtl V162))) (cons (quote cons) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V162)) (pair? (kl:shen.hdhd V162))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))) (eq? (quote _waspvm_at_v) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))))) (let ((NewStream155 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream155))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V162) (kl:shen.hdtl V162))) (cons (quote _waspvm_at_v) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V162)) (pair? (kl:shen.hdhd V162))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))) (eq? (quote _waspvm_at_s) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))))) (let ((NewStream157 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))))) (let ((Parse_shen.<pattern1> (kl:shen.<pattern1> NewStream157))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern1>)) (let ((Parse_shen.<pattern2> (kl:shen.<pattern2> Parse_shen.<pattern1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern2>)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V162) (kl:shen.hdtl V162))) (cons (quote _waspvm_at_s) (cons (kl:shen.hdtl Parse_shen.<pattern1>) (cons (kl:shen.hdtl Parse_shen.<pattern2>) (quote ()))))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (and (pair? (car V162)) (pair? (kl:shen.hdhd V162))) (if (and (pair? (car (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))) (eq? (quote vector) (kl:shen.hdhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))))) (let ((NewStream159 (kl:shen.pair (kl:shen.tlhd (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162))) (kl:shen.hdtl (kl:shen.pair (kl:shen.hdhd V162) (kl:shen.hdtl V162)))))) (if (and (pair? (car NewStream159)) (kl:= 0 (kl:shen.hdhd NewStream159))) (let ((NewStream160 (kl:shen.pair (kl:shen.tlhd NewStream159) (kl:shen.hdtl NewStream159)))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V162) (kl:shen.hdtl V162))) (cons (quote vector) (cons 0 (quote ()))))) (kl:fail))) (kl:fail)) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (if (pair? (car V162)) (let ((Parse_X (kl:shen.hdhd V162))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V162) (kl:shen.hdtl V162))) (kl:shen.custom-pattern-compiler Parse_X (lambda () (kl:shen.constructor-error Parse_X)))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<simple_pattern> (kl:shen.<simple_pattern> V162))) (if (kl:not (kl:= (kl:fail) Parse_shen.<simple_pattern>)) (kl:shen.pair (car Parse_shen.<simple_pattern>) (kl:shen.hdtl Parse_shen.<simple_pattern>)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (export shen.<pattern>) (quote shen.<pattern>))
(begin (register-function-arity (quote shen.constructor-error) 1) (define (kl:shen.constructor-error V164) (simple-error (kl:shen.app V164 " is not a legitimate constructor\n" (quote shen.a)))) (export shen.constructor-error) (quote shen.constructor-error))
(begin (register-function-arity (quote shen.<simple_pattern>) 1) (define (kl:shen.<simple_pattern> V166) (let ((YaccParse (if (pair? (car V166)) (let ((Parse_X (kl:shen.hdhd V166))) (if (eq? Parse_X (quote _)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V166) (kl:shen.hdtl V166))) (kl:gensym (quote Parse_Y))) (kl:fail))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V166)) (let ((Parse_X (kl:shen.hdhd V166))) (if (kl:not (kl:element? Parse_X (cons (quote ->) (cons (quote <-) (quote ()))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V166) (kl:shen.hdtl V166))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (export shen.<simple_pattern>) (quote shen.<simple_pattern>))
(begin (register-function-arity (quote shen.<pattern1>) 1) (define (kl:shen.<pattern1> V168) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V168))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (export shen.<pattern1>) (quote shen.<pattern1>))
(begin (register-function-arity (quote shen.<pattern2>) 1) (define (kl:shen.<pattern2> V170) (let ((Parse_shen.<pattern> (kl:shen.<pattern> V170))) (if (kl:not (kl:= (kl:fail) Parse_shen.<pattern>)) (kl:shen.pair (car Parse_shen.<pattern>) (kl:shen.hdtl Parse_shen.<pattern>)) (kl:fail)))) (export shen.<pattern2>) (quote shen.<pattern2>))
(begin (register-function-arity (quote shen.<action>) 1) (define (kl:shen.<action> V172) (if (pair? (car V172)) (let ((Parse_X (kl:shen.hdhd V172))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V172) (kl:shen.hdtl V172))) Parse_X)) (kl:fail))) (export shen.<action>) (quote shen.<action>))
(begin (register-function-arity (quote shen.<guard>) 1) (define (kl:shen.<guard> V174) (if (pair? (car V174)) (let ((Parse_X (kl:shen.hdhd V174))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V174) (kl:shen.hdtl V174))) Parse_X)) (kl:fail))) (export shen.<guard>) (quote shen.<guard>))
(begin (register-function-arity (quote shen.compile_to_machine_code) 2) (define (kl:shen.compile_to_machine_code V177 V178) (let ((Lambda+ (kl:shen.compile_to_lambda+ V177 V178))) (let ((KL (kl:shen.compile_to_kl V177 Lambda+))) (let ((Record (kl:shen.record-source V177 KL))) KL)))) (export shen.compile_to_machine_code) (quote shen.compile_to_machine_code))
(begin (register-function-arity (quote shen.record-source) 2) (define (kl:shen.record-source V183 V184) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V183 (quote shen.source) V184 (kl:value (quote *property-vector*)))))) (export shen.record-source) (quote shen.record-source))
(begin (register-function-arity (quote shen.compile_to_lambda+) 2) (define (kl:shen.compile_to_lambda+ V187 V188) (let ((Arity (kl:shen.aritycheck V187 V188))) (let ((UpDateSymbolTable (kl:shen.update-symbol-table V187 Arity))) (let ((Free (kl:shen.for-each (lambda (Rule) (kl:shen.free_variable_check V187 Rule)) V188))) (let ((Variables (kl:shen.parameters Arity))) (let ((Strip (kl:map (lambda (X) (kl:shen.strip-protect X)) V188))) (let ((Abstractions (kl:map (lambda (X) (kl:shen.abstract_rule X)) Strip))) (let ((Applications (kl:map (lambda (X) (kl:shen.application_build Variables X)) Abstractions))) (cons Variables (cons Applications (quote ()))))))))))) (export shen.compile_to_lambda+) (quote shen.compile_to_lambda+))
(begin (register-function-arity (quote shen.update-symbol-table) 2) (define (kl:shen.update-symbol-table V191 V192) (cond ((kl:= 0 V192) (quote shen.skip)) (#t (kl:put V191 (quote shen.lambda-form) (kl:eval-kl (kl:shen.lambda-form V191 V192)) (kl:value (quote *property-vector*)))))) (export shen.update-symbol-table) (quote shen.update-symbol-table))
(begin (register-function-arity (quote shen.free_variable_check) 2) (define (kl:shen.free_variable_check V195 V196) (cond ((and (pair? V196) (and (pair? (cdr V196)) (null? (cdr (cdr V196))))) (let ((Bound (kl:shen.extract_vars (car V196)))) (let ((Free (kl:shen.extract_free_vars Bound (car (cdr V196))))) (kl:shen.free_variable_warnings V195 Free)))) (#t (kl:shen.f_error (quote shen.free_variable_check))))) (export shen.free_variable_check) (quote shen.free_variable_check))
(begin (register-function-arity (quote shen.extract_vars) 1) (define (kl:shen.extract_vars V198) (cond ((kl:variable? V198) (cons V198 (quote ()))) ((pair? V198) (kl:union (kl:shen.extract_vars (car V198)) (kl:shen.extract_vars (cdr V198)))) (#t (quote ())))) (export shen.extract_vars) (quote shen.extract_vars))
(begin (register-function-arity (quote shen.extract_free_vars) 2) (define (kl:shen.extract_free_vars V210 V211) (cond ((and (pair? V211) (and (pair? (cdr V211)) (and (null? (cdr (cdr V211))) (eq? (car V211) (quote protect))))) (quote ())) ((and (kl:variable? V211) (kl:not (kl:element? V211 V210))) (cons V211 (quote ()))) ((and (pair? V211) (and (eq? (quote lambda) (car V211)) (and (pair? (cdr V211)) (and (pair? (cdr (cdr V211))) (null? (cdr (cdr (cdr V211)))))))) (kl:shen.extract_free_vars (cons (car (cdr V211)) V210) (car (cdr (cdr V211))))) ((and (pair? V211) (and (eq? (quote let) (car V211)) (and (pair? (cdr V211)) (and (pair? (cdr (cdr V211))) (and (pair? (cdr (cdr (cdr V211)))) (null? (cdr (cdr (cdr (cdr V211)))))))))) (kl:union (kl:shen.extract_free_vars V210 (car (cdr (cdr V211)))) (kl:shen.extract_free_vars (cons (car (cdr V211)) V210) (car (cdr (cdr (cdr V211))))))) ((pair? V211) (kl:union (kl:shen.extract_free_vars V210 (car V211)) (kl:shen.extract_free_vars V210 (cdr V211)))) (#t (quote ())))) (export shen.extract_free_vars) (quote shen.extract_free_vars))
(begin (register-function-arity (quote shen.free_variable_warnings) 2) (define (kl:shen.free_variable_warnings V216 V217) (cond ((null? V217) (quote _)) (#t (simple-error (string-append "error: the following variables are free in " (kl:shen.app V216 (string-append ": " (kl:shen.app (kl:shen.list_variables V217) "" (quote shen.a))) (quote shen.a))))))) (export shen.free_variable_warnings) (quote shen.free_variable_warnings))
(begin (register-function-arity (quote shen.list_variables) 1) (define (kl:shen.list_variables V219) (cond ((and (pair? V219) (null? (cdr V219))) (string-append (kl:str (car V219)) ".")) ((pair? V219) (string-append (kl:str (car V219)) (string-append ", " (kl:shen.list_variables (cdr V219))))) (#t (kl:shen.f_error (quote shen.list_variables))))) (export shen.list_variables) (quote shen.list_variables))
(begin (register-function-arity (quote shen.strip-protect) 1) (define (kl:shen.strip-protect V221) (cond ((and (pair? V221) (and (pair? (cdr V221)) (and (null? (cdr (cdr V221))) (eq? (car V221) (quote protect))))) (kl:shen.strip-protect (car (cdr V221)))) ((pair? V221) (kl:map (lambda (Z) (kl:shen.strip-protect Z)) V221)) (#t V221))) (export shen.strip-protect) (quote shen.strip-protect))
(begin (register-function-arity (quote shen.linearise) 1) (define (kl:shen.linearise V223) (cond ((and (pair? V223) (and (pair? (cdr V223)) (null? (cdr (cdr V223))))) (kl:shen.linearise_help (kl:shen.flatten (car V223)) (car V223) (car (cdr V223)))) (#t (kl:shen.f_error (quote shen.linearise))))) (export shen.linearise) (quote shen.linearise))
(begin (register-function-arity (quote shen.flatten) 1) (define (kl:shen.flatten V225) (cond ((null? V225) (quote ())) ((pair? V225) (kl:append (kl:shen.flatten (car V225)) (kl:shen.flatten (cdr V225)))) (#t (cons V225 (quote ()))))) (export shen.flatten) (quote shen.flatten))
(begin (register-function-arity (quote shen.linearise_help) 3) (define (kl:shen.linearise_help V229 V230 V231) (cond ((null? V229) (cons V230 (cons V231 (quote ())))) ((pair? V229) (if (and (kl:variable? (car V229)) (kl:element? (car V229) (cdr V229))) (let ((Var (kl:gensym (car V229)))) (let ((NewAction (cons (quote where) (cons (cons (quote =) (cons (car V229) (cons Var (quote ())))) (cons V231 (quote ())))))) (let ((NewPatts (kl:shen.linearise_X (car V229) Var V230))) (kl:shen.linearise_help (cdr V229) NewPatts NewAction)))) (kl:shen.linearise_help (cdr V229) V230 V231))) (#t (kl:shen.f_error (quote shen.linearise_help))))) (export shen.linearise_help) (quote shen.linearise_help))
(begin (register-function-arity (quote shen.linearise_X) 3) (define (kl:shen.linearise_X V244 V245 V246) (cond ((kl:= V246 V244) V245) ((pair? V246) (let ((L (kl:shen.linearise_X V244 V245 (car V246)))) (if (kl:= L (car V246)) (cons (car V246) (kl:shen.linearise_X V244 V245 (cdr V246))) (cons L (cdr V246))))) (#t V246))) (export shen.linearise_X) (quote shen.linearise_X))
(begin (register-function-arity (quote shen.aritycheck) 2) (define (kl:shen.aritycheck V249 V250) (cond ((and (pair? V250) (and (pair? (car V250)) (and (pair? (cdr (car V250))) (and (null? (cdr (cdr (car V250)))) (null? (cdr V250)))))) (begin (kl:shen.aritycheck-action (car (cdr (car V250)))) (kl:shen.aritycheck-name V249 (kl:arity V249) (kl:length (car (car V250)))))) ((and (pair? V250) (and (pair? (car V250)) (and (pair? (cdr (car V250))) (and (null? (cdr (cdr (car V250)))) (and (pair? (cdr V250)) (and (pair? (car (cdr V250))) (and (pair? (cdr (car (cdr V250)))) (null? (cdr (cdr (car (cdr V250)))))))))))) (if (kl:= (kl:length (car (car V250))) (kl:length (car (car (cdr V250))))) (begin (kl:shen.aritycheck-action (car (cdr (car V250)))) (kl:shen.aritycheck V249 (cdr V250))) (simple-error (string-append "arity error in " (kl:shen.app V249 "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.aritycheck))))) (export shen.aritycheck) (quote shen.aritycheck))
(begin (register-function-arity (quote shen.aritycheck-name) 3) (define (kl:shen.aritycheck-name V263 V264 V265) (cond ((kl:= -1 V264) V265) ((kl:= V265 V264) V265) (#t (begin (kl:shen.prhush (string-append "\nwarning: changing the arity of " (kl:shen.app V263 " can cause errors.\n" (quote shen.a))) (kl:stoutput)) V265)))) (export shen.aritycheck-name) (quote shen.aritycheck-name))
(begin (register-function-arity (quote shen.aritycheck-action) 1) (define (kl:shen.aritycheck-action V271) (cond ((pair? V271) (begin (kl:shen.aah (car V271) (cdr V271)) (kl:shen.for-each (lambda (Y) (kl:shen.aritycheck-action Y)) V271))) (#t (quote shen.skip)))) (export shen.aritycheck-action) (quote shen.aritycheck-action))
(begin (register-function-arity (quote shen.aah) 2) (define (kl:shen.aah V274 V275) (let ((Arity (kl:arity V274))) (let ((Len (kl:length V275))) (if (and (> Arity -1) (> Len Arity)) (kl:shen.prhush (string-append "warning: " (kl:shen.app V274 (string-append " might not like " (kl:shen.app Len (string-append " argument" (kl:shen.app (if (> Len 1) "s" "") ".\n" (quote shen.a))) (quote shen.a))) (quote shen.a))) (kl:stoutput)) (quote shen.skip))))) (export shen.aah) (quote shen.aah))
(begin (register-function-arity (quote shen.abstract_rule) 1) (define (kl:shen.abstract_rule V277) (cond ((and (pair? V277) (and (pair? (cdr V277)) (null? (cdr (cdr V277))))) (kl:shen.abstraction_build (car V277) (car (cdr V277)))) (#t (kl:shen.f_error (quote shen.abstract_rule))))) (export shen.abstract_rule) (quote shen.abstract_rule))
(begin (register-function-arity (quote shen.abstraction_build) 2) (define (kl:shen.abstraction_build V280 V281) (cond ((null? V280) V281) ((pair? V280) (cons (quote /.) (cons (car V280) (cons (kl:shen.abstraction_build (cdr V280) V281) (quote ()))))) (#t (kl:shen.f_error (quote shen.abstraction_build))))) (export shen.abstraction_build) (quote shen.abstraction_build))
(begin (register-function-arity (quote shen.parameters) 1) (define (kl:shen.parameters V283) (cond ((kl:= 0 V283) (quote ())) (#t (cons (kl:gensym (quote V)) (kl:shen.parameters (- V283 1)))))) (export shen.parameters) (quote shen.parameters))
(begin (register-function-arity (quote shen.application_build) 2) (define (kl:shen.application_build V286 V287) (cond ((null? V286) V287) ((pair? V286) (kl:shen.application_build (cdr V286) (cons V287 (cons (car V286) (quote ()))))) (#t (kl:shen.f_error (quote shen.application_build))))) (export shen.application_build) (quote shen.application_build))
(begin (register-function-arity (quote shen.compile_to_kl) 2) (define (kl:shen.compile_to_kl V290 V291) (cond ((and (pair? V291) (and (pair? (cdr V291)) (null? (cdr (cdr V291))))) (let ((Arity (kl:shen.store-arity V290 (kl:length (car V291))))) (let ((Reduce (kl:map (lambda (X) (kl:shen.reduce X)) (car (cdr V291))))) (let ((CondExpression (kl:shen.cond-expression V290 (car V291) Reduce))) (let ((TypeTable (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.typextable (kl:shen.get-type V290) (car V291)) (quote shen.skip)))) (let ((TypedCondExpression (if (assert-boolean (kl:value (quote shen.*optimise*))) (kl:shen.assign-types (car V291) TypeTable CondExpression) CondExpression))) (cons (quote defun) (cons V290 (cons (car V291) (cons TypedCondExpression (quote ()))))))))))) (#t (kl:shen.f_error (quote shen.compile_to_kl))))) (export shen.compile_to_kl) (quote shen.compile_to_kl))
(begin (register-function-arity (quote shen.get-type) 1) (define (kl:shen.get-type V297) (cond ((pair? V297) (quote shen.skip)) (#t (let ((FType (kl:assoc V297 (kl:value (quote shen.*signedfuncs*))))) (if (kl:empty? FType) (quote shen.skip) (cdr FType)))))) (export shen.get-type) (quote shen.get-type))
(begin (register-function-arity (quote shen.typextable) 2) (define (kl:shen.typextable V308 V309) (cond ((and (pair? V308) (and (pair? (cdr V308)) (and (eq? (quote -->) (car (cdr V308))) (and (pair? (cdr (cdr V308))) (and (null? (cdr (cdr (cdr V308)))) (pair? V309)))))) (if (kl:variable? (car V308)) (kl:shen.typextable (car (cdr (cdr V308))) (cdr V309)) (cons (cons (car V309) (car V308)) (kl:shen.typextable (car (cdr (cdr V308))) (cdr V309))))) (#t (quote ())))) (export shen.typextable) (quote shen.typextable))
(begin (register-function-arity (quote shen.assign-types) 3) (define (kl:shen.assign-types V313 V314 V315) (cond ((and (pair? V315) (and (eq? (quote let) (car V315)) (and (pair? (cdr V315)) (and (pair? (cdr (cdr V315))) (and (pair? (cdr (cdr (cdr V315)))) (null? (cdr (cdr (cdr (cdr V315)))))))))) (cons (quote let) (cons (car (cdr V315)) (cons (kl:shen.assign-types V313 V314 (car (cdr (cdr V315)))) (cons (kl:shen.assign-types (cons (car (cdr V315)) V313) V314 (car (cdr (cdr (cdr V315))))) (quote ())))))) ((and (pair? V315) (and (eq? (quote lambda) (car V315)) (and (pair? (cdr V315)) (and (pair? (cdr (cdr V315))) (null? (cdr (cdr (cdr V315)))))))) (cons (quote lambda) (cons (car (cdr V315)) (cons (kl:shen.assign-types (cons (car (cdr V315)) V313) V314 (car (cdr (cdr V315)))) (quote ()))))) ((and (pair? V315) (eq? (quote cond) (car V315))) (cons (quote cond) (kl:map (lambda (Y) (cons (kl:shen.assign-types V313 V314 (car Y)) (cons (kl:shen.assign-types V313 V314 (car (cdr Y))) (quote ())))) (cdr V315)))) ((pair? V315) (let ((NewTable (kl:shen.typextable (kl:shen.get-type (car V315)) (cdr V315)))) (cons (car V315) (kl:map (lambda (Y) (kl:shen.assign-types V313 (kl:append V314 NewTable) Y)) (cdr V315))))) (#t (let ((AtomType (kl:assoc V315 V314))) (if (pair? AtomType) (cons (quote type) (cons V315 (cons (cdr AtomType) (quote ())))) (if (kl:element? V315 V313) V315 (kl:shen.atom-type V315))))))) (export shen.assign-types) (quote shen.assign-types))
(begin (register-function-arity (quote shen.atom-type) 1) (define (kl:shen.atom-type V317) (if (string? V317) (cons (quote type) (cons V317 (cons (quote string) (quote ())))) (if (number? V317) (cons (quote type) (cons V317 (cons (quote number) (quote ())))) (if (kl:boolean? V317) (cons (quote type) (cons V317 (cons (quote boolean) (quote ())))) (if (kl:symbol? V317) (cons (quote type) (cons V317 (cons (quote symbol) (quote ())))) V317))))) (export shen.atom-type) (quote shen.atom-type))
(begin (register-function-arity (quote shen.store-arity) 2) (define (kl:shen.store-arity V322 V323) (cond ((assert-boolean (kl:value (quote shen.*installing-kl*))) (quote shen.skip)) (#t (kl:put V322 (quote arity) V323 (kl:value (quote *property-vector*)))))) (export shen.store-arity) (quote shen.store-arity))
(begin (register-function-arity (quote shen.reduce) 1) (define (kl:shen.reduce V325) (begin (kl:set (quote shen.*teststack*) (quote ())) (let ((Result (kl:shen.reduce_help V325))) (cons (cons (quote :) (cons (quote shen.tests) (kl:reverse (kl:value (quote shen.*teststack*))))) (cons Result (quote ())))))) (export shen.reduce) (quote shen.reduce))
(begin (register-function-arity (quote shen.reduce_help) 1) (define (kl:shen.reduce_help V327) (cond ((and (pair? V327) (and (pair? (car V327)) (and (eq? (quote /.) (car (car V327))) (and (pair? (cdr (car V327))) (and (pair? (car (cdr (car V327)))) (and (eq? (quote cons) (car (car (cdr (car V327))))) (and (pair? (cdr (car (cdr (car V327))))) (and (pair? (cdr (cdr (car (cdr (car V327)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V327))))))) (and (pair? (cdr (cdr (car V327)))) (and (null? (cdr (cdr (cdr (car V327))))) (and (pair? (cdr V327)) (null? (cdr (cdr V327))))))))))))))) (begin (kl:shen.add_test (cons (quote cons?) (cdr V327))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V327))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V327)))))) (cons (kl:shen.ebr (car (cdr V327)) (car (cdr (car V327))) (car (cdr (cdr (car V327))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hd) (cdr V327)) (quote ()))) (cons (cons (quote tl) (cdr V327)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V327) (and (pair? (car V327)) (and (eq? (quote /.) (car (car V327))) (and (pair? (cdr (car V327))) (and (pair? (car (cdr (car V327)))) (and (eq? (quote _waspvm_at_p) (car (car (cdr (car V327))))) (and (pair? (cdr (car (cdr (car V327))))) (and (pair? (cdr (cdr (car (cdr (car V327)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V327))))))) (and (pair? (cdr (cdr (car V327)))) (and (null? (cdr (cdr (cdr (car V327))))) (and (pair? (cdr V327)) (null? (cdr (cdr V327))))))))))))))) (begin (kl:shen.add_test (cons (quote tuple?) (cdr V327))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V327))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V327)))))) (cons (kl:shen.ebr (car (cdr V327)) (car (cdr (car V327))) (car (cdr (cdr (car V327))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote fst) (cdr V327)) (quote ()))) (cons (cons (quote snd) (cdr V327)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V327) (and (pair? (car V327)) (and (eq? (quote /.) (car (car V327))) (and (pair? (cdr (car V327))) (and (pair? (car (cdr (car V327)))) (and (eq? (quote _waspvm_at_v) (car (car (cdr (car V327))))) (and (pair? (cdr (car (cdr (car V327))))) (and (pair? (cdr (cdr (car (cdr (car V327)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V327))))))) (and (pair? (cdr (cdr (car V327)))) (and (null? (cdr (cdr (cdr (car V327))))) (and (pair? (cdr V327)) (null? (cdr (cdr V327))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+vector?) (cdr V327))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V327))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V327)))))) (cons (kl:shen.ebr (car (cdr V327)) (car (cdr (car V327))) (car (cdr (cdr (car V327))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote hdv) (cdr V327)) (quote ()))) (cons (cons (quote tlv) (cdr V327)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V327) (and (pair? (car V327)) (and (eq? (quote /.) (car (car V327))) (and (pair? (cdr (car V327))) (and (pair? (car (cdr (car V327)))) (and (eq? (quote _waspvm_at_s) (car (car (cdr (car V327))))) (and (pair? (cdr (car (cdr (car V327))))) (and (pair? (cdr (cdr (car (cdr (car V327)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V327))))))) (and (pair? (cdr (cdr (car V327)))) (and (null? (cdr (cdr (cdr (car V327))))) (and (pair? (cdr V327)) (null? (cdr (cdr V327))))))))))))))) (begin (kl:shen.add_test (cons (quote shen.+string?) (cdr V327))) (let ((Abstraction (cons (quote /.) (cons (car (cdr (car (cdr (car V327))))) (cons (cons (quote /.) (cons (car (cdr (cdr (car (cdr (car V327)))))) (cons (kl:shen.ebr (car (cdr V327)) (car (cdr (car V327))) (car (cdr (cdr (car V327))))) (quote ())))) (quote ())))))) (let ((Application (cons (cons Abstraction (cons (cons (quote pos) (cons (car (cdr V327)) (cons 0 (quote ())))) (quote ()))) (cons (cons (quote tlstr) (cdr V327)) (quote ()))))) (kl:shen.reduce_help Application))))) ((and (pair? V327) (and (pair? (car V327)) (and (eq? (quote /.) (car (car V327))) (and (pair? (cdr (car V327))) (and (pair? (car (cdr (car V327)))) (and (eq? (quote vector) (car (car (cdr (car V327))))) (and (pair? (cdr (car (cdr (car V327))))) (and (kl:= 0 (car (cdr (car (cdr (car V327)))))) (and (null? (cdr (cdr (car (cdr (car V327)))))) (and (pair? (cdr (cdr (car V327)))) (and (null? (cdr (cdr (cdr (car V327))))) (and (pair? (cdr V327)) (null? (cdr (cdr V327))))))))))))))) (begin (kl:shen.add_test (cons (quote vector?) (cdr V327))) (begin (kl:shen.add_test (cons (quote =) (cons 0 (cons (cons (quote limit) (cdr V327)) (quote ()))))) (kl:shen.reduce_help (kl:shen.ebr (car (cdr V327)) (car (cdr (car V327))) (car (cdr (cdr (car V327))))))))) ((and (pair? V327) (and (pair? (car V327)) (and (eq? (quote /.) (car (car V327))) (and (pair? (cdr (car V327))) (and (pair? (car (cdr (car V327)))) (and (pair? (cdr (cdr (car V327)))) (and (null? (cdr (cdr (cdr (car V327))))) (and (pair? (cdr V327)) (null? (cdr (cdr V327))))))))))) (kl:shen.custom-pattern-reducer V327)) ((and (pair? V327) (and (pair? (car V327)) (and (eq? (quote /.) (car (car V327))) (and (pair? (cdr (car V327))) (and (pair? (cdr (cdr (car V327)))) (and (null? (cdr (cdr (cdr (car V327))))) (and (pair? (cdr V327)) (and (null? (cdr (cdr V327))) (kl:not (kl:variable? (car (cdr (car V327))))))))))))) (begin (kl:shen.add_test (cons (quote =) (cons (car (cdr (car V327))) (cdr V327)))) (kl:shen.reduce_help (car (cdr (cdr (car V327))))))) ((and (pair? V327) (and (pair? (car V327)) (and (eq? (quote /.) (car (car V327))) (and (pair? (cdr (car V327))) (and (pair? (cdr (cdr (car V327)))) (and (null? (cdr (cdr (cdr (car V327))))) (and (pair? (cdr V327)) (null? (cdr (cdr V327)))))))))) (kl:shen.reduce_help (kl:shen.ebr (car (cdr V327)) (car (cdr (car V327))) (car (cdr (cdr (car V327))))))) ((and (pair? V327) (and (eq? (quote where) (car V327)) (and (pair? (cdr V327)) (and (pair? (cdr (cdr V327))) (null? (cdr (cdr (cdr V327)))))))) (begin (kl:shen.add_test (car (cdr V327))) (kl:shen.reduce_help (car (cdr (cdr V327)))))) ((and (pair? V327) (and (pair? (cdr V327)) (null? (cdr (cdr V327))))) (let ((Z (kl:shen.reduce_help (car V327)))) (if (kl:= (car V327) Z) V327 (kl:shen.reduce_help (cons Z (cdr V327)))))) (#t V327))) (export shen.reduce_help) (quote shen.reduce_help))
(begin (register-function-arity (quote shen.+string?) 1) (define (kl:shen.+string? V329) (cond ((equal? "" V329) #f) (#t (string? V329)))) (export shen.+string?) (quote shen.+string?))
(begin (register-function-arity (quote shen.+vector?) 1) (define (kl:shen.+vector? V331) (and (vector? V331) (> (vector-ref V331 0) 0))) (export shen.+vector?) (quote shen.+vector?))
(begin (register-function-arity (quote shen.ebr) 3) (define (kl:shen.ebr V344 V345 V346) (cond ((kl:= V346 V345) V344) ((and (pair? V346) (and (eq? (quote lambda) (car V346)) (and (pair? (cdr V346)) (and (pair? (cdr (cdr V346))) (and (null? (cdr (cdr (cdr V346)))) (assert-boolean (kl:shen.clash? (car (cdr V346)) V345))))))) V346) ((and (pair? V346) (and (eq? (quote let) (car V346)) (and (pair? (cdr V346)) (and (pair? (cdr (cdr V346))) (and (pair? (cdr (cdr (cdr V346)))) (and (null? (cdr (cdr (cdr (cdr V346))))) (assert-boolean (kl:shen.clash? (car (cdr V346)) V345)))))))) (cons (quote let) (cons (car (cdr V346)) (cons (kl:shen.ebr V344 V345 (car (cdr (cdr V346)))) (cdr (cdr (cdr V346))))))) ((pair? V346) (cons (kl:shen.ebr V344 V345 (car V346)) (kl:shen.ebr V344 V345 (cdr V346)))) (#t V346))) (export shen.ebr) (quote shen.ebr))
(begin (register-function-arity (quote shen.clash?) 2) (define (kl:shen.clash? V358 V359) (cond ((kl:= V359 V358) #t) ((pair? V359) (or (assert-boolean (kl:shen.clash? V358 (car V359))) (assert-boolean (kl:shen.clash? V358 (cdr V359))))) (#t #f))) (export shen.clash?) (quote shen.clash?))
(begin (register-function-arity (quote shen.add_test) 1) (define (kl:shen.add_test V361) (kl:set (quote shen.*teststack*) (cons V361 (kl:value (quote shen.*teststack*))))) (export shen.add_test) (quote shen.add_test))
(begin (register-function-arity (quote shen.cond-expression) 3) (define (kl:shen.cond-expression V365 V366 V367) (let ((Err (kl:shen.err-condition V365))) (let ((Cases (kl:shen.case-form V367 Err))) (let ((EncodeChoices (kl:shen.encode-choices Cases V365))) (kl:shen.cond-form EncodeChoices))))) (export shen.cond-expression) (quote shen.cond-expression))
(begin (register-function-arity (quote shen.cond-form) 1) (define (kl:shen.cond-form V371) (cond ((and (pair? V371) (and (pair? (car V371)) (and (kl:= #t (car (car V371))) (and (pair? (cdr (car V371))) (null? (cdr (cdr (car V371)))))))) (car (cdr (car V371)))) (#t (cons (quote cond) V371)))) (export shen.cond-form) (quote shen.cond-form))
(begin (register-function-arity (quote shen.encode-choices) 2) (define (kl:shen.encode-choices V376 V377) (cond ((null? V376) (quote ())) ((and (pair? V376) (and (pair? (car V376)) (and (kl:= #t (car (car V376))) (and (pair? (cdr (car V376))) (and (pair? (car (cdr (car V376)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V376))))) (and (pair? (cdr (car (cdr (car V376))))) (and (null? (cdr (cdr (car (cdr (car V376)))))) (and (null? (cdr (cdr (car V376)))) (null? (cdr V376))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V376))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (if (assert-boolean (kl:value (quote shen.*installing-kl*))) (cons (quote shen.sys-error) (cons V377 (quote ()))) (cons (quote shen.f_error) (cons V377 (quote ())))) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V376) (and (pair? (car V376)) (and (kl:= #t (car (car V376))) (and (pair? (cdr (car V376))) (and (pair? (car (cdr (car V376)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V376))))) (and (pair? (cdr (car (cdr (car V376))))) (and (null? (cdr (cdr (car (cdr (car V376)))))) (null? (cdr (cdr (car V376)))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V376))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V376) V377)) (cons (quote Result) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V376) (and (pair? (car V376)) (and (pair? (cdr (car V376))) (and (pair? (car (cdr (car V376)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V376))))) (and (pair? (cdr (car (cdr (car V376))))) (and (null? (cdr (cdr (car (cdr (car V376)))))) (null? (cdr (cdr (car V376))))))))))) (cons (cons #t (cons (cons (quote let) (cons (quote Freeze) (cons (cons (quote freeze) (cons (kl:shen.cond-form (kl:shen.encode-choices (cdr V376) V377)) (quote ()))) (cons (cons (quote if) (cons (car (car V376)) (cons (cons (quote let) (cons (quote Result) (cons (car (cdr (car (cdr (car V376))))) (cons (cons (quote if) (cons (cons (quote =) (cons (quote Result) (cons (cons (quote fail) (quote ())) (quote ())))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (cons (quote Result) (quote ()))))) (quote ()))))) (cons (cons (quote thaw) (cons (quote Freeze) (quote ()))) (quote ()))))) (quote ()))))) (quote ()))) (quote ()))) ((and (pair? V376) (and (pair? (car V376)) (and (pair? (cdr (car V376))) (null? (cdr (cdr (car V376))))))) (cons (car V376) (kl:shen.encode-choices (cdr V376) V377))) (#t (kl:shen.f_error (quote shen.encode-choices))))) (export shen.encode-choices) (quote shen.encode-choices))
(begin (register-function-arity (quote shen.case-form) 2) (define (kl:shen.case-form V384 V385) (cond ((null? V384) (cons V385 (quote ()))) ((and (pair? V384) (and (pair? (car V384)) (and (pair? (car (car V384))) (and (eq? (quote :) (car (car (car V384)))) (and (pair? (cdr (car (car V384)))) (and (eq? (quote shen.tests) (car (cdr (car (car V384))))) (and (null? (cdr (cdr (car (car V384))))) (and (pair? (cdr (car V384))) (and (pair? (car (cdr (car V384)))) (and (eq? (quote shen.choicepoint!) (car (car (cdr (car V384))))) (and (pair? (cdr (car (cdr (car V384))))) (and (null? (cdr (cdr (car (cdr (car V384)))))) (null? (cdr (cdr (car V384)))))))))))))))) (cons (cons #t (cdr (car V384))) (kl:shen.case-form (cdr V384) V385))) ((and (pair? V384) (and (pair? (car V384)) (and (pair? (car (car V384))) (and (eq? (quote :) (car (car (car V384)))) (and (pair? (cdr (car (car V384)))) (and (eq? (quote shen.tests) (car (cdr (car (car V384))))) (and (null? (cdr (cdr (car (car V384))))) (and (pair? (cdr (car V384))) (null? (cdr (cdr (car V384)))))))))))) (cons (cons #t (cdr (car V384))) (quote ()))) ((and (pair? V384) (and (pair? (car V384)) (and (pair? (car (car V384))) (and (eq? (quote :) (car (car (car V384)))) (and (pair? (cdr (car (car V384)))) (and (eq? (quote shen.tests) (car (cdr (car (car V384))))) (and (pair? (cdr (car V384))) (null? (cdr (cdr (car V384))))))))))) (cons (cons (kl:shen.embed-and (cdr (cdr (car (car V384))))) (cdr (car V384))) (kl:shen.case-form (cdr V384) V385))) (#t (kl:shen.f_error (quote shen.case-form))))) (export shen.case-form) (quote shen.case-form))
(begin (register-function-arity (quote shen.embed-and) 1) (define (kl:shen.embed-and V387) (cond ((and (pair? V387) (null? (cdr V387))) (car V387)) ((pair? V387) (cons (quote and) (cons (car V387) (cons (kl:shen.embed-and (cdr V387)) (quote ()))))) (#t (kl:shen.f_error (quote shen.embed-and))))) (export shen.embed-and) (quote shen.embed-and))
(begin (register-function-arity (quote shen.err-condition) 1) (define (kl:shen.err-condition V389) (cons #t (cons (cons (quote shen.f_error) (cons V389 (quote ()))) (quote ())))) (export shen.err-condition) (quote shen.err-condition))
(begin (register-function-arity (quote shen.sys-error) 1) (define (kl:shen.sys-error V391) (simple-error (string-append "system function " (kl:shen.app V391 ": unexpected argument\n" (quote shen.a))))) (export shen.sys-error) (quote shen.sys-error))

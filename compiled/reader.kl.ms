(module "compiled/reader.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.read-char-code) 1) (define (kl:shen.read-char-code V1372) (read-u8 V1372)) (export shen.read-char-code) (quote shen.read-char-code))
(begin (register-function-arity (quote read-file-as-bytelist) 1) (define (kl:read-file-as-bytelist V1374) (kl:shen.read-file-as-Xlist V1374 (lambda (S) (read-u8 S)))) (export read-file-as-bytelist) (quote read-file-as-bytelist))
(begin (register-function-arity (quote shen.read-file-as-charlist) 1) (define (kl:shen.read-file-as-charlist V1376) (kl:shen.read-file-as-Xlist V1376 (lambda (S) (kl:shen.read-char-code S)))) (export shen.read-file-as-charlist) (quote shen.read-file-as-charlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist) 2) (define (kl:shen.read-file-as-Xlist V1379 V1380) (let ((Stream (kl:open V1379 (quote in)))) (let ((X (V1380 Stream))) (let ((Xs (kl:shen.read-file-as-Xlist-help Stream V1380 X (quote ())))) (let ((Close (kl:close Stream))) (kl:reverse Xs)))))) (export shen.read-file-as-Xlist) (quote shen.read-file-as-Xlist))
(begin (register-function-arity (quote shen.read-file-as-Xlist-help) 4) (define (kl:shen.read-file-as-Xlist-help V1385 V1386 V1387 V1388) (cond ((kl:= -1 V1387) V1388) (#t (kl:shen.read-file-as-Xlist-help V1385 V1386 (V1386 V1385) (cons V1387 V1388))))) (export shen.read-file-as-Xlist-help) (quote shen.read-file-as-Xlist-help))
(begin (register-function-arity (quote read-file-as-string) 1) (define (kl:read-file-as-string V1390) (let ((Stream (kl:open V1390 (quote in)))) (kl:shen.rfas-h Stream (kl:shen.read-char-code Stream) ""))) (export read-file-as-string) (quote read-file-as-string))
(begin (register-function-arity (quote shen.rfas-h) 3) (define (kl:shen.rfas-h V1394 V1395 V1396) (cond ((kl:= -1 V1395) (begin (kl:close V1394) V1396)) (#t (kl:shen.rfas-h V1394 (kl:shen.read-char-code V1394) (string-append V1396 (make-string 1 V1395)))))) (export shen.rfas-h) (quote shen.rfas-h))
(begin (register-function-arity (quote input) 1) (define (kl:input V1398) (kl:eval-kl (kl:read V1398))) (export input) (quote input))
(begin (register-function-arity (quote input+) 2) (define (kl:input+ V1401 V1402) (let ((Mono? (kl:shen.monotype V1401))) (let ((Input (kl:read V1402))) (if (kl:= #f (kl:shen.typecheck Input (kl:shen.demodulate V1401))) (simple-error (string-append "type error: " (kl:shen.app Input (string-append " is not of type " (kl:shen.app V1401 "\n" (quote shen.r))) (quote shen.r)))) (kl:eval-kl Input))))) (export input+) (quote input+))
(begin (register-function-arity (quote shen.monotype) 1) (define (kl:shen.monotype V1404) (cond ((pair? V1404) (kl:map (lambda (Z) (kl:shen.monotype Z)) V1404)) (#t (if (kl:variable? V1404) (simple-error (string-append "input+ expects a monotype: not " (kl:shen.app V1404 "\n" (quote shen.a)))) V1404)))) (export shen.monotype) (quote shen.monotype))
(begin (register-function-arity (quote read) 1) (define (kl:read V1406) (car (kl:shen.read-loop V1406 (kl:shen.read-char-code V1406) (quote ())))) (export read) (quote read))
(begin (register-function-arity (quote it) 0) (define (kl:it) (kl:value (quote shen.*it*))) (export it) (quote it))
(begin (register-function-arity (quote shen.read-loop) 3) (define (kl:shen.read-loop V1414 V1415 V1416) (cond ((kl:= 94 V1415) (simple-error "read aborted")) ((kl:= -1 V1415) (if (kl:empty? V1416) (simple-error "error: empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V1416 (lambda (E) E)))) ((assert-boolean (kl:shen.terminator? V1415)) (let ((AllChars (kl:append V1416 (cons V1415 (quote ()))))) (let ((It (kl:shen.record-it AllChars))) (let ((Read (kl:compile (lambda (X) (kl:shen.<st_input> X)) AllChars (lambda (E) (quote shen.nextbyte))))) (if (or (eq? Read (quote shen.nextbyte)) (kl:empty? Read)) (kl:shen.read-loop V1414 (kl:shen.read-char-code V1414) AllChars) Read))))) (#t (kl:shen.read-loop V1414 (kl:shen.read-char-code V1414) (kl:append V1416 (cons V1415 (quote ()))))))) (export shen.read-loop) (quote shen.read-loop))
(begin (register-function-arity (quote shen.terminator?) 1) (define (kl:shen.terminator? V1418) (kl:element? V1418 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 (quote ())))))))))) (export shen.terminator?) (quote shen.terminator?))
(begin (register-function-arity (quote lineread) 1) (define (kl:lineread V1420) (kl:shen.lineread-loop (kl:shen.read-char-code V1420) (quote ()) V1420)) (export lineread) (quote lineread))
(begin (register-function-arity (quote shen.lineread-loop) 3) (define (kl:shen.lineread-loop V1425 V1426 V1427) (cond ((kl:= -1 V1425) (if (kl:empty? V1426) (simple-error "empty stream") (kl:compile (lambda (X) (kl:shen.<st_input> X)) V1426 (lambda (E) E)))) ((kl:= V1425 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V1425 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V1426 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V1426))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.lineread-loop (kl:shen.read-char-code V1427) (kl:append V1426 (cons V1425 (quote ()))) V1427) Line)))) (#t (kl:shen.lineread-loop (kl:shen.read-char-code V1427) (kl:append V1426 (cons V1425 (quote ()))) V1427)))) (export shen.lineread-loop) (quote shen.lineread-loop))
(begin (register-function-arity (quote shen.record-it) 1) (define (kl:shen.record-it V1429) (let ((TrimLeft (kl:shen.trim-whitespace V1429))) (let ((TrimRight (kl:shen.trim-whitespace (kl:reverse TrimLeft)))) (let ((Trimmed (kl:reverse TrimRight))) (kl:shen.record-it-h Trimmed))))) (export shen.record-it) (quote shen.record-it))
(begin (register-function-arity (quote shen.trim-whitespace) 1) (define (kl:shen.trim-whitespace V1431) (cond ((and (pair? V1431) (kl:element? (car V1431) (cons 9 (cons 10 (cons 13 (cons 32 (quote ()))))))) (kl:shen.trim-whitespace (cdr V1431))) (#t V1431))) (export shen.trim-whitespace) (quote shen.trim-whitespace))
(begin (register-function-arity (quote shen.record-it-h) 1) (define (kl:shen.record-it-h V1433) (begin (kl:set (quote shen.*it*) (kl:shen.cn-all (kl:map (lambda (X) (make-string 1 X)) V1433))) V1433)) (export shen.record-it-h) (quote shen.record-it-h))
(begin (register-function-arity (quote shen.cn-all) 1) (define (kl:shen.cn-all V1435) (cond ((null? V1435) "") ((pair? V1435) (string-append (car V1435) (kl:shen.cn-all (cdr V1435)))) (#t (kl:shen.f_error (quote shen.cn-all))))) (export shen.cn-all) (quote shen.cn-all))
(begin (register-function-arity (quote read-file) 1) (define (kl:read-file V1437) (let ((Charlist (kl:shen.read-file-as-charlist V1437))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Charlist (lambda (X) (kl:shen.read-error X))))) (export read-file) (quote read-file))
(begin (register-function-arity (quote read-from-string) 1) (define (kl:read-from-string V1439) (let ((Ns (kl:map (lambda (X) (string-ref X 0)) (kl:explode V1439)))) (kl:compile (lambda (X) (kl:shen.<st_input> X)) Ns (lambda (X) (kl:shen.read-error X))))) (export read-from-string) (quote read-from-string))
(begin (register-function-arity (quote shen.read-error) 1) (define (kl:shen.read-error V1447) (cond ((and (pair? V1447) (and (pair? (car V1447)) (and (pair? (cdr V1447)) (null? (cdr (cdr V1447)))))) (simple-error (string-append "read error here:\n\n " (kl:shen.app (kl:shen.compress-50 50 (car V1447)) "\n" (quote shen.a))))) (#t (simple-error "read error\n")))) (export shen.read-error) (quote shen.read-error))
(begin (register-function-arity (quote shen.compress-50) 2) (define (kl:shen.compress-50 V1454 V1455) (cond ((null? V1455) "") ((kl:= 0 V1454) "") ((pair? V1455) (string-append (make-string 1 (car V1455)) (kl:shen.compress-50 (- V1454 1) (cdr V1455)))) (#t (kl:shen.f_error (quote shen.compress-50))))) (export shen.compress-50) (quote shen.compress-50))
(begin (register-function-arity (quote shen.<st_input>) 1) (define (kl:shen.<st_input> V1457) (let ((YaccParse (let ((Parse_shen.<lsb> (kl:shen.<lsb> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lsb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rsb> (kl:shen.<rsb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rsb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rsb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (cons (kl:macroexpand (kl:shen.cons_form (kl:shen.hdtl Parse_shen.<st_input1>))) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lrb> (kl:shen.<lrb> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lrb>)) (let ((Parse_shen.<st_input1> (kl:shen.<st_input1> Parse_shen.<lrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input1>)) (let ((Parse_shen.<rrb> (kl:shen.<rrb> Parse_shen.<st_input1>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rrb>)) (let ((Parse_shen.<st_input2> (kl:shen.<st_input2> Parse_shen.<rrb>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input2>)) (kl:shen.pair (car Parse_shen.<st_input2>) (kl:shen.package-macro (kl:macroexpand (kl:shen.hdtl Parse_shen.<st_input1>)) (kl:shen.hdtl Parse_shen.<st_input2>))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<lcurly> (kl:shen.<lcurly> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<lcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<lcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote {) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<rcurly> (kl:shen.<rcurly> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rcurly>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<rcurly>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote }) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<bar> (kl:shen.<bar> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<bar>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<bar>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote bar!) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<semicolon> (kl:shen.<semicolon> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<semicolon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<semicolon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote _waspvm_sc_) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<equal> (kl:shen.<equal> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<equal>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<equal>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :=) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<minus> (kl:shen.<minus> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :-) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<colon> (kl:shen.<colon> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<colon>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<colon>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (quote :) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comma> (kl:shen.<comma> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comma>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comma>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:intern ",") (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<atom> (kl:shen.<atom> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<atom>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<atom>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (cons (kl:macroexpand (kl:shen.hdtl Parse_shen.<atom>)) (kl:shen.hdtl Parse_shen.<st_input>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> V1457))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (let ((Parse_shen.<st_input> (kl:shen.<st_input> Parse_shen.<whitespaces>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1457))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (export shen.<st_input>) (quote shen.<st_input>))
(begin (register-function-arity (quote shen.<lsb>) 1) (define (kl:shen.<lsb> V1460) (if (and (pair? (car V1460)) (kl:= 91 (kl:shen.hdhd V1460))) (let ((NewStream1458 (kl:shen.pair (kl:shen.tlhd V1460) (kl:shen.hdtl V1460)))) (kl:shen.pair (car NewStream1458) (quote shen.skip))) (kl:fail))) (export shen.<lsb>) (quote shen.<lsb>))
(begin (register-function-arity (quote shen.<rsb>) 1) (define (kl:shen.<rsb> V1463) (if (and (pair? (car V1463)) (kl:= 93 (kl:shen.hdhd V1463))) (let ((NewStream1461 (kl:shen.pair (kl:shen.tlhd V1463) (kl:shen.hdtl V1463)))) (kl:shen.pair (car NewStream1461) (quote shen.skip))) (kl:fail))) (export shen.<rsb>) (quote shen.<rsb>))
(begin (register-function-arity (quote shen.<lcurly>) 1) (define (kl:shen.<lcurly> V1466) (if (and (pair? (car V1466)) (kl:= 123 (kl:shen.hdhd V1466))) (let ((NewStream1464 (kl:shen.pair (kl:shen.tlhd V1466) (kl:shen.hdtl V1466)))) (kl:shen.pair (car NewStream1464) (quote shen.skip))) (kl:fail))) (export shen.<lcurly>) (quote shen.<lcurly>))
(begin (register-function-arity (quote shen.<rcurly>) 1) (define (kl:shen.<rcurly> V1469) (if (and (pair? (car V1469)) (kl:= 125 (kl:shen.hdhd V1469))) (let ((NewStream1467 (kl:shen.pair (kl:shen.tlhd V1469) (kl:shen.hdtl V1469)))) (kl:shen.pair (car NewStream1467) (quote shen.skip))) (kl:fail))) (export shen.<rcurly>) (quote shen.<rcurly>))
(begin (register-function-arity (quote shen.<bar>) 1) (define (kl:shen.<bar> V1472) (if (and (pair? (car V1472)) (kl:= 124 (kl:shen.hdhd V1472))) (let ((NewStream1470 (kl:shen.pair (kl:shen.tlhd V1472) (kl:shen.hdtl V1472)))) (kl:shen.pair (car NewStream1470) (quote shen.skip))) (kl:fail))) (export shen.<bar>) (quote shen.<bar>))
(begin (register-function-arity (quote shen.<semicolon>) 1) (define (kl:shen.<semicolon> V1475) (if (and (pair? (car V1475)) (kl:= 59 (kl:shen.hdhd V1475))) (let ((NewStream1473 (kl:shen.pair (kl:shen.tlhd V1475) (kl:shen.hdtl V1475)))) (kl:shen.pair (car NewStream1473) (quote shen.skip))) (kl:fail))) (export shen.<semicolon>) (quote shen.<semicolon>))
(begin (register-function-arity (quote shen.<colon>) 1) (define (kl:shen.<colon> V1478) (if (and (pair? (car V1478)) (kl:= 58 (kl:shen.hdhd V1478))) (let ((NewStream1476 (kl:shen.pair (kl:shen.tlhd V1478) (kl:shen.hdtl V1478)))) (kl:shen.pair (car NewStream1476) (quote shen.skip))) (kl:fail))) (export shen.<colon>) (quote shen.<colon>))
(begin (register-function-arity (quote shen.<comma>) 1) (define (kl:shen.<comma> V1481) (if (and (pair? (car V1481)) (kl:= 44 (kl:shen.hdhd V1481))) (let ((NewStream1479 (kl:shen.pair (kl:shen.tlhd V1481) (kl:shen.hdtl V1481)))) (kl:shen.pair (car NewStream1479) (quote shen.skip))) (kl:fail))) (export shen.<comma>) (quote shen.<comma>))
(begin (register-function-arity (quote shen.<equal>) 1) (define (kl:shen.<equal> V1484) (if (and (pair? (car V1484)) (kl:= 61 (kl:shen.hdhd V1484))) (let ((NewStream1482 (kl:shen.pair (kl:shen.tlhd V1484) (kl:shen.hdtl V1484)))) (kl:shen.pair (car NewStream1482) (quote shen.skip))) (kl:fail))) (export shen.<equal>) (quote shen.<equal>))
(begin (register-function-arity (quote shen.<minus>) 1) (define (kl:shen.<minus> V1487) (if (and (pair? (car V1487)) (kl:= 45 (kl:shen.hdhd V1487))) (let ((NewStream1485 (kl:shen.pair (kl:shen.tlhd V1487) (kl:shen.hdtl V1487)))) (kl:shen.pair (car NewStream1485) (quote shen.skip))) (kl:fail))) (export shen.<minus>) (quote shen.<minus>))
(begin (register-function-arity (quote shen.<lrb>) 1) (define (kl:shen.<lrb> V1490) (if (and (pair? (car V1490)) (kl:= 40 (kl:shen.hdhd V1490))) (let ((NewStream1488 (kl:shen.pair (kl:shen.tlhd V1490) (kl:shen.hdtl V1490)))) (kl:shen.pair (car NewStream1488) (quote shen.skip))) (kl:fail))) (export shen.<lrb>) (quote shen.<lrb>))
(begin (register-function-arity (quote shen.<rrb>) 1) (define (kl:shen.<rrb> V1493) (if (and (pair? (car V1493)) (kl:= 41 (kl:shen.hdhd V1493))) (let ((NewStream1491 (kl:shen.pair (kl:shen.tlhd V1493) (kl:shen.hdtl V1493)))) (kl:shen.pair (car NewStream1491) (quote shen.skip))) (kl:fail))) (export shen.<rrb>) (quote shen.<rrb>))
(begin (register-function-arity (quote shen.<atom>) 1) (define (kl:shen.<atom> V1495) (let ((YaccParse (let ((Parse_shen.<str> (kl:shen.<str> V1495))) (if (kl:not (kl:= (kl:fail) Parse_shen.<str>)) (kl:shen.pair (car Parse_shen.<str>) (kl:shen.control-chars (kl:shen.hdtl Parse_shen.<str>))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<number> (kl:shen.<number> V1495))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<sym> (kl:shen.<sym> V1495))) (if (kl:not (kl:= (kl:fail) Parse_shen.<sym>)) (kl:shen.pair (car Parse_shen.<sym>) (if (equal? (kl:shen.hdtl Parse_shen.<sym>) "<>") (cons (quote vector) (cons 0 (quote ()))) (kl:intern (kl:shen.hdtl Parse_shen.<sym>)))) (kl:fail))) YaccParse)) YaccParse))) (export shen.<atom>) (quote shen.<atom>))
(begin (register-function-arity (quote shen.control-chars) 1) (define (kl:shen.control-chars V1497) (cond ((null? V1497) "") ((and (pair? V1497) (and (equal? "c" (car V1497)) (and (pair? (cdr V1497)) (equal? "#" (car (cdr V1497)))))) (let ((CodePoint (kl:shen.code-point (cdr (cdr V1497))))) (let ((AfterCodePoint (kl:shen.after-codepoint (cdr (cdr V1497))))) (kl:_waspvm_at_s (make-string 1 (kl:shen.decimalise CodePoint)) (kl:shen.control-chars AfterCodePoint))))) ((pair? V1497) (kl:_waspvm_at_s (car V1497) (kl:shen.control-chars (cdr V1497)))) (#t (kl:shen.f_error (quote shen.control-chars))))) (export shen.control-chars) (quote shen.control-chars))
(begin (register-function-arity (quote shen.code-point) 1) (define (kl:shen.code-point V1501) (cond ((and (pair? V1501) (equal? ";" (car V1501))) "") ((and (pair? V1501) (kl:element? (car V1501) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" (quote ())))))))))))))) (cons (car V1501) (kl:shen.code-point (cdr V1501)))) (#t (simple-error (string-append "code point parse error " (kl:shen.app V1501 "\n" (quote shen.a))))))) (export shen.code-point) (quote shen.code-point))
(begin (register-function-arity (quote shen.after-codepoint) 1) (define (kl:shen.after-codepoint V1507) (cond ((null? V1507) (quote ())) ((and (pair? V1507) (equal? ";" (car V1507))) (cdr V1507)) ((pair? V1507) (kl:shen.after-codepoint (cdr V1507))) (#t (kl:shen.f_error (quote shen.after-codepoint))))) (export shen.after-codepoint) (quote shen.after-codepoint))
(begin (register-function-arity (quote shen.decimalise) 1) (define (kl:shen.decimalise V1509) (kl:shen.pre (kl:reverse (kl:shen.digits->integers V1509)) 0)) (export shen.decimalise) (quote shen.decimalise))
(begin (register-function-arity (quote shen.digits->integers) 1) (define (kl:shen.digits->integers V1515) (cond ((and (pair? V1515) (equal? "0" (car V1515))) (cons 0 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "1" (car V1515))) (cons 1 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "2" (car V1515))) (cons 2 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "3" (car V1515))) (cons 3 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "4" (car V1515))) (cons 4 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "5" (car V1515))) (cons 5 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "6" (car V1515))) (cons 6 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "7" (car V1515))) (cons 7 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "8" (car V1515))) (cons 8 (kl:shen.digits->integers (cdr V1515)))) ((and (pair? V1515) (equal? "9" (car V1515))) (cons 9 (kl:shen.digits->integers (cdr V1515)))) (#t (quote ())))) (export shen.digits->integers) (quote shen.digits->integers))
(begin (register-function-arity (quote shen.<sym>) 1) (define (kl:shen.<sym> V1517) (let ((Parse_shen.<alpha> (kl:shen.<alpha> V1517))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alpha>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail)))) (export shen.<sym>) (quote shen.<sym>))
(begin (register-function-arity (quote shen.<alphanums>) 1) (define (kl:shen.<alphanums> V1519) (let ((YaccParse (let ((Parse_shen.<alphanum> (kl:shen.<alphanum> V1519))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanum>)) (let ((Parse_shen.<alphanums> (kl:shen.<alphanums> Parse_shen.<alphanum>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alphanums>)) (kl:shen.pair (car Parse_shen.<alphanums>) (kl:_waspvm_at_s (kl:shen.hdtl Parse_shen.<alphanum>) (kl:shen.hdtl Parse_shen.<alphanums>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1519))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) "") (kl:fail))) YaccParse))) (export shen.<alphanums>) (quote shen.<alphanums>))
(begin (register-function-arity (quote shen.<alphanum>) 1) (define (kl:shen.<alphanum> V1521) (let ((YaccParse (let ((Parse_shen.<alpha> (kl:shen.<alpha> V1521))) (if (kl:not (kl:= (kl:fail) Parse_shen.<alpha>)) (kl:shen.pair (car Parse_shen.<alpha>) (kl:shen.hdtl Parse_shen.<alpha>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<num> (kl:shen.<num> V1521))) (if (kl:not (kl:= (kl:fail) Parse_shen.<num>)) (kl:shen.pair (car Parse_shen.<num>) (kl:shen.hdtl Parse_shen.<num>)) (kl:fail))) YaccParse))) (export shen.<alphanum>) (quote shen.<alphanum>))
(begin (register-function-arity (quote shen.<num>) 1) (define (kl:shen.<num> V1523) (if (pair? (car V1523)) (let ((Parse_Char (kl:shen.hdhd V1523))) (if (assert-boolean (kl:shen.numbyte? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1523) (kl:shen.hdtl V1523))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<num>) (quote shen.<num>))
(begin (register-function-arity (quote shen.numbyte?) 1) (define (kl:shen.numbyte? V1529) (cond ((kl:= 48 V1529) #t) ((kl:= 49 V1529) #t) ((kl:= 50 V1529) #t) ((kl:= 51 V1529) #t) ((kl:= 52 V1529) #t) ((kl:= 53 V1529) #t) ((kl:= 54 V1529) #t) ((kl:= 55 V1529) #t) ((kl:= 56 V1529) #t) ((kl:= 57 V1529) #t) (#t #f))) (export shen.numbyte?) (quote shen.numbyte?))
(begin (register-function-arity (quote shen.<alpha>) 1) (define (kl:shen.<alpha> V1531) (if (pair? (car V1531)) (let ((Parse_Char (kl:shen.hdhd V1531))) (if (assert-boolean (kl:shen.symbol-code? Parse_Char)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1531) (kl:shen.hdtl V1531))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<alpha>) (quote shen.<alpha>))
(begin (register-function-arity (quote shen.symbol-code?) 1) (define (kl:shen.symbol-code? V1533) (or (kl:= V1533 126) (or (and (> V1533 94) (< V1533 123)) (or (and (> V1533 59) (< V1533 91)) (or (and (> V1533 41) (and (< V1533 58) (kl:not (kl:= V1533 44)))) (or (and (> V1533 34) (< V1533 40)) (kl:= V1533 33))))))) (export shen.symbol-code?) (quote shen.symbol-code?))
(begin (register-function-arity (quote shen.<str>) 1) (define (kl:shen.<str> V1535) (let ((Parse_shen.<dbq> (kl:shen.<dbq> V1535))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<dbq>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (let ((Parse_shen.<dbq> (kl:shen.<dbq> Parse_shen.<strcontents>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<dbq>)) (kl:shen.pair (car Parse_shen.<dbq>) (kl:shen.hdtl Parse_shen.<strcontents>)) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<str>) (quote shen.<str>))
(begin (register-function-arity (quote shen.<dbq>) 1) (define (kl:shen.<dbq> V1537) (if (pair? (car V1537)) (let ((Parse_Char (kl:shen.hdhd V1537))) (if (kl:= Parse_Char 34) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1537) (kl:shen.hdtl V1537))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<dbq>) (quote shen.<dbq>))
(begin (register-function-arity (quote shen.<strcontents>) 1) (define (kl:shen.<strcontents> V1539) (let ((YaccParse (let ((Parse_shen.<strc> (kl:shen.<strc> V1539))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strc>)) (let ((Parse_shen.<strcontents> (kl:shen.<strcontents> Parse_shen.<strc>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<strcontents>)) (kl:shen.pair (car Parse_shen.<strcontents>) (cons (kl:shen.hdtl Parse_shen.<strc>) (kl:shen.hdtl Parse_shen.<strcontents>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1539))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<strcontents>) (quote shen.<strcontents>))
(begin (register-function-arity (quote shen.<byte>) 1) (define (kl:shen.<byte> V1541) (if (pair? (car V1541)) (let ((Parse_Char (kl:shen.hdhd V1541))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1541) (kl:shen.hdtl V1541))) (make-string 1 Parse_Char))) (kl:fail))) (export shen.<byte>) (quote shen.<byte>))
(begin (register-function-arity (quote shen.<strc>) 1) (define (kl:shen.<strc> V1543) (if (pair? (car V1543)) (let ((Parse_Char (kl:shen.hdhd V1543))) (if (kl:not (kl:= Parse_Char 34)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1543) (kl:shen.hdtl V1543))) (make-string 1 Parse_Char)) (kl:fail))) (kl:fail))) (export shen.<strc>) (quote shen.<strc>))
(begin (register-function-arity (quote shen.<number>) 1) (define (kl:shen.<number> V1545) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V1545))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (- 0 (kl:shen.hdtl Parse_shen.<number>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<plus> (kl:shen.<plus> V1545))) (if (kl:not (kl:= (kl:fail) Parse_shen.<plus>)) (let ((Parse_shen.<number> (kl:shen.<number> Parse_shen.<plus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<number>)) (kl:shen.pair (car Parse_shen.<number>) (kl:shen.hdtl Parse_shen.<number>)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V1545))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<postdigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1)))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V1545))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (let ((Parse_shen.<E> (kl:shen.<E> Parse_shen.<digits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<E>)) (let ((Parse_shen.<log10> (kl:shen.<log10> Parse_shen.<E>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<log10>)) (kl:shen.pair (car Parse_shen.<log10>) (* (kl:shen.expt 10 (kl:shen.hdtl Parse_shen.<log10>)) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<predigits> (kl:shen.<predigits> V1545))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predigits>)) (let ((Parse_shen.<stop> (kl:shen.<stop> Parse_shen.<predigits>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<stop>)) (let ((Parse_shen.<postdigits> (kl:shen.<postdigits> Parse_shen.<stop>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<postdigits>)) (kl:shen.pair (car Parse_shen.<postdigits>) (+ (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<predigits>)) 0) (kl:shen.post (kl:shen.hdtl Parse_shen.<postdigits>) 1))) (kl:fail))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V1545))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse))) (export shen.<number>) (quote shen.<number>))
(begin (register-function-arity (quote shen.<E>) 1) (define (kl:shen.<E> V1548) (if (and (pair? (car V1548)) (kl:= 101 (kl:shen.hdhd V1548))) (let ((NewStream1546 (kl:shen.pair (kl:shen.tlhd V1548) (kl:shen.hdtl V1548)))) (kl:shen.pair (car NewStream1546) (quote shen.skip))) (kl:fail))) (export shen.<E>) (quote shen.<E>))
(begin (register-function-arity (quote shen.<log10>) 1) (define (kl:shen.<log10> V1550) (let ((YaccParse (let ((Parse_shen.<minus> (kl:shen.<minus> V1550))) (if (kl:not (kl:= (kl:fail) Parse_shen.<minus>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<minus>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (- 0 (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digits> (kl:shen.<digits> V1550))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.pre (kl:reverse (kl:shen.hdtl Parse_shen.<digits>)) 0)) (kl:fail))) YaccParse))) (export shen.<log10>) (quote shen.<log10>))
(begin (register-function-arity (quote shen.<plus>) 1) (define (kl:shen.<plus> V1552) (if (pair? (car V1552)) (let ((Parse_Char (kl:shen.hdhd V1552))) (if (kl:= Parse_Char 43) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1552) (kl:shen.hdtl V1552))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<plus>) (quote shen.<plus>))
(begin (register-function-arity (quote shen.<stop>) 1) (define (kl:shen.<stop> V1554) (if (pair? (car V1554)) (let ((Parse_Char (kl:shen.hdhd V1554))) (if (kl:= Parse_Char 46) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1554) (kl:shen.hdtl V1554))) Parse_Char) (kl:fail))) (kl:fail))) (export shen.<stop>) (quote shen.<stop>))
(begin (register-function-arity (quote shen.<predigits>) 1) (define (kl:shen.<predigits> V1556) (let ((YaccParse (let ((Parse_shen.<digits> (kl:shen.<digits> V1556))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1556))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<predigits>) (quote shen.<predigits>))
(begin (register-function-arity (quote shen.<postdigits>) 1) (define (kl:shen.<postdigits> V1558) (let ((Parse_shen.<digits> (kl:shen.<digits> V1558))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (kl:shen.hdtl Parse_shen.<digits>)) (kl:fail)))) (export shen.<postdigits>) (quote shen.<postdigits>))
(begin (register-function-arity (quote shen.<digits>) 1) (define (kl:shen.<digits> V1560) (let ((YaccParse (let ((Parse_shen.<digit> (kl:shen.<digit> V1560))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (let ((Parse_shen.<digits> (kl:shen.<digits> Parse_shen.<digit>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digits>)) (kl:shen.pair (car Parse_shen.<digits>) (cons (kl:shen.hdtl Parse_shen.<digit>) (kl:shen.hdtl Parse_shen.<digits>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<digit> (kl:shen.<digit> V1560))) (if (kl:not (kl:= (kl:fail) Parse_shen.<digit>)) (kl:shen.pair (car Parse_shen.<digit>) (cons (kl:shen.hdtl Parse_shen.<digit>) (quote ()))) (kl:fail))) YaccParse))) (export shen.<digits>) (quote shen.<digits>))
(begin (register-function-arity (quote shen.<digit>) 1) (define (kl:shen.<digit> V1562) (if (pair? (car V1562)) (let ((Parse_X (kl:shen.hdhd V1562))) (if (assert-boolean (kl:shen.numbyte? Parse_X)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1562) (kl:shen.hdtl V1562))) (kl:shen.byte->digit Parse_X)) (kl:fail))) (kl:fail))) (export shen.<digit>) (quote shen.<digit>))
(begin (register-function-arity (quote shen.byte->digit) 1) (define (kl:shen.byte->digit V1564) (cond ((kl:= 48 V1564) 0) ((kl:= 49 V1564) 1) ((kl:= 50 V1564) 2) ((kl:= 51 V1564) 3) ((kl:= 52 V1564) 4) ((kl:= 53 V1564) 5) ((kl:= 54 V1564) 6) ((kl:= 55 V1564) 7) ((kl:= 56 V1564) 8) ((kl:= 57 V1564) 9) (#t (kl:shen.f_error (quote shen.byte->digit))))) (export shen.byte->digit) (quote shen.byte->digit))
(begin (register-function-arity (quote shen.pre) 2) (define (kl:shen.pre V1569 V1570) (cond ((null? V1569) 0) ((pair? V1569) (+ (* (kl:shen.expt 10 V1570) (car V1569)) (kl:shen.pre (cdr V1569) (+ V1570 1)))) (#t (kl:shen.f_error (quote shen.pre))))) (export shen.pre) (quote shen.pre))
(begin (register-function-arity (quote shen.post) 2) (define (kl:shen.post V1575 V1576) (cond ((null? V1575) 0) ((pair? V1575) (+ (* (kl:shen.expt 10 (- 0 V1576)) (car V1575)) (kl:shen.post (cdr V1575) (+ V1576 1)))) (#t (kl:shen.f_error (quote shen.post))))) (export shen.post) (quote shen.post))
(begin (register-function-arity (quote shen.expt) 2) (define (kl:shen.expt V1581 V1582) (cond ((kl:= 0 V1582) 1) ((> V1582 0) (* V1581 (kl:shen.expt V1581 (- V1582 1)))) (#t (* 1.000000 (/ (kl:shen.expt V1581 (+ V1582 1)) V1581))))) (export shen.expt) (quote shen.expt))
(begin (register-function-arity (quote shen.<st_input1>) 1) (define (kl:shen.<st_input1> V1584) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V1584))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (export shen.<st_input1>) (quote shen.<st_input1>))
(begin (register-function-arity (quote shen.<st_input2>) 1) (define (kl:shen.<st_input2> V1586) (let ((Parse_shen.<st_input> (kl:shen.<st_input> V1586))) (if (kl:not (kl:= (kl:fail) Parse_shen.<st_input>)) (kl:shen.pair (car Parse_shen.<st_input>) (kl:shen.hdtl Parse_shen.<st_input>)) (kl:fail)))) (export shen.<st_input2>) (quote shen.<st_input2>))
(begin (register-function-arity (quote shen.<comment>) 1) (define (kl:shen.<comment> V1588) (let ((YaccParse (let ((Parse_shen.<singleline> (kl:shen.<singleline> V1588))) (if (kl:not (kl:= (kl:fail) Parse_shen.<singleline>)) (kl:shen.pair (car Parse_shen.<singleline>) (quote shen.skip)) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<multiline> (kl:shen.<multiline> V1588))) (if (kl:not (kl:= (kl:fail) Parse_shen.<multiline>)) (kl:shen.pair (car Parse_shen.<multiline>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<comment>) (quote shen.<comment>))
(begin (register-function-arity (quote shen.<singleline>) 1) (define (kl:shen.<singleline> V1590) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V1590))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (let ((Parse_shen.<return> (kl:shen.<return> Parse_shen.<anysingle>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<return>)) (kl:shen.pair (car Parse_shen.<return>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<singleline>) (quote shen.<singleline>))
(begin (register-function-arity (quote shen.<backslash>) 1) (define (kl:shen.<backslash> V1593) (if (and (pair? (car V1593)) (kl:= 92 (kl:shen.hdhd V1593))) (let ((NewStream1591 (kl:shen.pair (kl:shen.tlhd V1593) (kl:shen.hdtl V1593)))) (kl:shen.pair (car NewStream1591) (quote shen.skip))) (kl:fail))) (export shen.<backslash>) (quote shen.<backslash>))
(begin (register-function-arity (quote shen.<anysingle>) 1) (define (kl:shen.<anysingle> V1595) (let ((YaccParse (let ((Parse_shen.<non-return> (kl:shen.<non-return> V1595))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-return>)) (let ((Parse_shen.<anysingle> (kl:shen.<anysingle> Parse_shen.<non-return>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anysingle>)) (kl:shen.pair (car Parse_shen.<anysingle>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V1595))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<anysingle>) (quote shen.<anysingle>))
(begin (register-function-arity (quote shen.<non-return>) 1) (define (kl:shen.<non-return> V1597) (if (pair? (car V1597)) (let ((Parse_X (kl:shen.hdhd V1597))) (if (kl:not (kl:element? Parse_X (cons 10 (cons 13 (quote ()))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1597) (kl:shen.hdtl V1597))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<non-return>) (quote shen.<non-return>))
(begin (register-function-arity (quote shen.<return>) 1) (define (kl:shen.<return> V1599) (if (pair? (car V1599)) (let ((Parse_X (kl:shen.hdhd V1599))) (if (kl:element? Parse_X (cons 10 (cons 13 (quote ())))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1599) (kl:shen.hdtl V1599))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<return>) (quote shen.<return>))
(begin (register-function-arity (quote shen.<multiline>) 1) (define (kl:shen.<multiline> V1601) (let ((Parse_shen.<backslash> (kl:shen.<backslash> V1601))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (let ((Parse_shen.<times> (kl:shen.<times> Parse_shen.<backslash>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))) (kl:fail)))) (export shen.<multiline>) (quote shen.<multiline>))
(begin (register-function-arity (quote shen.<times>) 1) (define (kl:shen.<times> V1604) (if (and (pair? (car V1604)) (kl:= 42 (kl:shen.hdhd V1604))) (let ((NewStream1602 (kl:shen.pair (kl:shen.tlhd V1604) (kl:shen.hdtl V1604)))) (kl:shen.pair (car NewStream1602) (quote shen.skip))) (kl:fail))) (export shen.<times>) (quote shen.<times>))
(begin (register-function-arity (quote shen.<anymulti>) 1) (define (kl:shen.<anymulti> V1606) (let ((YaccParse (let ((Parse_shen.<comment> (kl:shen.<comment> V1606))) (if (kl:not (kl:= (kl:fail) Parse_shen.<comment>)) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> Parse_shen.<comment>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((YaccParse (let ((Parse_shen.<times> (kl:shen.<times> V1606))) (if (kl:not (kl:= (kl:fail) Parse_shen.<times>)) (let ((Parse_shen.<backslash> (kl:shen.<backslash> Parse_shen.<times>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<backslash>)) (kl:shen.pair (car Parse_shen.<backslash>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V1606)) (let ((Parse_X (kl:shen.hdhd V1606))) (let ((Parse_shen.<anymulti> (kl:shen.<anymulti> (kl:shen.pair (kl:shen.tlhd V1606) (kl:shen.hdtl V1606))))) (if (kl:not (kl:= (kl:fail) Parse_shen.<anymulti>)) (kl:shen.pair (car Parse_shen.<anymulti>) (quote shen.skip)) (kl:fail)))) (kl:fail)) YaccParse)) YaccParse))) (export shen.<anymulti>) (quote shen.<anymulti>))
(begin (register-function-arity (quote shen.<whitespaces>) 1) (define (kl:shen.<whitespaces> V1608) (let ((YaccParse (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V1608))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (let ((Parse_shen.<whitespaces> (kl:shen.<whitespaces> Parse_shen.<whitespace>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespaces>)) (kl:shen.pair (car Parse_shen.<whitespaces>) (quote shen.skip)) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<whitespace> (kl:shen.<whitespace> V1608))) (if (kl:not (kl:= (kl:fail) Parse_shen.<whitespace>)) (kl:shen.pair (car Parse_shen.<whitespace>) (quote shen.skip)) (kl:fail))) YaccParse))) (export shen.<whitespaces>) (quote shen.<whitespaces>))
(begin (register-function-arity (quote shen.<whitespace>) 1) (define (kl:shen.<whitespace> V1610) (if (pair? (car V1610)) (let ((Parse_X (kl:shen.hdhd V1610))) (if (assert-boolean (let ((Parse_Case Parse_X)) (or (kl:= Parse_Case 32) (or (kl:= Parse_Case 13) (or (kl:= Parse_Case 10) (kl:= Parse_Case 9)))))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V1610) (kl:shen.hdtl V1610))) (quote shen.skip)) (kl:fail))) (kl:fail))) (export shen.<whitespace>) (quote shen.<whitespace>))
(begin (register-function-arity (quote shen.cons_form) 1) (define (kl:shen.cons_form V1612) (cond ((null? V1612) (quote ())) ((and (pair? V1612) (and (pair? (cdr V1612)) (and (pair? (cdr (cdr V1612))) (and (null? (cdr (cdr (cdr V1612)))) (eq? (car (cdr V1612)) (quote bar!)))))) (cons (quote cons) (cons (car V1612) (cdr (cdr V1612))))) ((pair? V1612) (cons (quote cons) (cons (car V1612) (cons (kl:shen.cons_form (cdr V1612)) (quote ()))))) (#t (kl:shen.f_error (quote shen.cons_form))))) (export shen.cons_form) (quote shen.cons_form))
(begin (register-function-arity (quote shen.package-macro) 2) (define (kl:shen.package-macro V1617 V1618) (cond ((and (pair? V1617) (and (eq? (quote _waspvm_dl_) (car V1617)) (and (pair? (cdr V1617)) (null? (cdr (cdr V1617)))))) (kl:append (kl:explode (car (cdr V1617))) V1618)) ((and (pair? V1617) (and (eq? (quote package) (car V1617)) (and (pair? (cdr V1617)) (and (eq? (quote null) (car (cdr V1617))) (pair? (cdr (cdr V1617))))))) (kl:append (cdr (cdr (cdr V1617))) V1618)) ((and (pair? V1617) (and (eq? (quote package) (car V1617)) (and (pair? (cdr V1617)) (pair? (cdr (cdr V1617)))))) (let ((ListofExceptions (kl:shen.eval-without-macros (car (cdr (cdr V1617)))))) (let ((External (kl:shen.record-exceptions ListofExceptions (car (cdr V1617))))) (let ((PackageNameDot (kl:intern (string-append (kl:str (car (cdr V1617))) ".")))) (let ((ExpPackageNameDot (kl:explode PackageNameDot))) (let ((Packaged (kl:shen.packageh PackageNameDot ListofExceptions (cdr (cdr (cdr V1617))) ExpPackageNameDot))) (let ((Internal (kl:shen.record-internal (car (cdr V1617)) (kl:shen.internal-symbols ExpPackageNameDot Packaged)))) (kl:append Packaged V1618)))))))) (#t (cons V1617 V1618)))) (export shen.package-macro) (quote shen.package-macro))
(begin (register-function-arity (quote shen.record-exceptions) 2) (define (kl:shen.record-exceptions V1621 V1622) (let ((CurrExceptions (guard (lambda (E) (quote ())) (kl:get V1622 (quote shen.external-symbols) (kl:value (quote *property-vector*)))))) (let ((AllExceptions (kl:union V1621 CurrExceptions))) (kl:put V1622 (quote shen.external-symbols) AllExceptions (kl:value (quote *property-vector*)))))) (export shen.record-exceptions) (quote shen.record-exceptions))
(begin (register-function-arity (quote shen.record-internal) 2) (define (kl:shen.record-internal V1625 V1626) (kl:put V1625 (quote shen.internal-symbols) (kl:union V1626 (guard (lambda (E) (quote ())) (kl:get V1625 (quote shen.internal-symbols) (kl:value (quote *property-vector*))))) (kl:value (quote *property-vector*)))) (export shen.record-internal) (quote shen.record-internal))
(begin (register-function-arity (quote shen.internal-symbols) 2) (define (kl:shen.internal-symbols V1637 V1638) (cond ((and (kl:symbol? V1638) (assert-boolean (kl:shen.prefix? V1637 (kl:explode V1638)))) (cons V1638 (quote ()))) ((pair? V1638) (kl:union (kl:shen.internal-symbols V1637 (car V1638)) (kl:shen.internal-symbols V1637 (cdr V1638)))) (#t (quote ())))) (export shen.internal-symbols) (quote shen.internal-symbols))
(begin (register-function-arity (quote shen.packageh) 4) (define (kl:shen.packageh V1655 V1656 V1657 V1658) (cond ((pair? V1657) (cons (kl:shen.packageh V1655 V1656 (car V1657) V1658) (kl:shen.packageh V1655 V1656 (cdr V1657) V1658))) ((or (assert-boolean (kl:shen.sysfunc? V1657)) (or (kl:variable? V1657) (or (kl:element? V1657 V1656) (or (assert-boolean (kl:shen.doubleunderline? V1657)) (assert-boolean (kl:shen.singleunderline? V1657)))))) V1657) ((and (kl:symbol? V1657) (assert-boolean (let ((ExplodeX (kl:explode V1657))) (and (kl:not (kl:shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." (quote ())))))) ExplodeX)) (kl:not (kl:shen.prefix? V1658 ExplodeX)))))) (kl:concat V1655 V1657)) (#t V1657))) (export shen.packageh) (quote shen.packageh))

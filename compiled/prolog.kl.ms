(module "compiled/prolog.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.<defprolog>) 1) (define (kl:shen.<defprolog> V809) (let ((Parse_shen.<predicate*> (kl:shen.<predicate*> V809))) (if (kl:not (kl:= (kl:fail) Parse_shen.<predicate*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<predicate*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (car (kl:shen.prolog->shen (kl:map (lambda (Parse_X) (kl:shen.insert-predicate (kl:shen.hdtl Parse_shen.<predicate*>) Parse_X)) (kl:shen.hdtl Parse_shen.<clauses*>))))) (kl:fail))) (kl:fail)))) (export shen.<defprolog>) (quote shen.<defprolog>))
(begin (register-function-arity (quote shen.prolog-error) 2) (define (kl:shen.prolog-error V818 V819) (cond ((and (pair? V819) (and (pair? (cdr V819)) (null? (cdr (cdr V819))))) (simple-error (string-append "prolog syntax error in " (kl:shen.app V818 (string-append " here:\n\n " (kl:shen.app (kl:shen.next-50 50 (car V819)) "\n" (quote shen.a))) (quote shen.a))))) (#t (simple-error (string-append "prolog syntax error in " (kl:shen.app V818 "\n" (quote shen.a))))))) (export shen.prolog-error) (quote shen.prolog-error))
(begin (register-function-arity (quote shen.next-50) 2) (define (kl:shen.next-50 V826 V827) (cond ((null? V827) "") ((kl:= 0 V826) "") ((pair? V827) (string-append (kl:shen.decons-string (car V827)) (kl:shen.next-50 (- V826 1) (cdr V827)))) (#t (kl:shen.f_error (quote shen.next-50))))) (export shen.next-50) (quote shen.next-50))
(begin (register-function-arity (quote shen.decons-string) 1) (define (kl:shen.decons-string V829) (cond ((and (pair? V829) (and (eq? (quote cons) (car V829)) (and (pair? (cdr V829)) (and (pair? (cdr (cdr V829))) (null? (cdr (cdr (cdr V829)))))))) (kl:shen.app (kl:shen.eval-cons V829) " " (quote shen.s))) (#t (kl:shen.app V829 " " (quote shen.r))))) (export shen.decons-string) (quote shen.decons-string))
(begin (register-function-arity (quote shen.insert-predicate) 2) (define (kl:shen.insert-predicate V832 V833) (cond ((and (pair? V833) (and (pair? (cdr V833)) (null? (cdr (cdr V833))))) (cons (cons V832 (car V833)) (cons (quote :-) (cdr V833)))) (#t (kl:shen.f_error (quote shen.insert-predicate))))) (export shen.insert-predicate) (quote shen.insert-predicate))
(begin (register-function-arity (quote shen.<predicate*>) 1) (define (kl:shen.<predicate*> V835) (if (pair? (car V835)) (let ((Parse_X (kl:shen.hdhd V835))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V835) (kl:shen.hdtl V835))) Parse_X)) (kl:fail))) (export shen.<predicate*>) (quote shen.<predicate*>))
(begin (register-function-arity (quote shen.<clauses*>) 1) (define (kl:shen.<clauses*> V837) (let ((YaccParse (let ((Parse_shen.<clause*> (kl:shen.<clause*> V837))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clause*>)) (let ((Parse_shen.<clauses*> (kl:shen.<clauses*> Parse_shen.<clause*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<clauses*>)) (kl:shen.pair (car Parse_shen.<clauses*>) (cons (kl:shen.hdtl Parse_shen.<clause*>) (kl:shen.hdtl Parse_shen.<clauses*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V837))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<clauses*>) (quote shen.<clauses*>))
(begin (register-function-arity (quote shen.<clause*>) 1) (define (kl:shen.<clause*> V840) (let ((Parse_shen.<head*> (kl:shen.<head*> V840))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (if (and (pair? (car Parse_shen.<head*>)) (eq? (quote <--) (kl:shen.hdhd Parse_shen.<head*>))) (let ((NewStream838 (kl:shen.pair (kl:shen.tlhd Parse_shen.<head*>) (kl:shen.hdtl Parse_shen.<head*>)))) (let ((Parse_shen.<body*> (kl:shen.<body*> NewStream838))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (let ((Parse_shen.<end*> (kl:shen.<end*> Parse_shen.<body*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<end*>)) (kl:shen.pair (car Parse_shen.<end*>) (cons (kl:shen.hdtl Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<body*>) (quote ())))) (kl:fail))) (kl:fail)))) (kl:fail)) (kl:fail)))) (export shen.<clause*>) (quote shen.<clause*>))
(begin (register-function-arity (quote shen.<head*>) 1) (define (kl:shen.<head*> V842) (let ((YaccParse (let ((Parse_shen.<term*> (kl:shen.<term*> V842))) (if (kl:not (kl:= (kl:fail) Parse_shen.<term*>)) (let ((Parse_shen.<head*> (kl:shen.<head*> Parse_shen.<term*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<head*>)) (kl:shen.pair (car Parse_shen.<head*>) (cons (kl:shen.hdtl Parse_shen.<term*>) (kl:shen.hdtl Parse_shen.<head*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V842))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<head*>) (quote shen.<head*>))
(begin (register-function-arity (quote shen.<term*>) 1) (define (kl:shen.<term*> V844) (if (pair? (car V844)) (let ((Parse_X (kl:shen.hdhd V844))) (if (and (kl:not (eq? (quote <--) Parse_X)) (assert-boolean (kl:shen.legitimate-term? Parse_X))) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V844) (kl:shen.hdtl V844))) (kl:shen.eval-cons Parse_X)) (kl:fail))) (kl:fail))) (export shen.<term*>) (quote shen.<term*>))
(begin (register-function-arity (quote shen.legitimate-term?) 1) (define (kl:shen.legitimate-term? V850) (cond ((and (pair? V850) (and (eq? (quote cons) (car V850)) (and (pair? (cdr V850)) (and (pair? (cdr (cdr V850))) (null? (cdr (cdr (cdr V850)))))))) (and (assert-boolean (kl:shen.legitimate-term? (car (cdr V850)))) (assert-boolean (kl:shen.legitimate-term? (car (cdr (cdr V850))))))) ((and (pair? V850) (and (eq? (quote mode) (car V850)) (and (pair? (cdr V850)) (and (pair? (cdr (cdr V850))) (and (eq? (quote +) (car (cdr (cdr V850)))) (null? (cdr (cdr (cdr V850))))))))) (kl:shen.legitimate-term? (car (cdr V850)))) ((and (pair? V850) (and (eq? (quote mode) (car V850)) (and (pair? (cdr V850)) (and (pair? (cdr (cdr V850))) (and (eq? (quote -) (car (cdr (cdr V850)))) (null? (cdr (cdr (cdr V850))))))))) (kl:shen.legitimate-term? (car (cdr V850)))) ((pair? V850) #f) (#t #t))) (export shen.legitimate-term?) (quote shen.legitimate-term?))
(begin (register-function-arity (quote shen.eval-cons) 1) (define (kl:shen.eval-cons V852) (cond ((and (pair? V852) (and (eq? (quote cons) (car V852)) (and (pair? (cdr V852)) (and (pair? (cdr (cdr V852))) (null? (cdr (cdr (cdr V852)))))))) (cons (kl:shen.eval-cons (car (cdr V852))) (kl:shen.eval-cons (car (cdr (cdr V852)))))) ((and (pair? V852) (and (eq? (quote mode) (car V852)) (and (pair? (cdr V852)) (and (pair? (cdr (cdr V852))) (null? (cdr (cdr (cdr V852)))))))) (cons (quote mode) (cons (kl:shen.eval-cons (car (cdr V852))) (cdr (cdr V852))))) (#t V852))) (export shen.eval-cons) (quote shen.eval-cons))
(begin (register-function-arity (quote shen.<body*>) 1) (define (kl:shen.<body*> V854) (let ((YaccParse (let ((Parse_shen.<literal*> (kl:shen.<literal*> V854))) (if (kl:not (kl:= (kl:fail) Parse_shen.<literal*>)) (let ((Parse_shen.<body*> (kl:shen.<body*> Parse_shen.<literal*>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<body*>)) (kl:shen.pair (car Parse_shen.<body*>) (cons (kl:shen.hdtl Parse_shen.<literal*>) (kl:shen.hdtl Parse_shen.<body*>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_<e> (kl:<e> V854))) (if (kl:not (kl:= (kl:fail) Parse_<e>)) (kl:shen.pair (car Parse_<e>) (quote ())) (kl:fail))) YaccParse))) (export shen.<body*>) (quote shen.<body*>))
(begin (register-function-arity (quote shen.<literal*>) 1) (define (kl:shen.<literal*> V857) (let ((YaccParse (if (and (pair? (car V857)) (eq? (quote !) (kl:shen.hdhd V857))) (let ((NewStream855 (kl:shen.pair (kl:shen.tlhd V857) (kl:shen.hdtl V857)))) (kl:shen.pair (car NewStream855) (cons (quote cut) (cons (kl:intern "Throwcontrol") (quote ()))))) (kl:fail)))) (if (kl:= YaccParse (kl:fail)) (if (pair? (car V857)) (let ((Parse_X (kl:shen.hdhd V857))) (if (pair? Parse_X) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V857) (kl:shen.hdtl V857))) Parse_X) (kl:fail))) (kl:fail)) YaccParse))) (export shen.<literal*>) (quote shen.<literal*>))
(begin (register-function-arity (quote shen.<end*>) 1) (define (kl:shen.<end*> V859) (if (pair? (car V859)) (let ((Parse_X (kl:shen.hdhd V859))) (if (eq? Parse_X (quote _waspvm_sc_)) (kl:shen.pair (car (kl:shen.pair (kl:shen.tlhd V859) (kl:shen.hdtl V859))) Parse_X) (kl:fail))) (kl:fail))) (export shen.<end*>) (quote shen.<end*>))
(begin (register-function-arity (quote cut) 3) (define (kl:cut V863 V864 V865) (let ((Result (kl:thaw V865))) (if (kl:= Result #f) V863 Result))) (export cut) (quote cut))
(begin (register-function-arity (quote shen.insert_modes) 1) (define (kl:shen.insert_modes V867) (cond ((and (pair? V867) (and (eq? (quote mode) (car V867)) (and (pair? (cdr V867)) (and (pair? (cdr (cdr V867))) (null? (cdr (cdr (cdr V867)))))))) V867) ((null? V867) (quote ())) ((pair? V867) (cons (cons (quote mode) (cons (car V867) (cons (quote +) (quote ())))) (cons (quote mode) (cons (kl:shen.insert_modes (cdr V867)) (cons (quote -) (quote ())))))) (#t V867))) (export shen.insert_modes) (quote shen.insert_modes))
(begin (register-function-arity (quote shen.s-prolog) 1) (define (kl:shen.s-prolog V869) (kl:map (lambda (X) (kl:eval X)) (kl:shen.prolog->shen V869))) (export shen.s-prolog) (quote shen.s-prolog))
(begin (register-function-arity (quote shen.prolog->shen) 1) (define (kl:shen.prolog->shen V871) (kl:map (lambda (X) (kl:shen.compile_prolog_procedure X)) (kl:shen.group_clauses (kl:map (lambda (X) (kl:shen.s-prolog_clause X)) (kl:mapcan (lambda (X) (kl:shen.head_abstraction X)) V871))))) (export shen.prolog->shen) (quote shen.prolog->shen))
(begin (register-function-arity (quote shen.s-prolog_clause) 1) (define (kl:shen.s-prolog_clause V873) (cond ((and (pair? V873) (and (pair? (cdr V873)) (and (eq? (quote :-) (car (cdr V873))) (and (pair? (cdr (cdr V873))) (null? (cdr (cdr (cdr V873)))))))) (cons (car V873) (cons (quote :-) (cons (kl:map (lambda (X) (kl:shen.s-prolog_literal X)) (car (cdr (cdr V873)))) (quote ()))))) (#t (kl:shen.f_error (quote shen.s-prolog_clause))))) (export shen.s-prolog_clause) (quote shen.s-prolog_clause))
(begin (register-function-arity (quote shen.head_abstraction) 1) (define (kl:shen.head_abstraction V875) (cond ((and (pair? V875) (and (pair? (cdr V875)) (and (eq? (quote :-) (car (cdr V875))) (and (pair? (cdr (cdr V875))) (and (null? (cdr (cdr (cdr V875)))) (assert-boolean (guard (lambda (_) #f) (< (kl:shen.complexity_head (car V875)) (kl:value (quote shen.*maxcomplexity*)))))))))) (cons V875 (quote ()))) ((and (pair? V875) (and (pair? (car V875)) (and (pair? (cdr V875)) (and (eq? (quote :-) (car (cdr V875))) (and (pair? (cdr (cdr V875))) (null? (cdr (cdr (cdr V875))))))))) (let ((Terms (kl:map (lambda (Y) (kl:gensym (quote V))) (cdr (car V875))))) (let ((XTerms (kl:shen.rcons_form (kl:shen.remove_modes (cdr (car V875)))))) (let ((Literal (cons (quote unify) (cons (kl:shen.cons_form Terms) (cons XTerms (quote ())))))) (let ((Clause (cons (cons (car (car V875)) Terms) (cons (quote :-) (cons (cons Literal (car (cdr (cdr V875)))) (quote ())))))) (cons Clause (quote ()))))))) (#t (kl:shen.f_error (quote shen.head_abstraction))))) (export shen.head_abstraction) (quote shen.head_abstraction))
(begin (register-function-arity (quote shen.complexity_head) 1) (define (kl:shen.complexity_head V881) (cond ((pair? V881) (kl:shen.safe-product (kl:map (lambda (X) (kl:shen.complexity X)) (cdr V881)))) (#t (kl:shen.f_error (quote shen.complexity_head))))) (export shen.complexity_head) (quote shen.complexity_head))
(begin (register-function-arity (quote shen.safe-multiply) 2) (define (kl:shen.safe-multiply V884 V885) (* V884 V885)) (export shen.safe-multiply) (quote shen.safe-multiply))
(begin (register-function-arity (quote shen.complexity) 1) (define (kl:shen.complexity V894) (cond ((and (pair? V894) (and (eq? (quote mode) (car V894)) (and (pair? (cdr V894)) (and (pair? (car (cdr V894))) (and (eq? (quote mode) (car (car (cdr V894)))) (and (pair? (cdr (car (cdr V894)))) (and (pair? (cdr (cdr (car (cdr V894))))) (and (null? (cdr (cdr (cdr (car (cdr V894)))))) (and (pair? (cdr (cdr V894))) (null? (cdr (cdr (cdr V894))))))))))))) (kl:shen.complexity (car (cdr V894)))) ((and (pair? V894) (and (eq? (quote mode) (car V894)) (and (pair? (cdr V894)) (and (pair? (car (cdr V894))) (and (pair? (cdr (cdr V894))) (and (eq? (quote +) (car (cdr (cdr V894)))) (null? (cdr (cdr (cdr V894)))))))))) (kl:shen.safe-multiply 2 (kl:shen.safe-multiply (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V894))) (cdr (cdr V894))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V894))) (cdr (cdr V894)))))))) ((and (pair? V894) (and (eq? (quote mode) (car V894)) (and (pair? (cdr V894)) (and (pair? (car (cdr V894))) (and (pair? (cdr (cdr V894))) (and (eq? (quote -) (car (cdr (cdr V894)))) (null? (cdr (cdr (cdr V894)))))))))) (kl:shen.safe-multiply (kl:shen.complexity (cons (quote mode) (cons (car (car (cdr V894))) (cdr (cdr V894))))) (kl:shen.complexity (cons (quote mode) (cons (cdr (car (cdr V894))) (cdr (cdr V894))))))) ((and (pair? V894) (and (eq? (quote mode) (car V894)) (and (pair? (cdr V894)) (and (pair? (cdr (cdr V894))) (and (null? (cdr (cdr (cdr V894)))) (kl:variable? (car (cdr V894)))))))) 1) ((and (pair? V894) (and (eq? (quote mode) (car V894)) (and (pair? (cdr V894)) (and (pair? (cdr (cdr V894))) (and (eq? (quote +) (car (cdr (cdr V894)))) (null? (cdr (cdr (cdr V894))))))))) 2) ((and (pair? V894) (and (eq? (quote mode) (car V894)) (and (pair? (cdr V894)) (and (pair? (cdr (cdr V894))) (and (eq? (quote -) (car (cdr (cdr V894)))) (null? (cdr (cdr (cdr V894))))))))) 1) (#t (kl:shen.complexity (cons (quote mode) (cons V894 (cons (quote +) (quote ())))))))) (export shen.complexity) (quote shen.complexity))
(begin (register-function-arity (quote shen.safe-product) 1) (define (kl:shen.safe-product V896) (cond ((null? V896) 1) ((pair? V896) (kl:shen.safe-multiply (car V896) (kl:shen.safe-product (cdr V896)))) (#t (kl:shen.f_error (quote shen.safe-product))))) (export shen.safe-product) (quote shen.safe-product))
(begin (register-function-arity (quote shen.s-prolog_literal) 1) (define (kl:shen.s-prolog_literal V898) (cond ((and (pair? V898) (and (eq? (quote is) (car V898)) (and (pair? (cdr V898)) (and (pair? (cdr (cdr V898))) (null? (cdr (cdr (cdr V898)))))))) (cons (quote bind) (cons (car (cdr V898)) (cons (kl:shen.insert-deref (car (cdr (cdr V898))) (quote ProcessN)) (quote ()))))) ((and (pair? V898) (and (eq? (quote when) (car V898)) (and (pair? (cdr V898)) (null? (cdr (cdr V898)))))) (cons (quote fwhen) (cons (kl:shen.insert-deref (car (cdr V898)) (quote ProcessN)) (quote ())))) ((and (pair? V898) (and (eq? (quote bind) (car V898)) (and (pair? (cdr V898)) (and (pair? (cdr (cdr V898))) (null? (cdr (cdr (cdr V898)))))))) (cons (quote bind) (cons (car (cdr V898)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V898))) (quote ProcessN)) (quote ()))))) ((and (pair? V898) (and (eq? (quote fwhen) (car V898)) (and (pair? (cdr V898)) (null? (cdr (cdr V898)))))) (cons (quote fwhen) (cons (kl:shen.insert-lazyderef (car (cdr V898)) (quote ProcessN)) (quote ())))) ((pair? V898) V898) (#t (kl:shen.f_error (quote shen.s-prolog_literal))))) (export shen.s-prolog_literal) (quote shen.s-prolog_literal))
(begin (register-function-arity (quote shen.insert-deref) 2) (define (kl:shen.insert-deref V905 V906) (cond ((kl:variable? V905) (cons (quote shen.deref) (cons V905 (cons V906 (quote ()))))) ((and (pair? V905) (and (eq? (quote lambda) (car V905)) (and (pair? (cdr V905)) (and (pair? (cdr (cdr V905))) (null? (cdr (cdr (cdr V905)))))))) (cons (quote lambda) (cons (car (cdr V905)) (cons (kl:shen.insert-deref (car (cdr (cdr V905))) V906) (quote ()))))) ((and (pair? V905) (and (eq? (quote let) (car V905)) (and (pair? (cdr V905)) (and (pair? (cdr (cdr V905))) (and (pair? (cdr (cdr (cdr V905)))) (null? (cdr (cdr (cdr (cdr V905)))))))))) (cons (quote let) (cons (car (cdr V905)) (cons (kl:shen.insert-deref (car (cdr (cdr V905))) V906) (cons (kl:shen.insert-deref (car (cdr (cdr (cdr V905)))) V906) (quote ())))))) ((pair? V905) (cons (kl:shen.insert-deref (car V905) V906) (kl:shen.insert-deref (cdr V905) V906))) (#t V905))) (export shen.insert-deref) (quote shen.insert-deref))
(begin (register-function-arity (quote shen.insert-lazyderef) 2) (define (kl:shen.insert-lazyderef V913 V914) (cond ((kl:variable? V913) (cons (quote shen.lazyderef) (cons V913 (cons V914 (quote ()))))) ((and (pair? V913) (and (eq? (quote lambda) (car V913)) (and (pair? (cdr V913)) (and (pair? (cdr (cdr V913))) (null? (cdr (cdr (cdr V913)))))))) (cons (quote lambda) (cons (car (cdr V913)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V913))) V914) (quote ()))))) ((and (pair? V913) (and (eq? (quote let) (car V913)) (and (pair? (cdr V913)) (and (pair? (cdr (cdr V913))) (and (pair? (cdr (cdr (cdr V913)))) (null? (cdr (cdr (cdr (cdr V913)))))))))) (cons (quote let) (cons (car (cdr V913)) (cons (kl:shen.insert-lazyderef (car (cdr (cdr V913))) V914) (cons (kl:shen.insert-lazyderef (car (cdr (cdr (cdr V913)))) V914) (quote ())))))) ((pair? V913) (cons (kl:shen.insert-lazyderef (car V913) V914) (kl:shen.insert-lazyderef (cdr V913) V914))) (#t V913))) (export shen.insert-lazyderef) (quote shen.insert-lazyderef))
(begin (register-function-arity (quote shen.group_clauses) 1) (define (kl:shen.group_clauses V916) (cond ((null? V916) (quote ())) ((pair? V916) (let ((Group (kl:shen.collect (lambda (X) (kl:shen.same_predicate? (car V916) X)) V916))) (let ((Rest (kl:difference V916 Group))) (cons Group (kl:shen.group_clauses Rest))))) (#t (kl:shen.f_error (quote shen.group_clauses))))) (export shen.group_clauses) (quote shen.group_clauses))
(begin (register-function-arity (quote shen.collect) 2) (define (kl:shen.collect V921 V922) (cond ((null? V922) (quote ())) ((pair? V922) (if (assert-boolean (V921 (car V922))) (cons (car V922) (kl:shen.collect V921 (cdr V922))) (kl:shen.collect V921 (cdr V922)))) (#t (kl:shen.f_error (quote shen.collect))))) (export shen.collect) (quote shen.collect))
(begin (register-function-arity (quote shen.same_predicate?) 2) (define (kl:shen.same_predicate? V941 V942) (cond ((and (pair? V941) (and (pair? (car V941)) (and (pair? V942) (pair? (car V942))))) (kl:= (car (car V941)) (car (car V942)))) (#t (kl:shen.f_error (quote shen.same_predicate?))))) (export shen.same_predicate?) (quote shen.same_predicate?))
(begin (register-function-arity (quote shen.compile_prolog_procedure) 1) (define (kl:shen.compile_prolog_procedure V944) (let ((F (kl:shen.procedure_name V944))) (let ((Shen (kl:shen.clauses-to-shen F V944))) Shen))) (export shen.compile_prolog_procedure) (quote shen.compile_prolog_procedure))
(begin (register-function-arity (quote shen.procedure_name) 1) (define (kl:shen.procedure_name V958) (cond ((and (pair? V958) (and (pair? (car V958)) (pair? (car (car V958))))) (car (car (car V958)))) (#t (kl:shen.f_error (quote shen.procedure_name))))) (export shen.procedure_name) (quote shen.procedure_name))
(begin (register-function-arity (quote shen.clauses-to-shen) 2) (define (kl:shen.clauses-to-shen V961 V962) (let ((Linear (kl:map (lambda (X) (kl:shen.linearise-clause X)) V962))) (let ((Arity (kl:shen.prolog-aritycheck V961 (kl:map (lambda (X) (kl:head X)) V962)))) (let ((Parameters (kl:shen.parameters Arity))) (let ((AUM_instructions (kl:map (lambda (X) (kl:shen.aum X Parameters)) Linear))) (let ((Code (kl:shen.catch-cut (kl:shen.nest-disjunct (kl:map (lambda (X) (kl:shen.aum_to_shen X)) AUM_instructions))))) (let ((ShenDef (cons (quote define) (cons V961 (kl:append Parameters (kl:append (cons (quote ProcessN) (cons (quote Continuation) (quote ()))) (cons (quote ->) (cons Code (quote ()))))))))) ShenDef))))))) (export shen.clauses-to-shen) (quote shen.clauses-to-shen))
(begin (register-function-arity (quote shen.catch-cut) 1) (define (kl:shen.catch-cut V964) (cond ((kl:not (kl:shen.occurs? (quote cut) V964)) V964) (#t (cons (quote let) (cons (quote Throwcontrol) (cons (cons (quote shen.catchpoint) (quote ())) (cons (cons (quote shen.cutpoint) (cons (quote Throwcontrol) (cons V964 (quote ())))) (quote ())))))))) (export shen.catch-cut) (quote shen.catch-cut))
(begin (register-function-arity (quote shen.catchpoint) 0) (define (kl:shen.catchpoint) (cons (quote shen.catchpoint!) (kl:set (quote shen.*catch*) (+ 1 (kl:value (quote shen.*catch*)))))) (export shen.catchpoint) (quote shen.catchpoint))
(begin (register-function-arity (quote shen.cutpoint) 2) (define (kl:shen.cutpoint V972 V973) (cond ((kl:= V973 V972) #f) (#t V973))) (export shen.cutpoint) (quote shen.cutpoint))
(begin (register-function-arity (quote shen.nest-disjunct) 1) (define (kl:shen.nest-disjunct V975) (cond ((and (pair? V975) (null? (cdr V975))) (car V975)) ((pair? V975) (kl:shen.lisp-or (car V975) (kl:shen.nest-disjunct (cdr V975)))) (#t (kl:shen.f_error (quote shen.nest-disjunct))))) (export shen.nest-disjunct) (quote shen.nest-disjunct))
(begin (register-function-arity (quote shen.lisp-or) 2) (define (kl:shen.lisp-or V978 V979) (cons (quote let) (cons (quote Case) (cons V978 (cons (cons (quote if) (cons (cons (quote =) (cons (quote Case) (cons #f (quote ())))) (cons V979 (cons (quote Case) (quote ()))))) (quote ())))))) (export shen.lisp-or) (quote shen.lisp-or))
(begin (register-function-arity (quote shen.prolog-aritycheck) 2) (define (kl:shen.prolog-aritycheck V984 V985) (cond ((and (pair? V985) (null? (cdr V985))) (- (kl:length (car V985)) 1)) ((and (pair? V985) (pair? (cdr V985))) (if (kl:= (kl:length (car V985)) (kl:length (car (cdr V985)))) (kl:shen.prolog-aritycheck V984 (cdr V985)) (simple-error (string-append "arity error in prolog procedure " (kl:shen.app (cons V984 (quote ())) "\n" (quote shen.a)))))) (#t (kl:shen.f_error (quote shen.prolog-aritycheck))))) (export shen.prolog-aritycheck) (quote shen.prolog-aritycheck))
(begin (register-function-arity (quote shen.linearise-clause) 1) (define (kl:shen.linearise-clause V987) (cond ((and (pair? V987) (and (pair? (cdr V987)) (and (eq? (quote :-) (car (cdr V987))) (and (pair? (cdr (cdr V987))) (null? (cdr (cdr (cdr V987)))))))) (let ((Linear (kl:shen.linearise (cons (car V987) (cdr (cdr V987)))))) (kl:shen.clause_form Linear))) (#t (kl:shen.f_error (quote shen.linearise-clause))))) (export shen.linearise-clause) (quote shen.linearise-clause))
(begin (register-function-arity (quote shen.clause_form) 1) (define (kl:shen.clause_form V989) (cond ((and (pair? V989) (and (pair? (cdr V989)) (null? (cdr (cdr V989))))) (cons (kl:shen.explicit_modes (car V989)) (cons (quote :-) (cons (kl:shen.cf_help (car (cdr V989))) (quote ()))))) (#t (kl:shen.f_error (quote shen.clause_form))))) (export shen.clause_form) (quote shen.clause_form))
(begin (register-function-arity (quote shen.explicit_modes) 1) (define (kl:shen.explicit_modes V991) (cond ((pair? V991) (cons (car V991) (kl:map (lambda (X) (kl:shen.em_help X)) (cdr V991)))) (#t (kl:shen.f_error (quote shen.explicit_modes))))) (export shen.explicit_modes) (quote shen.explicit_modes))
(begin (register-function-arity (quote shen.em_help) 1) (define (kl:shen.em_help V993) (cond ((and (pair? V993) (and (eq? (quote mode) (car V993)) (and (pair? (cdr V993)) (and (pair? (cdr (cdr V993))) (null? (cdr (cdr (cdr V993)))))))) V993) (#t (cons (quote mode) (cons V993 (cons (quote +) (quote ()))))))) (export shen.em_help) (quote shen.em_help))
(begin (register-function-arity (quote shen.cf_help) 1) (define (kl:shen.cf_help V995) (cond ((and (pair? V995) (and (eq? (quote where) (car V995)) (and (pair? (cdr V995)) (and (pair? (car (cdr V995))) (and (eq? (quote =) (car (car (cdr V995)))) (and (pair? (cdr (car (cdr V995)))) (and (pair? (cdr (cdr (car (cdr V995))))) (and (null? (cdr (cdr (cdr (car (cdr V995)))))) (and (pair? (cdr (cdr V995))) (null? (cdr (cdr (cdr V995))))))))))))) (cons (cons (if (assert-boolean (kl:value (quote shen.*occurs*))) (quote unify!) (quote unify)) (cdr (car (cdr V995)))) (kl:shen.cf_help (car (cdr (cdr V995)))))) (#t V995))) (export shen.cf_help) (quote shen.cf_help))
(begin (register-function-arity (quote occurs-check) 1) (define (kl:occurs-check V1001) (cond ((eq? (quote +) V1001) (kl:set (quote shen.*occurs*) #t)) ((eq? (quote -) V1001) (kl:set (quote shen.*occurs*) #f)) (#t (simple-error "occurs-check expects + or -\n")))) (export occurs-check) (quote occurs-check))
(begin (register-function-arity (quote shen.aum) 2) (define (kl:shen.aum V1004 V1005) (cond ((and (pair? V1004) (and (pair? (car V1004)) (and (pair? (cdr V1004)) (and (eq? (quote :-) (car (cdr V1004))) (and (pair? (cdr (cdr V1004))) (null? (cdr (cdr (cdr V1004))))))))) (let ((MuApplication (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car V1004)) (cons (kl:shen.continuation_call (cdr (car V1004)) (car (cdr (cdr V1004)))) (quote ())))) V1005))) (kl:shen.mu_reduction MuApplication (quote +)))) (#t (kl:shen.f_error (quote shen.aum))))) (export shen.aum) (quote shen.aum))
(begin (register-function-arity (quote shen.continuation_call) 2) (define (kl:shen.continuation_call V1008 V1009) (let ((VTerms (cons (quote ProcessN) (kl:shen.extract_vars V1008)))) (let ((VBody (kl:shen.extract_vars V1009))) (let ((Free (kl:remove (quote Throwcontrol) (kl:difference VBody VTerms)))) (kl:shen.cc_help Free V1009))))) (export shen.continuation_call) (quote shen.continuation_call))
(begin (register-function-arity (quote remove) 2) (define (kl:remove V1012 V1013) (kl:shen.remove-h V1012 V1013 (quote ()))) (export remove) (quote remove))
(begin (register-function-arity (quote shen.remove-h) 3) (define (kl:shen.remove-h V1020 V1021 V1022) (cond ((null? V1021) (kl:reverse V1022)) ((and (pair? V1021) (kl:= (car V1021) V1020)) (kl:shen.remove-h (car V1021) (cdr V1021) V1022)) ((pair? V1021) (kl:shen.remove-h V1020 (cdr V1021) (cons (car V1021) V1022))) (#t (kl:shen.f_error (quote shen.remove-h))))) (export shen.remove-h) (quote shen.remove-h))
(begin (register-function-arity (quote shen.cc_help) 2) (define (kl:shen.cc_help V1025 V1026) (cond ((and (null? V1025) (null? V1026)) (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ()))))) ((null? V1026) (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1025 (cons (quote and) (cons (quote shen.then) (cons (cons (quote shen.pop) (cons (quote shen.the) (cons (quote shen.stack) (quote ())))) (quote ())))))))))) ((null? V1025) (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1026 (quote ())))))) (#t (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons V1025 (cons (quote and) (cons (quote shen.then) (cons (cons (quote call) (cons (quote shen.the) (cons (quote shen.continuation) (cons V1026 (quote ()))))) (quote ())))))))))))) (export shen.cc_help) (quote shen.cc_help))
(begin (register-function-arity (quote shen.make_mu_application) 2) (define (kl:shen.make_mu_application V1029 V1030) (cond ((and (pair? V1029) (and (eq? (quote shen.mu) (car V1029)) (and (pair? (cdr V1029)) (and (null? (car (cdr V1029))) (and (pair? (cdr (cdr V1029))) (and (null? (cdr (cdr (cdr V1029)))) (null? V1030))))))) (car (cdr (cdr V1029)))) ((and (pair? V1029) (and (eq? (quote shen.mu) (car V1029)) (and (pair? (cdr V1029)) (and (pair? (car (cdr V1029))) (and (pair? (cdr (cdr V1029))) (and (null? (cdr (cdr (cdr V1029)))) (pair? V1030))))))) (cons (cons (quote shen.mu) (cons (car (car (cdr V1029))) (cons (kl:shen.make_mu_application (cons (quote shen.mu) (cons (cdr (car (cdr V1029))) (cdr (cdr V1029)))) (cdr V1030)) (quote ())))) (cons (car V1030) (quote ())))) (#t (kl:shen.f_error (quote shen.make_mu_application))))) (export shen.make_mu_application) (quote shen.make_mu_application))
(begin (register-function-arity (quote shen.mu_reduction) 2) (define (kl:shen.mu_reduction V1039 V1040) (cond ((and (pair? V1039) (and (pair? (car V1039)) (and (eq? (quote shen.mu) (car (car V1039))) (and (pair? (cdr (car V1039))) (and (pair? (car (cdr (car V1039)))) (and (eq? (quote mode) (car (car (cdr (car V1039))))) (and (pair? (cdr (car (cdr (car V1039))))) (and (pair? (cdr (cdr (car (cdr (car V1039)))))) (and (null? (cdr (cdr (cdr (car (cdr (car V1039))))))) (and (pair? (cdr (cdr (car V1039)))) (and (null? (cdr (cdr (cdr (car V1039))))) (and (pair? (cdr V1039)) (null? (cdr (cdr V1039))))))))))))))) (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (cdr (car (cdr (car V1039))))) (cdr (cdr (car V1039))))) (cdr V1039)) (car (cdr (cdr (car (cdr (car V1039)))))))) ((and (pair? V1039) (and (pair? (car V1039)) (and (eq? (quote shen.mu) (car (car V1039))) (and (pair? (cdr (car V1039))) (and (pair? (cdr (cdr (car V1039)))) (and (null? (cdr (cdr (cdr (car V1039))))) (and (pair? (cdr V1039)) (and (null? (cdr (cdr V1039))) (eq? (quote _) (car (cdr (car V1039)))))))))))) (kl:shen.mu_reduction (car (cdr (cdr (car V1039)))) V1040)) ((and (pair? V1039) (and (pair? (car V1039)) (and (eq? (quote shen.mu) (car (car V1039))) (and (pair? (cdr (car V1039))) (and (pair? (cdr (cdr (car V1039)))) (and (null? (cdr (cdr (cdr (car V1039))))) (and (pair? (cdr V1039)) (and (null? (cdr (cdr V1039))) (assert-boolean (kl:shen.ephemeral_variable? (car (cdr (car V1039))) (car (cdr V1039)))))))))))) (kl:subst (car (cdr V1039)) (car (cdr (car V1039))) (kl:shen.mu_reduction (car (cdr (cdr (car V1039)))) V1040))) ((and (pair? V1039) (and (pair? (car V1039)) (and (eq? (quote shen.mu) (car (car V1039))) (and (pair? (cdr (car V1039))) (and (pair? (cdr (cdr (car V1039)))) (and (null? (cdr (cdr (cdr (car V1039))))) (and (pair? (cdr V1039)) (and (null? (cdr (cdr V1039))) (kl:variable? (car (cdr (car V1039)))))))))))) (cons (quote let) (cons (car (cdr (car V1039))) (cons (quote shen.be) (cons (car (cdr V1039)) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1039)))) V1040) (quote ())))))))) ((and (pair? V1039) (and (pair? (car V1039)) (and (eq? (quote shen.mu) (car (car V1039))) (and (pair? (cdr (car V1039))) (and (pair? (cdr (cdr (car V1039)))) (and (null? (cdr (cdr (cdr (car V1039))))) (and (pair? (cdr V1039)) (and (null? (cdr (cdr V1039))) (and (eq? (quote -) V1040) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1039)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1039))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1039))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1039)))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1039) (and (pair? (car V1039)) (and (eq? (quote shen.mu) (car (car V1039))) (and (pair? (cdr (car V1039))) (and (pair? (cdr (cdr (car V1039)))) (and (null? (cdr (cdr (cdr (car V1039))))) (and (pair? (cdr V1039)) (and (null? (cdr (cdr V1039))) (and (eq? (quote +) V1040) (assert-boolean (kl:shen.prolog_constant? (car (cdr (car V1039)))))))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1039))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote identical) (cons (quote shen.to) (cons (car (cdr (car V1039))) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1039)))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (car (cdr (car V1039))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1039)))) (quote +)) (quote ()))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) ((and (pair? V1039) (and (pair? (car V1039)) (and (eq? (quote shen.mu) (car (car V1039))) (and (pair? (cdr (car V1039))) (and (pair? (car (cdr (car V1039)))) (and (pair? (cdr (cdr (car V1039)))) (and (null? (cdr (cdr (cdr (car V1039))))) (and (pair? (cdr V1039)) (and (null? (cdr (cdr V1039))) (eq? (quote -) V1040)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1039))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1039)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1039)))) (cdr (cdr (car V1039))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote -)) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))))) ((and (pair? V1039) (and (pair? (car V1039)) (and (eq? (quote shen.mu) (car (car V1039))) (and (pair? (cdr (car V1039))) (and (pair? (car (cdr (car V1039)))) (and (pair? (cdr (cdr (car V1039)))) (and (null? (cdr (cdr (cdr (car V1039))))) (and (pair? (cdr V1039)) (and (null? (cdr (cdr V1039))) (eq? (quote +) V1040)))))))))) (let ((Z (kl:gensym (quote V)))) (cons (quote let) (cons Z (cons (quote shen.be) (cons (cons (quote shen.the) (cons (quote shen.result) (cons (quote shen.of) (cons (quote shen.dereferencing) (cdr V1039))))) (cons (quote in) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.non-empty) (cons (quote list) (quote ())))))) (cons (quote shen.then) (cons (kl:shen.mu_reduction (cons (cons (quote shen.mu) (cons (car (car (cdr (car V1039)))) (cons (cons (cons (quote shen.mu) (cons (cdr (car (cdr (car V1039)))) (cdr (cdr (car V1039))))) (cons (cons (quote shen.the) (cons (quote tail) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote ())))) (cons (cons (quote shen.the) (cons (quote head) (cons (quote shen.of) (cons Z (quote ()))))) (quote ()))) (quote +)) (cons (quote shen.else) (cons (cons (quote if) (cons (cons Z (cons (quote is) (cons (quote shen.a) (cons (quote shen.variable) (quote ()))))) (cons (quote shen.then) (cons (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (kl:shen.extract_vars (car (cdr (car V1039)))) (cons (quote and) (cons (quote shen.then) (cons (cons (quote bind) (cons Z (cons (quote shen.to) (cons (kl:shen.rcons_form (kl:shen.remove_modes (car (cdr (car V1039))))) (cons (quote in) (cons (kl:shen.mu_reduction (car (cdr (cdr (car V1039)))) (quote +)) (quote ()))))))) (quote ()))))))))) (cons (quote shen.else) (cons (quote shen.failed!) (quote ()))))))) (quote ()))))))) (quote ()))))))))) (#t V1039))) (export shen.mu_reduction) (quote shen.mu_reduction))
(begin (register-function-arity (quote shen.rcons_form) 1) (define (kl:shen.rcons_form V1042) (cond ((pair? V1042) (cons (quote cons) (cons (kl:shen.rcons_form (car V1042)) (cons (kl:shen.rcons_form (cdr V1042)) (quote ()))))) (#t V1042))) (export shen.rcons_form) (quote shen.rcons_form))
(begin (register-function-arity (quote shen.remove_modes) 1) (define (kl:shen.remove_modes V1044) (cond ((and (pair? V1044) (and (eq? (quote mode) (car V1044)) (and (pair? (cdr V1044)) (and (pair? (cdr (cdr V1044))) (and (eq? (quote +) (car (cdr (cdr V1044)))) (null? (cdr (cdr (cdr V1044))))))))) (kl:shen.remove_modes (car (cdr V1044)))) ((and (pair? V1044) (and (eq? (quote mode) (car V1044)) (and (pair? (cdr V1044)) (and (pair? (cdr (cdr V1044))) (and (eq? (quote -) (car (cdr (cdr V1044)))) (null? (cdr (cdr (cdr V1044))))))))) (kl:shen.remove_modes (car (cdr V1044)))) ((pair? V1044) (cons (kl:shen.remove_modes (car V1044)) (kl:shen.remove_modes (cdr V1044)))) (#t V1044))) (export shen.remove_modes) (quote shen.remove_modes))
(begin (register-function-arity (quote shen.ephemeral_variable?) 2) (define (kl:shen.ephemeral_variable? V1047 V1048) (and (kl:variable? V1047) (kl:variable? V1048))) (export shen.ephemeral_variable?) (quote shen.ephemeral_variable?))
(begin (register-function-arity (quote shen.prolog_constant?) 1) (define (kl:shen.prolog_constant? V1058) (cond ((pair? V1058) #f) (#t #t))) (export shen.prolog_constant?) (quote shen.prolog_constant?))
(begin (register-function-arity (quote shen.aum_to_shen) 1) (define (kl:shen.aum_to_shen V1060) (cond ((and (pair? V1060) (and (eq? (quote let) (car V1060)) (and (pair? (cdr V1060)) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.be) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr (cdr V1060))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1060)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1060)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))))))))))) (cons (quote let) (cons (car (cdr V1060)) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1060))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1060))))))) (quote ())))))) ((and (pair? V1060) (and (eq? (quote shen.the) (car V1060)) (and (pair? (cdr V1060)) (and (eq? (quote shen.result) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.of) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (eq? (quote shen.dereferencing) (car (cdr (cdr (cdr V1060))))) (and (pair? (cdr (cdr (cdr (cdr V1060))))) (null? (cdr (cdr (cdr (cdr (cdr V1060))))))))))))))) (cons (quote shen.lazyderef) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr V1060)))))) (cons (quote ProcessN) (quote ()))))) ((and (pair? V1060) (and (eq? (quote if) (car V1060)) (and (pair? (cdr V1060)) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.then) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr (cdr V1060))))) (and (eq? (quote shen.else) (car (cdr (cdr (cdr (cdr V1060)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1060)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))))))))))) (cons (quote if) (cons (kl:shen.aum_to_shen (car (cdr V1060))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr V1060))))) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1060))))))) (quote ())))))) ((and (pair? V1060) (and (pair? (cdr V1060)) (and (eq? (quote is) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.a) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (eq? (quote shen.variable) (car (cdr (cdr (cdr V1060))))) (null? (cdr (cdr (cdr (cdr V1060)))))))))))) (cons (quote shen.pvar?) (cons (car V1060) (quote ())))) ((and (pair? V1060) (and (pair? (cdr V1060)) (and (eq? (quote is) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.a) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (eq? (quote shen.non-empty) (car (cdr (cdr (cdr V1060))))) (and (pair? (cdr (cdr (cdr (cdr V1060))))) (and (eq? (quote list) (car (cdr (cdr (cdr (cdr V1060)))))) (null? (cdr (cdr (cdr (cdr (cdr V1060))))))))))))))) (cons (quote cons?) (cons (car V1060) (quote ())))) ((and (pair? V1060) (and (eq? (quote shen.rename) (car V1060)) (and (pair? (cdr V1060)) (and (eq? (quote shen.the) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.variables) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1060))))) (and (pair? (cdr (cdr (cdr (cdr V1060))))) (and (null? (car (cdr (cdr (cdr (cdr V1060)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1060)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1060))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1060))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))))))))))))))))))) (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))))) ((and (pair? V1060) (and (eq? (quote shen.rename) (car V1060)) (and (pair? (cdr V1060)) (and (eq? (quote shen.the) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.variables) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (eq? (quote in) (car (cdr (cdr (cdr V1060))))) (and (pair? (cdr (cdr (cdr (cdr V1060))))) (and (pair? (car (cdr (cdr (cdr (cdr V1060)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1060)))))) (and (eq? (quote and) (car (cdr (cdr (cdr (cdr (cdr V1060))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr V1060))))))) (and (eq? (quote shen.then) (car (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))) (and (pair? (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))))))))))))))))))) (cons (quote let) (cons (car (car (cdr (cdr (cdr (cdr V1060)))))) (cons (cons (quote shen.newpv) (cons (quote ProcessN) (quote ()))) (cons (kl:shen.aum_to_shen (cons (quote shen.rename) (cons (quote shen.the) (cons (quote shen.variables) (cons (quote in) (cons (cdr (car (cdr (cdr (cdr (cdr V1060)))))) (cdr (cdr (cdr (cdr (cdr V1060))))))))))) (quote ())))))) ((and (pair? V1060) (and (eq? (quote bind) (car V1060)) (and (pair? (cdr V1060)) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.to) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr (cdr V1060))))) (and (eq? (quote in) (car (cdr (cdr (cdr (cdr V1060)))))) (and (pair? (cdr (cdr (cdr (cdr (cdr V1060)))))) (null? (cdr (cdr (cdr (cdr (cdr (cdr V1060)))))))))))))))) (cons (quote do) (cons (cons (quote shen.bindv) (cons (car (cdr V1060)) (cons (kl:shen.chwild (car (cdr (cdr (cdr V1060))))) (cons (quote ProcessN) (quote ()))))) (cons (cons (quote let) (cons (quote Result) (cons (kl:shen.aum_to_shen (car (cdr (cdr (cdr (cdr (cdr V1060))))))) (cons (cons (quote do) (cons (cons (quote shen.unbindv) (cons (car (cdr V1060)) (cons (quote ProcessN) (quote ())))) (cons (quote Result) (quote ())))) (quote ()))))) (quote ()))))) ((and (pair? V1060) (and (pair? (cdr V1060)) (and (eq? (quote is) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote identical) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (and (eq? (quote shen.to) (car (cdr (cdr (cdr V1060))))) (and (pair? (cdr (cdr (cdr (cdr V1060))))) (null? (cdr (cdr (cdr (cdr (cdr V1060)))))))))))))) (cons (quote =) (cons (car (cdr (cdr (cdr (cdr V1060))))) (cons (car V1060) (quote ()))))) ((eq? (quote shen.failed!) V1060) #f) ((and (pair? V1060) (and (eq? (quote shen.the) (car V1060)) (and (pair? (cdr V1060)) (and (eq? (quote head) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.of) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (null? (cdr (cdr (cdr (cdr V1060)))))))))))) (cons (quote hd) (cdr (cdr (cdr V1060))))) ((and (pair? V1060) (and (eq? (quote shen.the) (car V1060)) (and (pair? (cdr V1060)) (and (eq? (quote tail) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.of) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (null? (cdr (cdr (cdr (cdr V1060)))))))))))) (cons (quote tl) (cdr (cdr (cdr V1060))))) ((and (pair? V1060) (and (eq? (quote shen.pop) (car V1060)) (and (pair? (cdr V1060)) (and (eq? (quote shen.the) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.stack) (car (cdr (cdr V1060)))) (null? (cdr (cdr (cdr V1060)))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (cons (quote thaw) (cons (quote Continuation) (quote ()))) (quote ()))))) ((and (pair? V1060) (and (eq? (quote call) (car V1060)) (and (pair? (cdr V1060)) (and (eq? (quote shen.the) (car (cdr V1060))) (and (pair? (cdr (cdr V1060))) (and (eq? (quote shen.continuation) (car (cdr (cdr V1060)))) (and (pair? (cdr (cdr (cdr V1060)))) (null? (cdr (cdr (cdr (cdr V1060)))))))))))) (cons (quote do) (cons (cons (quote shen.incinfs) (quote ())) (cons (kl:shen.call_the_continuation (kl:shen.chwild (car (cdr (cdr (cdr V1060))))) (quote ProcessN) (quote Continuation)) (quote ()))))) (#t V1060))) (export shen.aum_to_shen) (quote shen.aum_to_shen))
(begin (register-function-arity (quote shen.chwild) 1) (define (kl:shen.chwild V1062) (cond ((eq? V1062 (quote _)) (cons (quote shen.newpv) (cons (quote ProcessN) (quote ())))) ((pair? V1062) (kl:map (lambda (Z) (kl:shen.chwild Z)) V1062)) (#t V1062))) (export shen.chwild) (quote shen.chwild))
(begin (register-function-arity (quote shen.newpv) 1) (define (kl:shen.newpv V1064) (let ((Count+1 (+ (vector-ref (kl:value (quote shen.*varcounter*)) V1064) 1))) (let ((IncVar (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V1064 Count+1) _tmp))) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1064))) (let ((ResizeVectorIfNeeded (if (kl:= Count+1 (kl:limit Vector)) (kl:shen.resizeprocessvector V1064 Count+1) (quote shen.skip)))) (kl:shen.mk-pvar Count+1)))))) (export shen.newpv) (quote shen.newpv))
(begin (register-function-arity (quote shen.resizeprocessvector) 2) (define (kl:shen.resizeprocessvector V1067 V1068) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1067))) (let ((BigVector (kl:shen.resize-vector Vector (+ V1068 V1068) (quote shen.-null-)))) (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V1067 BigVector) _tmp)))) (export shen.resizeprocessvector) (quote shen.resizeprocessvector))
(begin (register-function-arity (quote shen.resize-vector) 3) (define (kl:shen.resize-vector V1072 V1073 V1074) (let ((BigVector (let ((_tmp (make-vector (+ 1 V1073) (quote (quote shen.fail!))))) (vector-set! _tmp 0 V1073) _tmp))) (kl:shen.copy-vector V1072 BigVector (kl:limit V1072) V1073 V1074))) (export shen.resize-vector) (quote shen.resize-vector))
(begin (register-function-arity (quote shen.copy-vector) 5) (define (kl:shen.copy-vector V1080 V1081 V1082 V1083 V1084) (kl:shen.copy-vector-stage-2 (+ 1 V1082) (+ V1083 1) V1084 (kl:shen.copy-vector-stage-1 1 V1080 V1081 (+ 1 V1082)))) (export shen.copy-vector) (quote shen.copy-vector))
(begin (register-function-arity (quote shen.copy-vector-stage-1) 4) (define (kl:shen.copy-vector-stage-1 V1092 V1093 V1094 V1095) (cond ((kl:= V1095 V1092) V1094) (#t (kl:shen.copy-vector-stage-1 (+ 1 V1092) V1093 (let ((_tmp V1094)) (vector-set! _tmp V1092 (vector-ref V1093 V1092)) _tmp) V1095)))) (export shen.copy-vector-stage-1) (quote shen.copy-vector-stage-1))
(begin (register-function-arity (quote shen.copy-vector-stage-2) 4) (define (kl:shen.copy-vector-stage-2 V1103 V1104 V1105 V1106) (cond ((kl:= V1104 V1103) V1106) (#t (kl:shen.copy-vector-stage-2 (+ V1103 1) V1104 V1105 (let ((_tmp V1106)) (vector-set! _tmp V1103 V1105) _tmp))))) (export shen.copy-vector-stage-2) (quote shen.copy-vector-stage-2))
(begin (register-function-arity (quote shen.mk-pvar) 1) (define (kl:shen.mk-pvar V1108) (let ((_tmp (let ((_tmp (make-vector 2 (quote (quote shen.fail!))))) (vector-set! _tmp 0 (quote shen.pvar)) _tmp))) (vector-set! _tmp 1 V1108) _tmp)) (export shen.mk-pvar) (quote shen.mk-pvar))
(begin (register-function-arity (quote shen.pvar?) 1) (define (kl:shen.pvar? V1110) (and (vector? V1110) (eq? (guard (lambda (E) (quote shen.not-pvar)) (vector-ref V1110 0)) (quote shen.pvar)))) (export shen.pvar?) (quote shen.pvar?))
(begin (register-function-arity (quote shen.bindv) 3) (define (kl:shen.bindv V1114 V1115 V1116) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1116))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1114 1) V1115) _tmp))) (export shen.bindv) (quote shen.bindv))
(begin (register-function-arity (quote shen.unbindv) 2) (define (kl:shen.unbindv V1119 V1120) (let ((Vector (vector-ref (kl:value (quote shen.*prologvectors*)) V1120))) (let ((_tmp Vector)) (vector-set! _tmp (vector-ref V1119 1) (quote shen.-null-)) _tmp))) (export shen.unbindv) (quote shen.unbindv))
(begin (register-function-arity (quote shen.incinfs) 0) (define (kl:shen.incinfs) (kl:set (quote shen.*infs*) (+ 1 (kl:value (quote shen.*infs*))))) (export shen.incinfs) (quote shen.incinfs))
(begin (register-function-arity (quote shen.call_the_continuation) 3) (define (kl:shen.call_the_continuation V1124 V1125 V1126) (cond ((and (pair? V1124) (and (pair? (car V1124)) (null? (cdr V1124)))) (cons (car (car V1124)) (kl:append (cdr (car V1124)) (cons V1125 (cons V1126 (quote ())))))) ((and (pair? V1124) (pair? (car V1124))) (let ((NewContinuation (kl:shen.newcontinuation (cdr V1124) V1125 V1126))) (cons (car (car V1124)) (kl:append (cdr (car V1124)) (cons V1125 (cons NewContinuation (quote ()))))))) (#t (kl:shen.f_error (quote shen.call_the_continuation))))) (export shen.call_the_continuation) (quote shen.call_the_continuation))
(begin (register-function-arity (quote shen.newcontinuation) 3) (define (kl:shen.newcontinuation V1130 V1131 V1132) (cond ((null? V1130) V1132) ((and (pair? V1130) (pair? (car V1130))) (cons (quote freeze) (cons (cons (car (car V1130)) (kl:append (cdr (car V1130)) (cons V1131 (cons (kl:shen.newcontinuation (cdr V1130) V1131 V1132) (quote ()))))) (quote ())))) (#t (kl:shen.f_error (quote shen.newcontinuation))))) (export shen.newcontinuation) (quote shen.newcontinuation))
(begin (register-function-arity (quote return) 3) (define (kl:return V1140 V1141 V1142) (kl:shen.deref V1140 V1141)) (export return) (quote return))
(begin (register-function-arity (quote shen.measure&return) 3) (define (kl:shen.measure&return V1150 V1151 V1152) (begin (kl:shen.prhush (kl:shen.app (kl:value (quote shen.*infs*)) " inferences\n" (quote shen.a)) (kl:stoutput)) (kl:shen.deref V1150 V1151))) (export shen.measure&return) (quote shen.measure&return))
(begin (register-function-arity (quote unify) 4) (define (kl:unify V1157 V1158 V1159 V1160) (kl:shen.lzy= (kl:shen.lazyderef V1157 V1159) (kl:shen.lazyderef V1158 V1159) V1159 V1160)) (export unify) (quote unify))
(begin (register-function-arity (quote shen.lzy=) 4) (define (kl:shen.lzy= V1182 V1183 V1184 V1185) (cond ((kl:= V1183 V1182) (kl:thaw V1185)) ((kl:shen.pvar? V1182) (kl:bind V1182 V1183 V1184 V1185)) ((kl:shen.pvar? V1183) (kl:bind V1183 V1182 V1184 V1185)) ((and (pair? V1182) (pair? V1183)) (kl:shen.lzy= (kl:shen.lazyderef (car V1182) V1184) (kl:shen.lazyderef (car V1183) V1184) V1184 (lambda () (kl:shen.lzy= (kl:shen.lazyderef (cdr V1182) V1184) (kl:shen.lazyderef (cdr V1183) V1184) V1184 V1185)))) (#t #f))) (export shen.lzy=) (quote shen.lzy=))
(begin (register-function-arity (quote shen.deref) 2) (define (kl:shen.deref V1188 V1189) (cond ((pair? V1188) (cons (kl:shen.deref (car V1188) V1189) (kl:shen.deref (cdr V1188) V1189))) (#t (if (kl:shen.pvar? V1188) (let ((Value (kl:shen.valvector V1188 V1189))) (if (eq? Value (quote shen.-null-)) V1188 (kl:shen.deref Value V1189))) V1188)))) (export shen.deref) (quote shen.deref))
(begin (register-function-arity (quote shen.lazyderef) 2) (define (kl:shen.lazyderef V1192 V1193) (if (kl:shen.pvar? V1192) (let ((Value (kl:shen.valvector V1192 V1193))) (if (eq? Value (quote shen.-null-)) V1192 (kl:shen.lazyderef Value V1193))) V1192)) (export shen.lazyderef) (quote shen.lazyderef))
(begin (register-function-arity (quote shen.valvector) 2) (define (kl:shen.valvector V1196 V1197) (vector-ref (vector-ref (kl:value (quote shen.*prologvectors*)) V1197) (vector-ref V1196 1))) (export shen.valvector) (quote shen.valvector))
(begin (register-function-arity (quote unify!) 4) (define (kl:unify! V1202 V1203 V1204 V1205) (kl:shen.lzy=! (kl:shen.lazyderef V1202 V1204) (kl:shen.lazyderef V1203 V1204) V1204 V1205)) (export unify!) (quote unify!))
(begin (register-function-arity (quote shen.lzy=!) 4) (define (kl:shen.lzy=! V1227 V1228 V1229 V1230) (cond ((kl:= V1228 V1227) (kl:thaw V1230)) ((and (kl:shen.pvar? V1227) (kl:not (kl:shen.occurs? V1227 (kl:shen.deref V1228 V1229)))) (kl:bind V1227 V1228 V1229 V1230)) ((and (kl:shen.pvar? V1228) (kl:not (kl:shen.occurs? V1228 (kl:shen.deref V1227 V1229)))) (kl:bind V1228 V1227 V1229 V1230)) ((and (pair? V1227) (pair? V1228)) (kl:shen.lzy=! (kl:shen.lazyderef (car V1227) V1229) (kl:shen.lazyderef (car V1228) V1229) V1229 (lambda () (kl:shen.lzy=! (kl:shen.lazyderef (cdr V1227) V1229) (kl:shen.lazyderef (cdr V1228) V1229) V1229 V1230)))) (#t #f))) (export shen.lzy=!) (quote shen.lzy=!))
(begin (register-function-arity (quote shen.occurs?) 2) (define (kl:shen.occurs? V1242 V1243) (cond ((kl:= V1243 V1242) #t) ((pair? V1243) (or (assert-boolean (kl:shen.occurs? V1242 (car V1243))) (assert-boolean (kl:shen.occurs? V1242 (cdr V1243))))) (#t #f))) (export shen.occurs?) (quote shen.occurs?))
(begin (register-function-arity (quote identical) 4) (define (kl:identical V1248 V1249 V1250 V1251) (kl:shen.lzy== (kl:shen.lazyderef V1248 V1250) (kl:shen.lazyderef V1249 V1250) V1250 V1251)) (export identical) (quote identical))
(begin (register-function-arity (quote shen.lzy==) 4) (define (kl:shen.lzy== V1273 V1274 V1275 V1276) (cond ((kl:= V1274 V1273) (kl:thaw V1276)) ((and (pair? V1273) (pair? V1274)) (kl:shen.lzy== (kl:shen.lazyderef (car V1273) V1275) (kl:shen.lazyderef (car V1274) V1275) V1275 (lambda () (kl:shen.lzy== (cdr V1273) (cdr V1274) V1275 V1276)))) (#t #f))) (export shen.lzy==) (quote shen.lzy==))
(begin (register-function-arity (quote shen.pvar) 1) (define (kl:shen.pvar V1278) (string-append "Var" (kl:shen.app (vector-ref V1278 1) "" (quote shen.a)))) (export shen.pvar) (quote shen.pvar))
(begin (register-function-arity (quote bind) 4) (define (kl:bind V1283 V1284 V1285 V1286) (begin (kl:shen.bindv V1283 V1284 V1285) (let ((Result (kl:thaw V1286))) (begin (kl:shen.unbindv V1283 V1285) Result)))) (export bind) (quote bind))
(begin (register-function-arity (quote fwhen) 3) (define (kl:fwhen V1304 V1305 V1306) (cond ((kl:= #t V1304) (kl:thaw V1306)) ((kl:= #f V1304) #f) (#t (simple-error (string-append "fwhen expects a boolean: not " (kl:shen.app V1304 "%" (quote shen.s))))))) (export fwhen) (quote fwhen))
(begin (register-function-arity (quote call) 3) (define (kl:call V1322 V1323 V1324) (cond ((pair? V1322) (kl:shen.call-help (kl:function (kl:shen.lazyderef (car V1322) V1323)) (cdr V1322) V1323 V1324)) ((kl:shen.pvar? V1322) (kl:call (kl:shen.lazyderef V1322 V1323) V1323 V1324)) (#t #f))) (export call) (quote call))
(begin (register-function-arity (quote shen.call-help) 4) (define (kl:shen.call-help V1329 V1330 V1331 V1332) (cond ((null? V1330) ((V1329 V1331) V1332)) ((pair? V1330) (kl:shen.call-help (V1329 (car V1330)) (cdr V1330) V1331 V1332)) (#t (kl:shen.f_error (quote shen.call-help))))) (export shen.call-help) (quote shen.call-help))
(begin (register-function-arity (quote shen.intprolog) 1) (define (kl:shen.intprolog V1334) (cond ((and (pair? V1334) (pair? (car V1334))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (kl:shen.intprolog-help (car (car V1334)) (kl:shen.insert-prolog-variables (cons (cdr (car V1334)) (cons (cdr V1334) (quote ()))) ProcessN) ProcessN))) (#t (kl:shen.f_error (quote shen.intprolog))))) (export shen.intprolog) (quote shen.intprolog))
(begin (register-function-arity (quote shen.intprolog-help) 3) (define (kl:shen.intprolog-help V1338 V1339 V1340) (cond ((and (pair? V1339) (and (pair? (cdr V1339)) (null? (cdr (cdr V1339))))) (kl:shen.intprolog-help-help V1338 (car V1339) (car (cdr V1339)) V1340)) (#t (kl:shen.f_error (quote shen.intprolog-help))))) (export shen.intprolog-help) (quote shen.intprolog-help))
(begin (register-function-arity (quote shen.intprolog-help-help) 4) (define (kl:shen.intprolog-help-help V1345 V1346 V1347 V1348) (cond ((null? V1346) ((V1345 V1348) (lambda () (kl:shen.call-rest V1347 V1348)))) ((pair? V1346) (kl:shen.intprolog-help-help (V1345 (car V1346)) (cdr V1346) V1347 V1348)) (#t (kl:shen.f_error (quote shen.intprolog-help-help))))) (export shen.intprolog-help-help) (quote shen.intprolog-help-help))
(begin (register-function-arity (quote shen.call-rest) 2) (define (kl:shen.call-rest V1353 V1354) (cond ((null? V1353) #t) ((and (pair? V1353) (and (pair? (car V1353)) (pair? (cdr (car V1353))))) (kl:shen.call-rest (cons (cons ((car (car V1353)) (car (cdr (car V1353)))) (cdr (cdr (car V1353)))) (cdr V1353)) V1354)) ((and (pair? V1353) (and (pair? (car V1353)) (null? (cdr (car V1353))))) (((car (car V1353)) V1354) (lambda () (kl:shen.call-rest (cdr V1353) V1354)))) (#t (kl:shen.f_error (quote shen.call-rest))))) (export shen.call-rest) (quote shen.call-rest))
(begin (register-function-arity (quote shen.start-new-prolog-process) 0) (define (kl:shen.start-new-prolog-process) (let ((IncrementProcessCounter (kl:set (quote shen.*process-counter*) (+ 1 (kl:value (quote shen.*process-counter*)))))) (kl:shen.initialise-prolog IncrementProcessCounter))) (export shen.start-new-prolog-process) (quote shen.start-new-prolog-process))
(begin (register-function-arity (quote shen.insert-prolog-variables) 2) (define (kl:shen.insert-prolog-variables V1357 V1358) (kl:shen.insert-prolog-variables-help V1357 (kl:shen.flatten V1357) V1358)) (export shen.insert-prolog-variables) (quote shen.insert-prolog-variables))
(begin (register-function-arity (quote shen.insert-prolog-variables-help) 3) (define (kl:shen.insert-prolog-variables-help V1366 V1367 V1368) (cond ((null? V1367) V1366) ((and (pair? V1367) (kl:variable? (car V1367))) (let ((V (kl:shen.newpv V1368))) (let ((XV/Y (kl:subst V (car V1367) V1366))) (let ((Z-Y (kl:remove (car V1367) (cdr V1367)))) (kl:shen.insert-prolog-variables-help XV/Y Z-Y V1368))))) ((pair? V1367) (kl:shen.insert-prolog-variables-help V1366 (cdr V1367) V1368)) (#t (kl:shen.f_error (quote shen.insert-prolog-variables-help))))) (export shen.insert-prolog-variables-help) (quote shen.insert-prolog-variables-help))
(begin (register-function-arity (quote shen.initialise-prolog) 1) (define (kl:shen.initialise-prolog V1370) (let ((Vector (let ((_tmp (kl:value (quote shen.*prologvectors*)))) (vector-set! _tmp V1370 (kl:shen.fillvector (kl:vector 10) 1 10 (quote shen.-null-))) _tmp))) (let ((Counter (let ((_tmp (kl:value (quote shen.*varcounter*)))) (vector-set! _tmp V1370 1) _tmp))) V1370))) (export shen.initialise-prolog) (quote shen.initialise-prolog))

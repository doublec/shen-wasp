(module "compiled/yacc.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.yacc) 1) (define (kl:shen.yacc V4666) (cond ((and (pair? V4666) (and (eq? (quote defcc) (car V4666)) (pair? (cdr V4666)))) (kl:shen.yacc->shen (car (cdr V4666)) (cdr (cdr V4666)))) (#t (kl:shen.f_error (quote shen.yacc))))) (export shen.yacc) (quote shen.yacc))
(begin (register-function-arity (quote shen.yacc->shen) 2) (define (kl:shen.yacc->shen V4669 V4670) (let ((CCRules (kl:shen.split_cc_rules #t V4670 (quote ())))) (let ((CCBody (kl:map (lambda (X) (kl:shen.cc_body X)) CCRules))) (let ((YaccCases (kl:shen.yacc_cases CCBody))) (cons (quote define) (cons V4669 (cons (quote Stream) (cons (quote ->) (cons (kl:shen.kill-code YaccCases) (quote ())))))))))) (export shen.yacc->shen) (quote shen.yacc->shen))
(begin (register-function-arity (quote shen.kill-code) 1) (define (kl:shen.kill-code V4672) (cond ((> (kl:occurrences (quote kill) V4672) 0) (cons (quote trap-error) (cons V4672 (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote shen.analyse-kill) (cons (quote E) (quote ()))) (quote ())))) (quote ()))))) (#t V4672))) (export shen.kill-code) (quote shen.kill-code))
(begin (register-function-arity (quote kill) 0) (define (kl:kill) (simple-error "yacc kill")) (export kill) (quote kill))
(begin (register-function-arity (quote shen.analyse-kill) 1) (define (kl:shen.analyse-kill V4674) (let ((String (kl:error-to-string V4674))) (if (equal? String "yacc kill") (kl:fail) V4674))) (export shen.analyse-kill) (quote shen.analyse-kill))
(begin (register-function-arity (quote shen.split_cc_rules) 3) (define (kl:shen.split_cc_rules V4680 V4681 V4682) (cond ((and (null? V4681) (null? V4682)) (quote ())) ((null? V4681) (cons (kl:shen.split_cc_rule V4680 (kl:reverse V4682) (quote ())) (quote ()))) ((and (pair? V4681) (eq? (quote _waspvm_sc_) (car V4681))) (cons (kl:shen.split_cc_rule V4680 (kl:reverse V4682) (quote ())) (kl:shen.split_cc_rules V4680 (cdr V4681) (quote ())))) ((pair? V4681) (kl:shen.split_cc_rules V4680 (cdr V4681) (cons (car V4681) V4682))) (#t (kl:shen.f_error (quote shen.split_cc_rules))))) (export shen.split_cc_rules) (quote shen.split_cc_rules))
(begin (register-function-arity (quote shen.split_cc_rule) 3) (define (kl:shen.split_cc_rule V4690 V4691 V4692) (cond ((and (pair? V4691) (and (eq? (quote :=) (car V4691)) (and (pair? (cdr V4691)) (null? (cdr (cdr V4691)))))) (cons (kl:reverse V4692) (cdr V4691))) ((and (pair? V4691) (and (eq? (quote :=) (car V4691)) (and (pair? (cdr V4691)) (and (pair? (cdr (cdr V4691))) (and (eq? (quote where) (car (cdr (cdr V4691)))) (and (pair? (cdr (cdr (cdr V4691)))) (null? (cdr (cdr (cdr (cdr V4691))))))))))) (cons (kl:reverse V4692) (cons (cons (quote where) (cons (car (cdr (cdr (cdr V4691)))) (cons (car (cdr V4691)) (quote ())))) (quote ())))) ((null? V4691) (begin (kl:shen.semantic-completion-warning V4690 V4692) (kl:shen.split_cc_rule V4690 (cons (quote :=) (cons (kl:shen.default_semantics (kl:reverse V4692)) (quote ()))) V4692))) ((pair? V4691) (kl:shen.split_cc_rule V4690 (cdr V4691) (cons (car V4691) V4692))) (#t (kl:shen.f_error (quote shen.split_cc_rule))))) (export shen.split_cc_rule) (quote shen.split_cc_rule))
(begin (register-function-arity (quote shen.semantic-completion-warning) 2) (define (kl:shen.semantic-completion-warning V4703 V4704) (cond ((kl:= #t V4703) (begin (kl:shen.prhush "warning: " (kl:stoutput)) (begin (kl:shen.for-each (lambda (X) (kl:shen.prhush (kl:shen.app X " " (quote shen.a)) (kl:stoutput))) (kl:reverse V4704)) (kl:shen.prhush "has no semantics.\n" (kl:stoutput))))) (#t (quote shen.skip)))) (export shen.semantic-completion-warning) (quote shen.semantic-completion-warning))
(begin (register-function-arity (quote shen.default_semantics) 1) (define (kl:shen.default_semantics V4706) (cond ((null? V4706) (quote ())) ((and (pair? V4706) (and (null? (cdr V4706)) (assert-boolean (kl:shen.grammar_symbol? (car V4706))))) (car V4706)) ((and (pair? V4706) (assert-boolean (kl:shen.grammar_symbol? (car V4706)))) (cons (quote append) (cons (car V4706) (cons (kl:shen.default_semantics (cdr V4706)) (quote ()))))) ((pair? V4706) (cons (quote cons) (cons (car V4706) (cons (kl:shen.default_semantics (cdr V4706)) (quote ()))))) (#t (kl:shen.f_error (quote shen.default_semantics))))) (export shen.default_semantics) (quote shen.default_semantics))
(begin (register-function-arity (quote shen.grammar_symbol?) 1) (define (kl:shen.grammar_symbol? V4708) (and (kl:symbol? V4708) (assert-boolean (let ((Cs (kl:shen.strip-pathname (kl:explode V4708)))) (and (equal? (car Cs) "<") (equal? (car (kl:reverse Cs)) ">")))))) (export shen.grammar_symbol?) (quote shen.grammar_symbol?))
(begin (register-function-arity (quote shen.yacc_cases) 1) (define (kl:shen.yacc_cases V4710) (cond ((and (pair? V4710) (null? (cdr V4710))) (car V4710)) ((pair? V4710) (let ((P (quote YaccParse))) (cons (quote let) (cons P (cons (car V4710) (cons (cons (quote if) (cons (cons (quote =) (cons P (cons (cons (quote fail) (quote ())) (quote ())))) (cons (kl:shen.yacc_cases (cdr V4710)) (cons P (quote ()))))) (quote ()))))))) (#t (kl:shen.f_error (quote shen.yacc_cases))))) (export shen.yacc_cases) (quote shen.yacc_cases))
(begin (register-function-arity (quote shen.cc_body) 1) (define (kl:shen.cc_body V4712) (cond ((and (pair? V4712) (and (pair? (cdr V4712)) (null? (cdr (cdr V4712))))) (kl:shen.syntax (car V4712) (quote Stream) (car (cdr V4712)))) (#t (kl:shen.f_error (quote shen.cc_body))))) (export shen.cc_body) (quote shen.cc_body))
(begin (register-function-arity (quote shen.syntax) 3) (define (kl:shen.syntax V4716 V4717 V4718) (cond ((and (null? V4716) (and (pair? V4718) (and (eq? (quote where) (car V4718)) (and (pair? (cdr V4718)) (and (pair? (cdr (cdr V4718))) (null? (cdr (cdr (cdr V4718))))))))) (cons (quote if) (cons (kl:shen.semantics (car (cdr V4718))) (cons (cons (quote shen.pair) (cons (cons (quote hd) (cons V4717 (quote ()))) (cons (kl:shen.semantics (car (cdr (cdr V4718)))) (quote ())))) (cons (cons (quote fail) (quote ())) (quote ())))))) ((null? V4716) (cons (quote shen.pair) (cons (cons (quote hd) (cons V4717 (quote ()))) (cons (kl:shen.semantics V4718) (quote ()))))) ((pair? V4716) (if (assert-boolean (kl:shen.grammar_symbol? (car V4716))) (kl:shen.recursive_descent V4716 V4717 V4718) (if (kl:variable? (car V4716)) (kl:shen.variable-match V4716 V4717 V4718) (if (assert-boolean (kl:shen.jump_stream? (car V4716))) (kl:shen.jump_stream V4716 V4717 V4718) (if (assert-boolean (kl:shen.terminal? (car V4716))) (kl:shen.check_stream V4716 V4717 V4718) (if (pair? (car V4716)) (kl:shen.list-stream (kl:shen.decons (car V4716)) (cdr V4716) V4717 V4718) (simple-error (kl:shen.app (car V4716) " is not legal syntax\n" (quote shen.a))))))))) (#t (kl:shen.f_error (quote shen.syntax))))) (export shen.syntax) (quote shen.syntax))
(begin (register-function-arity (quote shen.list-stream) 4) (define (kl:shen.list-stream V4723 V4724 V4725 V4726) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4725 (quote ()))) (quote ()))) (cons (cons (quote cons?) (cons (cons (quote shen.hdhd) (cons V4725 (quote ()))) (quote ()))) (quote ())))))) (let ((Placeholder (kl:gensym (quote shen.place)))) (let ((RunOn (kl:shen.syntax V4724 (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V4725 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4725 (quote ()))) (quote ())))) V4726))) (let ((Action (kl:shen.insert-runon RunOn Placeholder (kl:shen.syntax V4723 (cons (quote shen.pair) (cons (cons (quote shen.hdhd) (cons V4725 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4725 (quote ()))) (quote ())))) Placeholder)))) (cons (quote if) (cons Test (cons Action (cons (cons (quote fail) (quote ())) (quote ())))))))))) (export shen.list-stream) (quote shen.list-stream))
(begin (register-function-arity (quote shen.decons) 1) (define (kl:shen.decons V4728) (cond ((and (pair? V4728) (and (eq? (quote cons) (car V4728)) (and (pair? (cdr V4728)) (and (pair? (cdr (cdr V4728))) (and (null? (car (cdr (cdr V4728)))) (null? (cdr (cdr (cdr V4728))))))))) (cons (car (cdr V4728)) (quote ()))) ((and (pair? V4728) (and (eq? (quote cons) (car V4728)) (and (pair? (cdr V4728)) (and (pair? (cdr (cdr V4728))) (null? (cdr (cdr (cdr V4728)))))))) (cons (car (cdr V4728)) (kl:shen.decons (car (cdr (cdr V4728)))))) (#t V4728))) (export shen.decons) (quote shen.decons))
(begin (register-function-arity (quote shen.insert-runon) 3) (define (kl:shen.insert-runon V4743 V4744 V4745) (cond ((and (pair? V4745) (and (eq? (quote shen.pair) (car V4745)) (and (pair? (cdr V4745)) (and (pair? (cdr (cdr V4745))) (and (null? (cdr (cdr (cdr V4745)))) (kl:= (car (cdr (cdr V4745))) V4744)))))) V4743) ((pair? V4745) (kl:map (lambda (Z) (kl:shen.insert-runon V4743 V4744 Z)) V4745)) (#t V4745))) (export shen.insert-runon) (quote shen.insert-runon))
(begin (register-function-arity (quote shen.strip-pathname) 1) (define (kl:shen.strip-pathname V4751) (cond ((kl:not (kl:element? "." V4751)) V4751) ((pair? V4751) (kl:shen.strip-pathname (cdr V4751))) (#t (kl:shen.f_error (quote shen.strip-pathname))))) (export shen.strip-pathname) (quote shen.strip-pathname))
(begin (register-function-arity (quote shen.recursive_descent) 3) (define (kl:shen.recursive_descent V4755 V4756 V4757) (cond ((pair? V4755) (let ((Test (cons (car V4755) (cons V4756 (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4755) (kl:concat (quote Parse_) (car V4755)) V4757))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote let) (cons (kl:concat (quote Parse_) (car V4755)) (cons Test (cons (cons (quote if) (cons (cons (quote not) (cons (cons (quote =) (cons (cons (quote fail) (quote ())) (cons (kl:concat (quote Parse_) (car V4755)) (quote ())))) (quote ()))) (cons Action (cons Else (quote ()))))) (quote ()))))))))) (#t (kl:shen.f_error (quote shen.recursive_descent))))) (export shen.recursive_descent) (quote shen.recursive_descent))
(begin (register-function-arity (quote shen.variable-match) 3) (define (kl:shen.variable-match V4761 V4762 V4763) (cond ((pair? V4761) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4762 (quote ()))) (quote ()))))) (let ((Action (cons (quote let) (cons (kl:concat (quote Parse_) (car V4761)) (cons (cons (quote shen.hdhd) (cons V4762 (quote ()))) (cons (kl:shen.syntax (cdr V4761) (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V4762 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4762 (quote ()))) (quote ())))) V4763) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.variable-match))))) (export shen.variable-match) (quote shen.variable-match))
(begin (register-function-arity (quote shen.terminal?) 1) (define (kl:shen.terminal? V4773) (cond ((pair? V4773) #f) ((kl:variable? V4773) #f) (#t #t))) (export shen.terminal?) (quote shen.terminal?))
(begin (register-function-arity (quote shen.jump_stream?) 1) (define (kl:shen.jump_stream? V4779) (cond ((eq? V4779 (quote _)) #t) (#t #f))) (export shen.jump_stream?) (quote shen.jump_stream?))
(begin (register-function-arity (quote shen.check_stream) 3) (define (kl:shen.check_stream V4783 V4784 V4785) (cond ((pair? V4783) (let ((Test (cons (quote and) (cons (cons (quote cons?) (cons (cons (quote hd) (cons V4784 (quote ()))) (quote ()))) (cons (cons (quote =) (cons (car V4783) (cons (cons (quote shen.hdhd) (cons V4784 (quote ()))) (quote ())))) (quote ())))))) (let ((NewStr (kl:gensym (quote NewStream)))) (let ((Action (cons (quote let) (cons NewStr (cons (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V4784 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4784 (quote ()))) (quote ())))) (cons (kl:shen.syntax (cdr V4783) NewStr V4785) (quote ()))))))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ())))))))))) (#t (kl:shen.f_error (quote shen.check_stream))))) (export shen.check_stream) (quote shen.check_stream))
(begin (register-function-arity (quote shen.jump_stream) 3) (define (kl:shen.jump_stream V4789 V4790 V4791) (cond ((pair? V4789) (let ((Test (cons (quote cons?) (cons (cons (quote hd) (cons V4790 (quote ()))) (quote ()))))) (let ((Action (kl:shen.syntax (cdr V4789) (cons (quote shen.pair) (cons (cons (quote shen.tlhd) (cons V4790 (quote ()))) (cons (cons (quote shen.hdtl) (cons V4790 (quote ()))) (quote ())))) V4791))) (let ((Else (cons (quote fail) (quote ())))) (cons (quote if) (cons Test (cons Action (cons Else (quote ()))))))))) (#t (kl:shen.f_error (quote shen.jump_stream))))) (export shen.jump_stream) (quote shen.jump_stream))
(begin (register-function-arity (quote shen.semantics) 1) (define (kl:shen.semantics V4793) (cond ((null? V4793) (quote ())) ((assert-boolean (kl:shen.grammar_symbol? V4793)) (cons (quote shen.hdtl) (cons (kl:concat (quote Parse_) V4793) (quote ())))) ((kl:variable? V4793) (kl:concat (quote Parse_) V4793)) ((pair? V4793) (kl:map (lambda (Z) (kl:shen.semantics Z)) V4793)) (#t V4793))) (export shen.semantics) (quote shen.semantics))
(begin (register-function-arity (quote shen.pair) 2) (define (kl:shen.pair V4796 V4797) (cons V4796 (cons V4797 (quote ())))) (export shen.pair) (quote shen.pair))
(begin (register-function-arity (quote shen.hdtl) 1) (define (kl:shen.hdtl V4799) (car (cdr V4799))) (export shen.hdtl) (quote shen.hdtl))
(begin (register-function-arity (quote shen.hdhd) 1) (define (kl:shen.hdhd V4801) (car (car V4801))) (export shen.hdhd) (quote shen.hdhd))
(begin (register-function-arity (quote shen.tlhd) 1) (define (kl:shen.tlhd V4803) (cdr (car V4803))) (export shen.tlhd) (quote shen.tlhd))
(begin (register-function-arity (quote shen.snd-or-fail) 1) (define (kl:shen.snd-or-fail V4811) (cond ((and (pair? V4811) (and (pair? (cdr V4811)) (null? (cdr (cdr V4811))))) (car (cdr V4811))) (#t (kl:fail)))) (export shen.snd-or-fail) (quote shen.snd-or-fail))
(begin (register-function-arity (quote fail) 0) (define (kl:fail) (quote shen.fail!)) (export fail) (quote fail))
(begin (register-function-arity (quote <!>) 1) (define (kl:<!> V4819) (cond ((and (pair? V4819) (and (pair? (cdr V4819)) (null? (cdr (cdr V4819))))) (cons (quote ()) (cons (car V4819) (quote ())))) (#t (kl:fail)))) (export <!>) (quote <!>))
(begin (register-function-arity (quote <e>) 1) (define (kl:<e> V4825) (cond ((and (pair? V4825) (and (pair? (cdr V4825)) (null? (cdr (cdr V4825))))) (cons (car V4825) (cons (quote ()) (quote ())))) (#t (kl:shen.f_error (quote <e>))))) (export <e>) (quote <e>))

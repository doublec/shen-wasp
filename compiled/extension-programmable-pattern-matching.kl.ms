(module "compiled/extension-programmable-pattern-matching.kl")
"Copyright (c) 2019 Bruno Deferrari.  All rights reserved.\nBSD 3-Clause License: http://opensource.org/licenses/BSD-3-Clause"
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.apply-pattern-handlers) 5) (define (kl:shen.x.programmable-pattern-matching.apply-pattern-handlers V5042 V5043 V5044 V5045 V5046) (cond ((null? V5042) (kl:fail)) (#t (let ((Freeze (lambda () (cond ((pair? V5042) (kl:shen.x.programmable-pattern-matching.apply-pattern-handlers (cdr V5042) V5043 V5044 V5045 V5046)) (#t (kl:shen.f_error (quote shen.x.programmable-pattern-matching.apply-pattern-handlers))))))) (if (pair? V5042) (let ((Result (((((car V5042) V5043) V5044) V5045) V5046))) (if (kl:= Result (kl:fail)) (kl:thaw Freeze) Result)) (kl:thaw Freeze)))))) (export shen.x.programmable-pattern-matching.apply-pattern-handlers) (quote shen.x.programmable-pattern-matching.apply-pattern-handlers))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.make-stack) 0) (define (kl:shen.x.programmable-pattern-matching.make-stack) (let ((_tmp (make-vector 1 (quote (quote shen.fail!))))) (vector-set! _tmp 0 (quote ())) _tmp)) (export shen.x.programmable-pattern-matching.make-stack) (quote shen.x.programmable-pattern-matching.make-stack))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.push) 2) (define (kl:shen.x.programmable-pattern-matching.push V5049 V5050) (let ((_tmp V5049)) (vector-set! _tmp 0 (cons V5050 (vector-ref V5049 0))) _tmp)) (export shen.x.programmable-pattern-matching.push) (quote shen.x.programmable-pattern-matching.push))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.pop-all) 1) (define (kl:shen.x.programmable-pattern-matching.pop-all V5052) (let ((Res (vector-ref V5052 0))) (let ((_ (let ((_tmp V5052)) (vector-set! _tmp 0 (quote ())) _tmp))) Res))) (export shen.x.programmable-pattern-matching.pop-all) (quote shen.x.programmable-pattern-matching.pop-all))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.compile-pattern) 3) (define (kl:shen.x.programmable-pattern-matching.compile-pattern V5056 V5057 V5058) (let ((VarsStack (kl:shen.x.programmable-pattern-matching.make-stack))) (let ((Self (quote Self_waspvm_dl__waspvm_dl_7907_waspvm_dl__waspvm_dl_))) (let ((AddTest (lambda (_) (quote shen.x.programmable-pattern-matching.ignored)))) (let ((Bind (lambda (Var) (lambda (_) (kl:shen.x.programmable-pattern-matching.push VarsStack Var))))) (let ((Result (kl:shen.x.programmable-pattern-matching.apply-pattern-handlers V5057 Self AddTest Bind V5056))) (if (kl:= Result (kl:fail)) (kl:thaw V5058) (kl:shen.x.programmable-pattern-matching.compile-pattern-h V5056 (kl:reverse (kl:shen.x.programmable-pattern-matching.pop-all VarsStack)))))))))) (export shen.x.programmable-pattern-matching.compile-pattern) (quote shen.x.programmable-pattern-matching.compile-pattern))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.compile-pattern-h) 2) (define (kl:shen.x.programmable-pattern-matching.compile-pattern-h V5061 V5062) (cond ((pair? V5061) (let ((Compile (lambda (X) (kl:shen.<pattern> X)))) (let ((Handler (lambda (E) (simple-error (string-append "failed to compile " (kl:shen.app E "" (quote shen.a))))))) (let ((NewArgs (kl:map (lambda (Arg) (if (kl:element? Arg V5062) (kl:compile Compile (cons Arg (quote ())) Handler) Arg)) (cdr V5061)))) (cons (car V5061) NewArgs))))) (#t (kl:shen.f_error (quote shen.x.programmable-pattern-matching.compile-pattern-h))))) (export shen.x.programmable-pattern-matching.compile-pattern-h) (quote shen.x.programmable-pattern-matching.compile-pattern-h))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.reduce) 2) (define (kl:shen.x.programmable-pattern-matching.reduce V5065 V5066) (cond ((and (pair? V5065) (and (pair? (car V5065)) (and (eq? (quote /.) (car (car V5065))) (and (pair? (cdr (car V5065))) (and (pair? (car (cdr (car V5065)))) (and (pair? (cdr (cdr (car V5065)))) (and (null? (cdr (cdr (cdr (car V5065))))) (and (pair? (cdr V5065)) (null? (cdr (cdr V5065))))))))))) (let ((SelectorStack (kl:shen.x.programmable-pattern-matching.make-stack))) (let ((AddTest (lambda (Expr) (kl:shen.add_test Expr)))) (let ((Bind (lambda (Var) (lambda (Expr) (kl:shen.x.programmable-pattern-matching.push SelectorStack (kl:_waspvm_at_p Var Expr)))))) (let ((Result (kl:shen.x.programmable-pattern-matching.apply-pattern-handlers V5066 (car (cdr V5065)) AddTest Bind (car (cdr (car V5065)))))) (let ((Vars+Sels (kl:reverse (kl:shen.x.programmable-pattern-matching.pop-all SelectorStack)))) (let ((Vars (kl:map (lambda (V5019) (kl:fst V5019)) Vars+Sels))) (let ((Selectors (kl:map (lambda (V5020) (kl:snd V5020)) Vars+Sels))) (let ((Abstraction (kl:shen.abstraction_build Vars (kl:shen.ebr (car (cdr V5065)) (car (cdr (car V5065))) (car (cdr (cdr (car V5065)))))))) (let ((Application (kl:shen.application_build Selectors Abstraction))) (kl:shen.reduce_help Application))))))))))) (#t (kl:shen.f_error (quote shen.x.programmable-pattern-matching.reduce))))) (export shen.x.programmable-pattern-matching.reduce) (quote shen.x.programmable-pattern-matching.reduce))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.initialise) 0) (define (kl:shen.x.programmable-pattern-matching.initialise) (begin (kl:set (quote shen.*custom-pattern-compiler*) (lambda (Arg) (lambda (OnFail) (kl:shen.x.programmable-pattern-matching.compile-pattern Arg (kl:value (quote shen.x.programmable-pattern-matching.*pattern-handlers*)) OnFail)))) (begin (kl:set (quote shen.*custom-pattern-reducer*) (lambda (Arg) (kl:shen.x.programmable-pattern-matching.reduce Arg (kl:value (quote shen.x.programmable-pattern-matching.*pattern-handlers*))))) (begin (kl:set (quote shen.x.programmable-pattern-matching.*pattern-handlers*) (quote ())) (begin (kl:set (quote shen.x.programmable-pattern-matching.*pattern-handlers-reg*) (quote ())) (quote shen.x.programmable-pattern-matching.done)))))) (export shen.x.programmable-pattern-matching.initialise) (quote shen.x.programmable-pattern-matching.initialise))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.register-handler) 1) (define (kl:shen.x.programmable-pattern-matching.register-handler V5068) (cond ((kl:element? V5068 (kl:value (quote shen.x.programmable-pattern-matching.*pattern-handlers-reg*))) V5068) (#t (begin (kl:set (quote shen.x.programmable-pattern-matching.*pattern-handlers-reg*) (cons V5068 (kl:value (quote shen.x.programmable-pattern-matching.*pattern-handlers-reg*)))) (begin (kl:set (quote shen.x.programmable-pattern-matching.*pattern-handlers*) (cons (kl:function V5068) (kl:value (quote shen.x.programmable-pattern-matching.*pattern-handlers*)))) V5068))))) (export shen.x.programmable-pattern-matching.register-handler) (quote shen.x.programmable-pattern-matching.register-handler))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.findpos) 2) (define (kl:shen.x.programmable-pattern-matching.findpos V5071 V5072) (guard (lambda (_) (simple-error (kl:shen.app V5071 " is not a pattern handler\n" (quote shen.a)))) (kl:shen.findpos V5071 V5072))) (export shen.x.programmable-pattern-matching.findpos) (quote shen.x.programmable-pattern-matching.findpos))
(begin (register-function-arity (quote shen.x.programmable-pattern-matching.unregister-handler) 1) (define (kl:shen.x.programmable-pattern-matching.unregister-handler V5074) (let ((Reg (kl:value (quote shen.x.programmable-pattern-matching.*pattern-handlers-reg*)))) (let ((Pos (kl:shen.x.programmable-pattern-matching.findpos V5074 Reg))) (let ((RemoveReg (kl:set (quote shen.x.programmable-pattern-matching.*pattern-handlers-reg*) (kl:remove V5074 Reg)))) (let ((RemoveFun (kl:set (quote shen.x.programmable-pattern-matching.*pattern-handlers*) (kl:shen.remove-nth Pos (kl:value (quote shen.x.programmable-pattern-matching.*pattern-handlers*)))))) V5074))))) (export shen.x.programmable-pattern-matching.unregister-handler) (quote shen.x.programmable-pattern-matching.unregister-handler))

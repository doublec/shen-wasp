(module "compiled/t-star.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.typecheck) 2) (define (kl:shen.typecheck V2673 V2674) (let ((Curry (kl:shen.curry V2673))) (let ((ProcessN (kl:shen.start-new-prolog-process))) (let ((Type (kl:shen.insert-prolog-variables (kl:shen.demodulate (kl:shen.curry-type V2674)) ProcessN))) (let ((Continuation (lambda () (kl:return Type ProcessN (quote shen.void))))) (kl:shen.t* (cons Curry (cons (quote :) (cons Type (quote ())))) (quote ()) ProcessN Continuation)))))) (export shen.typecheck) (quote shen.typecheck))
(begin (register-function-arity (quote shen.curry) 1) (define (kl:shen.curry V2676) (cond ((and (pair? V2676) (assert-boolean (kl:shen.special? (car V2676)))) (cons (car V2676) (kl:map (lambda (Y) (kl:shen.curry Y)) (cdr V2676)))) ((and (pair? V2676) (and (pair? (cdr V2676)) (assert-boolean (kl:shen.extraspecial? (car V2676))))) V2676) ((and (pair? V2676) (and (eq? (quote type) (car V2676)) (and (pair? (cdr V2676)) (and (pair? (cdr (cdr V2676))) (null? (cdr (cdr (cdr V2676)))))))) (cons (quote type) (cons (kl:shen.curry (car (cdr V2676))) (cdr (cdr V2676))))) ((and (pair? V2676) (and (pair? (cdr V2676)) (pair? (cdr (cdr V2676))))) (kl:shen.curry (cons (cons (car V2676) (cons (car (cdr V2676)) (quote ()))) (cdr (cdr V2676))))) ((and (pair? V2676) (and (pair? (cdr V2676)) (null? (cdr (cdr V2676))))) (cons (kl:shen.curry (car V2676)) (cons (kl:shen.curry (car (cdr V2676))) (quote ())))) (#t V2676))) (export shen.curry) (quote shen.curry))
(begin (register-function-arity (quote shen.special?) 1) (define (kl:shen.special? V2678) (kl:element? V2678 (kl:value (quote shen.*special*)))) (export shen.special?) (quote shen.special?))
(begin (register-function-arity (quote shen.extraspecial?) 1) (define (kl:shen.extraspecial? V2680) (kl:element? V2680 (kl:value (quote shen.*extraspecial*)))) (export shen.extraspecial?) (quote shen.extraspecial?))
(begin (register-function-arity (quote shen.t*) 4) (define (kl:shen.t* V2685 V2686 V2687 V2688) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((Error (kl:shen.newpv V2687))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.maxinfexceeded?) V2687 (lambda () (kl:bind Error (kl:shen.errormaxinfs) V2687 V2688))))))) (if (kl:= Case #f) (let ((Case (let ((V2665 (kl:shen.lazyderef V2685 V2687))) (if (eq? (quote fail) V2665) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2687 (lambda () (kl:shen.prolog-failure V2687 V2688)))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2666 (kl:shen.lazyderef V2685 V2687))) (if (pair? V2666) (let ((X (car V2666))) (let ((V2667 (kl:shen.lazyderef (cdr V2666) V2687))) (if (pair? V2667) (let ((V2668 (kl:shen.lazyderef (car V2667) V2687))) (if (eq? (quote :) V2668) (let ((V2669 (kl:shen.lazyderef (cdr V2667) V2687))) (if (pair? V2669) (let ((A (car V2669))) (let ((V2670 (kl:shen.lazyderef (cdr V2669) V2687))) (if (null? V2670) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.type-theory-enabled?) V2687 (lambda () (kl:cut Throwcontrol V2687 (lambda () (kl:shen.th* X A V2686 V2687 V2688)))))) #f))) #f)) #f)) #f))) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V2687))) (begin (kl:shen.incinfs) (kl:shen.show V2685 V2686 V2687 (lambda () (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V2687 (lambda () (kl:shen.udefs* V2685 V2686 Datatypes V2687 V2688))))))) Case)) Case)) Case))))) (export shen.t*) (quote shen.t*))
(begin (register-function-arity (quote shen.type-theory-enabled?) 0) (define (kl:shen.type-theory-enabled?) (kl:value (quote shen.*shen-type-theory-enabled?*))) (export shen.type-theory-enabled?) (quote shen.type-theory-enabled?))
(begin (register-function-arity (quote enable-type-theory) 1) (define (kl:enable-type-theory V2694) (cond ((eq? (quote +) V2694) (kl:set (quote shen.*shen-type-theory-enabled?*) #t)) ((eq? (quote -) V2694) (kl:set (quote shen.*shen-type-theory-enabled?*) #f)) (#t (simple-error "enable-type-theory expects a + or a -\n")))) (export enable-type-theory) (quote enable-type-theory))
(begin (register-function-arity (quote shen.prolog-failure) 2) (define (kl:shen.prolog-failure V2705 V2706) #f) (export shen.prolog-failure) (quote shen.prolog-failure))
(begin (register-function-arity (quote shen.maxinfexceeded?) 0) (define (kl:shen.maxinfexceeded?) (> (kl:inferences) (kl:value (quote shen.*maxinferences*)))) (export shen.maxinfexceeded?) (quote shen.maxinfexceeded?))
(begin (register-function-arity (quote shen.errormaxinfs) 0) (define (kl:shen.errormaxinfs) (simple-error "maximum inferences exceeded~%")) (export shen.errormaxinfs) (quote shen.errormaxinfs))
(begin (register-function-arity (quote shen.udefs*) 5) (define (kl:shen.udefs* V2712 V2713 V2714 V2715 V2716) (let ((Case (let ((V2661 (kl:shen.lazyderef V2714 V2715))) (if (pair? V2661) (let ((D (car V2661))) (begin (kl:shen.incinfs) (kl:call (cons D (cons V2712 (cons V2713 (quote ())))) V2715 V2716))) #f)))) (if (kl:= Case #f) (let ((V2662 (kl:shen.lazyderef V2714 V2715))) (if (pair? V2662) (let ((Ds (cdr V2662))) (begin (kl:shen.incinfs) (kl:shen.udefs* V2712 V2713 Ds V2715 V2716))) #f)) Case))) (export shen.udefs*) (quote shen.udefs*))
(begin (register-function-arity (quote shen.th*) 5) (define (kl:shen.th* V2722 V2723 V2724 V2725 V2726) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (begin (kl:shen.incinfs) (kl:shen.show (cons V2722 (cons (quote :) (cons V2723 (quote ())))) V2724 V2725 (lambda () (kl:fwhen #f V2725 V2726)))))) (if (kl:= Case #f) (let ((Case (let ((F (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:fwhen (kl:shen.typedf? (kl:shen.lazyderef V2722 V2725)) V2725 (lambda () (kl:bind F (kl:shen.sigf (kl:shen.lazyderef V2722 V2725)) V2725 (lambda () (kl:call (cons F (cons V2723 (quote ()))) V2725 V2726))))))))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.base V2722 V2723 V2725 V2726)))) (if (kl:= Case #f) (let ((Case (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V2722 V2723 V2724 V2725 V2726)))) (if (kl:= Case #f) (let ((Case (let ((V2557 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2557) (let ((F (car V2557))) (let ((V2558 (kl:shen.lazyderef (cdr V2557) V2725))) (if (null? V2558) (begin (kl:shen.incinfs) (kl:shen.th* F (cons (quote -->) (cons V2723 (quote ()))) V2724 V2725 V2726)) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2559 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2559) (let ((F (car V2559))) (let ((V2560 (kl:shen.lazyderef (cdr V2559) V2725))) (if (pair? V2560) (let ((X (car V2560))) (let ((V2561 (kl:shen.lazyderef (cdr V2560) V2725))) (if (null? V2561) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:shen.th* F (cons B (cons (quote -->) (cons V2723 (quote ())))) V2724 V2725 (lambda () (kl:shen.th* X B V2724 V2725 V2726))))) #f))) #f))) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2562 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2562) (let ((V2563 (kl:shen.lazyderef (car V2562) V2725))) (if (eq? (quote cons) V2563) (let ((V2564 (kl:shen.lazyderef (cdr V2562) V2725))) (if (pair? V2564) (let ((X (car V2564))) (let ((V2565 (kl:shen.lazyderef (cdr V2564) V2725))) (if (pair? V2565) (let ((Y (car V2565))) (let ((V2566 (kl:shen.lazyderef (cdr V2565) V2725))) (if (null? V2566) (let ((V2567 (kl:shen.lazyderef V2723 V2725))) (if (pair? V2567) (let ((V2568 (kl:shen.lazyderef (car V2567) V2725))) (if (eq? (quote list) V2568) (let ((V2569 (kl:shen.lazyderef (cdr V2567) V2725))) (if (pair? V2569) (let ((A (car V2569))) (let ((V2570 (kl:shen.lazyderef (cdr V2569) V2725))) (if (null? V2570) (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V2724 V2725 V2726)))) (if (kl:shen.pvar? V2570) (begin (kl:shen.bindv V2570 (quote ()) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2570 V2725) Result))) #f)))) (if (kl:shen.pvar? V2569) (let ((A (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2569 (cons A (quote ())) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2569 V2725) Result)))) #f))) (if (kl:shen.pvar? V2568) (begin (kl:shen.bindv V2568 (quote list) V2725) (let ((Result (let ((V2571 (kl:shen.lazyderef (cdr V2567) V2725))) (if (pair? V2571) (let ((A (car V2571))) (let ((V2572 (kl:shen.lazyderef (cdr V2571) V2725))) (if (null? V2572) (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V2724 V2725 V2726)))) (if (kl:shen.pvar? V2572) (begin (kl:shen.bindv V2572 (quote ()) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2572 V2725) Result))) #f)))) (if (kl:shen.pvar? V2571) (let ((A (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2571 (cons A (quote ())) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2571 V2725) Result)))) #f))))) (begin (kl:shen.unbindv V2568 V2725) Result))) #f))) (if (kl:shen.pvar? V2567) (let ((A (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2567 (cons (quote list) (cons A (quote ()))) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote list) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2567 V2725) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2573 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2573) (let ((V2574 (kl:shen.lazyderef (car V2573) V2725))) (if (eq? (quote _waspvm_at_p) V2574) (let ((V2575 (kl:shen.lazyderef (cdr V2573) V2725))) (if (pair? V2575) (let ((X (car V2575))) (let ((V2576 (kl:shen.lazyderef (cdr V2575) V2725))) (if (pair? V2576) (let ((Y (car V2576))) (let ((V2577 (kl:shen.lazyderef (cdr V2576) V2725))) (if (null? V2577) (let ((V2578 (kl:shen.lazyderef V2723 V2725))) (if (pair? V2578) (let ((A (car V2578))) (let ((V2579 (kl:shen.lazyderef (cdr V2578) V2725))) (if (pair? V2579) (let ((V2580 (kl:shen.lazyderef (car V2579) V2725))) (if (eq? (quote *) V2580) (let ((V2581 (kl:shen.lazyderef (cdr V2579) V2725))) (if (pair? V2581) (let ((B (car V2581))) (let ((V2582 (kl:shen.lazyderef (cdr V2581) V2725))) (if (null? V2582) (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y B V2724 V2725 V2726)))) (if (kl:shen.pvar? V2582) (begin (kl:shen.bindv V2582 (quote ()) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y B V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2582 V2725) Result))) #f)))) (if (kl:shen.pvar? V2581) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2581 (cons B (quote ())) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y B V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2581 V2725) Result)))) #f))) (if (kl:shen.pvar? V2580) (begin (kl:shen.bindv V2580 (quote *) V2725) (let ((Result (let ((V2583 (kl:shen.lazyderef (cdr V2579) V2725))) (if (pair? V2583) (let ((B (car V2583))) (let ((V2584 (kl:shen.lazyderef (cdr V2583) V2725))) (if (null? V2584) (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y B V2724 V2725 V2726)))) (if (kl:shen.pvar? V2584) (begin (kl:shen.bindv V2584 (quote ()) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y B V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2584 V2725) Result))) #f)))) (if (kl:shen.pvar? V2583) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2583 (cons B (quote ())) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y B V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2583 V2725) Result)))) #f))))) (begin (kl:shen.unbindv V2580 V2725) Result))) #f))) (if (kl:shen.pvar? V2579) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2579 (cons (quote *) (cons B (quote ()))) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y B V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2579 V2725) Result)))) #f)))) (if (kl:shen.pvar? V2578) (let ((A (kl:shen.newpv V2725))) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2578 (cons A (cons (quote *) (cons B (quote ())))) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y B V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2578 V2725) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2585 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2585) (let ((V2586 (kl:shen.lazyderef (car V2585) V2725))) (if (eq? (quote _waspvm_at_v) V2586) (let ((V2587 (kl:shen.lazyderef (cdr V2585) V2725))) (if (pair? V2587) (let ((X (car V2587))) (let ((V2588 (kl:shen.lazyderef (cdr V2587) V2725))) (if (pair? V2588) (let ((Y (car V2588))) (let ((V2589 (kl:shen.lazyderef (cdr V2588) V2725))) (if (null? V2589) (let ((V2590 (kl:shen.lazyderef V2723 V2725))) (if (pair? V2590) (let ((V2591 (kl:shen.lazyderef (car V2590) V2725))) (if (eq? (quote vector) V2591) (let ((V2592 (kl:shen.lazyderef (cdr V2590) V2725))) (if (pair? V2592) (let ((A (car V2592))) (let ((V2593 (kl:shen.lazyderef (cdr V2592) V2725))) (if (null? V2593) (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V2724 V2725 V2726)))) (if (kl:shen.pvar? V2593) (begin (kl:shen.bindv V2593 (quote ()) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2593 V2725) Result))) #f)))) (if (kl:shen.pvar? V2592) (let ((A (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2592 (cons A (quote ())) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2592 V2725) Result)))) #f))) (if (kl:shen.pvar? V2591) (begin (kl:shen.bindv V2591 (quote vector) V2725) (let ((Result (let ((V2594 (kl:shen.lazyderef (cdr V2590) V2725))) (if (pair? V2594) (let ((A (car V2594))) (let ((V2595 (kl:shen.lazyderef (cdr V2594) V2725))) (if (null? V2595) (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V2724 V2725 V2726)))) (if (kl:shen.pvar? V2595) (begin (kl:shen.bindv V2595 (quote ()) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2595 V2725) Result))) #f)))) (if (kl:shen.pvar? V2594) (let ((A (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2594 (cons A (quote ())) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2594 V2725) Result)))) #f))))) (begin (kl:shen.unbindv V2591 V2725) Result))) #f))) (if (kl:shen.pvar? V2590) (let ((A (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2590 (cons (quote vector) (cons A (quote ()))) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X A V2724 V2725 (lambda () (kl:shen.th* Y (cons (quote vector) (cons A (quote ()))) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2590 V2725) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2596 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2596) (let ((V2597 (kl:shen.lazyderef (car V2596) V2725))) (if (eq? (quote _waspvm_at_s) V2597) (let ((V2598 (kl:shen.lazyderef (cdr V2596) V2725))) (if (pair? V2598) (let ((X (car V2598))) (let ((V2599 (kl:shen.lazyderef (cdr V2598) V2725))) (if (pair? V2599) (let ((Y (car V2599))) (let ((V2600 (kl:shen.lazyderef (cdr V2599) V2725))) (if (null? V2600) (let ((V2601 (kl:shen.lazyderef V2723 V2725))) (if (eq? (quote string) V2601) (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V2724 V2725 (lambda () (kl:shen.th* Y (quote string) V2724 V2725 V2726)))) (if (kl:shen.pvar? V2601) (begin (kl:shen.bindv V2601 (quote string) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:shen.th* X (quote string) V2724 V2725 (lambda () (kl:shen.th* Y (quote string) V2724 V2725 V2726)))))) (begin (kl:shen.unbindv V2601 V2725) Result))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2602 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2602) (let ((V2603 (kl:shen.lazyderef (car V2602) V2725))) (if (eq? (quote lambda) V2603) (let ((V2604 (kl:shen.lazyderef (cdr V2602) V2725))) (if (pair? V2604) (let ((X (car V2604))) (let ((V2605 (kl:shen.lazyderef (cdr V2604) V2725))) (if (pair? V2605) (let ((Y (car V2605))) (let ((V2606 (kl:shen.lazyderef (cdr V2605) V2725))) (if (null? V2606) (let ((V2607 (kl:shen.lazyderef V2723 V2725))) (if (pair? V2607) (let ((A (car V2607))) (let ((V2608 (kl:shen.lazyderef (cdr V2607) V2725))) (if (pair? V2608) (let ((V2609 (kl:shen.lazyderef (car V2608) V2725))) (if (eq? (quote -->) V2609) (let ((V2610 (kl:shen.lazyderef (cdr V2608) V2725))) (if (pair? V2610) (let ((B (car V2610))) (let ((V2611 (kl:shen.lazyderef (cdr V2610) V2725))) (if (null? V2611) (let ((Z (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Y V2725)) V2725 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V2724) V2725 V2726)))))))) (if (kl:shen.pvar? V2611) (begin (kl:shen.bindv V2611 (quote ()) V2725) (let ((Result (let ((Z (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Y V2725)) V2725 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V2724) V2725 V2726)))))))))) (begin (kl:shen.unbindv V2611 V2725) Result))) #f)))) (if (kl:shen.pvar? V2610) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2610 (cons B (quote ())) V2725) (let ((Result (let ((Z (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Y V2725)) V2725 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V2724) V2725 V2726)))))))))) (begin (kl:shen.unbindv V2610 V2725) Result)))) #f))) (if (kl:shen.pvar? V2609) (begin (kl:shen.bindv V2609 (quote -->) V2725) (let ((Result (let ((V2612 (kl:shen.lazyderef (cdr V2608) V2725))) (if (pair? V2612) (let ((B (car V2612))) (let ((V2613 (kl:shen.lazyderef (cdr V2612) V2725))) (if (null? V2613) (let ((Z (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Y V2725)) V2725 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V2724) V2725 V2726)))))))) (if (kl:shen.pvar? V2613) (begin (kl:shen.bindv V2613 (quote ()) V2725) (let ((Result (let ((Z (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Y V2725)) V2725 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V2724) V2725 V2726)))))))))) (begin (kl:shen.unbindv V2613 V2725) Result))) #f)))) (if (kl:shen.pvar? V2612) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2612 (cons B (quote ())) V2725) (let ((Result (let ((Z (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Y V2725)) V2725 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V2724) V2725 V2726)))))))))) (begin (kl:shen.unbindv V2612 V2725) Result)))) #f))))) (begin (kl:shen.unbindv V2609 V2725) Result))) #f))) (if (kl:shen.pvar? V2608) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2608 (cons (quote -->) (cons B (quote ()))) V2725) (let ((Result (let ((Z (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Y V2725)) V2725 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V2724) V2725 V2726)))))))))) (begin (kl:shen.unbindv V2608 V2725) Result)))) #f)))) (if (kl:shen.pvar? V2607) (let ((A (kl:shen.newpv V2725))) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2607 (cons A (cons (quote -->) (cons B (quote ())))) V2725) (let ((Result (let ((Z (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind Z (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Y V2725)) V2725 (lambda () (kl:shen.th* Z B (cons (cons X&& (cons (quote :) (cons A (quote ())))) V2724) V2725 V2726)))))))))) (begin (kl:shen.unbindv V2607 V2725) Result))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2614 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2614) (let ((V2615 (kl:shen.lazyderef (car V2614) V2725))) (if (eq? (quote let) V2615) (let ((V2616 (kl:shen.lazyderef (cdr V2614) V2725))) (if (pair? V2616) (let ((X (car V2616))) (let ((V2617 (kl:shen.lazyderef (cdr V2616) V2725))) (if (pair? V2617) (let ((Y (car V2617))) (let ((V2618 (kl:shen.lazyderef (cdr V2617) V2725))) (if (pair? V2618) (let ((Z (car V2618))) (let ((V2619 (kl:shen.lazyderef (cdr V2618) V2725))) (if (null? V2619) (let ((W (kl:shen.newpv V2725))) (let ((X&& (kl:shen.newpv V2725))) (let ((B (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:shen.th* Y B V2724 V2725 (lambda () (kl:bind X&& (kl:shen.placeholder) V2725 (lambda () (kl:bind W (kl:shen.ebr (kl:shen.lazyderef X&& V2725) (kl:shen.lazyderef X V2725) (kl:shen.lazyderef Z V2725)) V2725 (lambda () (kl:shen.th* W V2723 (cons (cons X&& (cons (quote :) (cons B (quote ())))) V2724) V2725 V2726))))))))))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2620 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2620) (let ((V2621 (kl:shen.lazyderef (car V2620) V2725))) (if (eq? (quote open) V2621) (let ((V2622 (kl:shen.lazyderef (cdr V2620) V2725))) (if (pair? V2622) (let ((FileName (car V2622))) (let ((V2623 (kl:shen.lazyderef (cdr V2622) V2725))) (if (pair? V2623) (let ((Direction2553 (car V2623))) (let ((V2624 (kl:shen.lazyderef (cdr V2623) V2725))) (if (null? V2624) (let ((V2625 (kl:shen.lazyderef V2723 V2725))) (if (pair? V2625) (let ((V2626 (kl:shen.lazyderef (car V2625) V2725))) (if (eq? (quote stream) V2626) (let ((V2627 (kl:shen.lazyderef (cdr V2625) V2725))) (if (pair? V2627) (let ((Direction (car V2627))) (let ((V2628 (kl:shen.lazyderef (cdr V2627) V2725))) (if (null? V2628) (begin (kl:shen.incinfs) (kl:unify! Direction Direction2553 V2725 (lambda () (kl:cut Throwcontrol V2725 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V2725) (cons (quote in) (cons (quote out) (quote ())))) V2725 (lambda () (kl:shen.th* FileName (quote string) V2724 V2725 V2726)))))))) (if (kl:shen.pvar? V2628) (begin (kl:shen.bindv V2628 (quote ()) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction2553 V2725 (lambda () (kl:cut Throwcontrol V2725 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V2725) (cons (quote in) (cons (quote out) (quote ())))) V2725 (lambda () (kl:shen.th* FileName (quote string) V2724 V2725 V2726)))))))))) (begin (kl:shen.unbindv V2628 V2725) Result))) #f)))) (if (kl:shen.pvar? V2627) (let ((Direction (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2627 (cons Direction (quote ())) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction2553 V2725 (lambda () (kl:cut Throwcontrol V2725 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V2725) (cons (quote in) (cons (quote out) (quote ())))) V2725 (lambda () (kl:shen.th* FileName (quote string) V2724 V2725 V2726)))))))))) (begin (kl:shen.unbindv V2627 V2725) Result)))) #f))) (if (kl:shen.pvar? V2626) (begin (kl:shen.bindv V2626 (quote stream) V2725) (let ((Result (let ((V2629 (kl:shen.lazyderef (cdr V2625) V2725))) (if (pair? V2629) (let ((Direction (car V2629))) (let ((V2630 (kl:shen.lazyderef (cdr V2629) V2725))) (if (null? V2630) (begin (kl:shen.incinfs) (kl:unify! Direction Direction2553 V2725 (lambda () (kl:cut Throwcontrol V2725 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V2725) (cons (quote in) (cons (quote out) (quote ())))) V2725 (lambda () (kl:shen.th* FileName (quote string) V2724 V2725 V2726)))))))) (if (kl:shen.pvar? V2630) (begin (kl:shen.bindv V2630 (quote ()) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction2553 V2725 (lambda () (kl:cut Throwcontrol V2725 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V2725) (cons (quote in) (cons (quote out) (quote ())))) V2725 (lambda () (kl:shen.th* FileName (quote string) V2724 V2725 V2726)))))))))) (begin (kl:shen.unbindv V2630 V2725) Result))) #f)))) (if (kl:shen.pvar? V2629) (let ((Direction (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2629 (cons Direction (quote ())) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction2553 V2725 (lambda () (kl:cut Throwcontrol V2725 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V2725) (cons (quote in) (cons (quote out) (quote ())))) V2725 (lambda () (kl:shen.th* FileName (quote string) V2724 V2725 V2726)))))))))) (begin (kl:shen.unbindv V2629 V2725) Result)))) #f))))) (begin (kl:shen.unbindv V2626 V2725) Result))) #f))) (if (kl:shen.pvar? V2625) (let ((Direction (kl:shen.newpv V2725))) (begin (kl:shen.bindv V2625 (cons (quote stream) (cons Direction (quote ()))) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:unify! Direction Direction2553 V2725 (lambda () (kl:cut Throwcontrol V2725 (lambda () (kl:fwhen (kl:element? (kl:shen.lazyderef Direction V2725) (cons (quote in) (cons (quote out) (quote ())))) V2725 (lambda () (kl:shen.th* FileName (quote string) V2724 V2725 V2726)))))))))) (begin (kl:shen.unbindv V2625 V2725) Result)))) #f))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2631 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2631) (let ((V2632 (kl:shen.lazyderef (car V2631) V2725))) (if (eq? (quote type) V2632) (let ((V2633 (kl:shen.lazyderef (cdr V2631) V2725))) (if (pair? V2633) (let ((X (car V2633))) (let ((V2634 (kl:shen.lazyderef (cdr V2633) V2725))) (if (pair? V2634) (let ((A (car V2634))) (let ((V2635 (kl:shen.lazyderef (cdr V2634) V2725))) (if (null? V2635) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2725 (lambda () (kl:unify A V2723 V2725 (lambda () (kl:shen.th* X A V2724 V2725 V2726)))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2636 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2636) (let ((V2637 (kl:shen.lazyderef (car V2636) V2725))) (if (eq? (quote input+) V2637) (let ((V2638 (kl:shen.lazyderef (cdr V2636) V2725))) (if (pair? V2638) (let ((A (car V2638))) (let ((V2639 (kl:shen.lazyderef (cdr V2638) V2725))) (if (pair? V2639) (let ((Stream (car V2639))) (let ((V2640 (kl:shen.lazyderef (cdr V2639) V2725))) (if (null? V2640) (let ((C (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind C (kl:shen.demodulate (kl:shen.lazyderef A V2725)) V2725 (lambda () (kl:unify V2723 C V2725 (lambda () (kl:shen.th* Stream (cons (quote stream) (cons (quote in) (quote ()))) V2724 V2725 V2726))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2641 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2641) (let ((V2642 (kl:shen.lazyderef (car V2641) V2725))) (if (eq? (quote set) V2642) (let ((V2643 (kl:shen.lazyderef (cdr V2641) V2725))) (if (pair? V2643) (let ((Var (car V2643))) (let ((V2644 (kl:shen.lazyderef (cdr V2643) V2725))) (if (pair? V2644) (let ((Val (car V2644))) (let ((V2645 (kl:shen.lazyderef (cdr V2644) V2725))) (if (null? V2645) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2725 (lambda () (kl:shen.th* Var (quote symbol) V2724 V2725 (lambda () (kl:cut Throwcontrol V2725 (lambda () (kl:shen.th* (cons (quote value) (cons Var (quote ()))) V2723 V2724 V2725 (lambda () (kl:shen.th* Val V2723 V2724 V2725 V2726)))))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((NewHyp (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:shen.t*-hyps V2724 NewHyp V2725 (lambda () (kl:shen.th* V2722 V2723 NewHyp V2725 V2726))))))) (if (kl:= Case #f) (let ((Case (let ((V2646 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2646) (let ((V2647 (kl:shen.lazyderef (car V2646) V2725))) (if (eq? (quote define) V2647) (let ((V2648 (kl:shen.lazyderef (cdr V2646) V2725))) (if (pair? V2648) (let ((F (car V2648))) (let ((X (cdr V2648))) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2725 (lambda () (kl:shen.t*-def (cons (quote define) (cons F X)) V2723 V2724 V2725 V2726)))))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2649 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2649) (let ((V2650 (kl:shen.lazyderef (car V2649) V2725))) (if (eq? (quote defmacro) V2650) (let ((V2651 (kl:shen.lazyderef V2723 V2725))) (if (eq? (quote unit) V2651) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2725 V2726)) (if (kl:shen.pvar? V2651) (begin (kl:shen.bindv V2651 (quote unit) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2725 V2726)))) (begin (kl:shen.unbindv V2651 V2725) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2652 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2652) (let ((V2653 (kl:shen.lazyderef (car V2652) V2725))) (if (eq? (quote shen.process-datatype) V2653) (let ((V2654 (kl:shen.lazyderef V2723 V2725))) (if (eq? (quote symbol) V2654) (begin (kl:shen.incinfs) (kl:thaw V2726)) (if (kl:shen.pvar? V2654) (begin (kl:shen.bindv V2654 (quote symbol) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V2726)))) (begin (kl:shen.unbindv V2654 V2725) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2655 (kl:shen.lazyderef V2722 V2725))) (if (pair? V2655) (let ((V2656 (kl:shen.lazyderef (car V2655) V2725))) (if (eq? (quote shen.synonyms-help) V2656) (let ((V2657 (kl:shen.lazyderef V2723 V2725))) (if (eq? (quote symbol) V2657) (begin (kl:shen.incinfs) (kl:thaw V2726)) (if (kl:shen.pvar? V2657) (begin (kl:shen.bindv V2657 (quote symbol) V2725) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V2726)))) (begin (kl:shen.unbindv V2657 V2725) Result))) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((Datatypes (kl:shen.newpv V2725))) (begin (kl:shen.incinfs) (kl:bind Datatypes (kl:value (quote shen.*datatypes*)) V2725 (lambda () (kl:shen.udefs* (cons V2722 (cons (quote :) (cons V2723 (quote ())))) V2724 Datatypes V2725 V2726))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case))))) (export shen.th*) (quote shen.th*))
(begin (register-function-arity (quote shen.t*-hyps) 4) (define (kl:shen.t*-hyps V2731 V2732 V2733 V2734) (let ((Case (let ((V2468 (kl:shen.lazyderef V2731 V2733))) (if (pair? V2468) (let ((V2469 (kl:shen.lazyderef (car V2468) V2733))) (if (pair? V2469) (let ((V2470 (kl:shen.lazyderef (car V2469) V2733))) (if (pair? V2470) (let ((V2471 (kl:shen.lazyderef (car V2470) V2733))) (if (eq? (quote cons) V2471) (let ((V2472 (kl:shen.lazyderef (cdr V2470) V2733))) (if (pair? V2472) (let ((X (car V2472))) (let ((V2473 (kl:shen.lazyderef (cdr V2472) V2733))) (if (pair? V2473) (let ((Y (car V2473))) (let ((V2474 (kl:shen.lazyderef (cdr V2473) V2733))) (if (null? V2474) (let ((V2475 (kl:shen.lazyderef (cdr V2469) V2733))) (if (pair? V2475) (let ((V2476 (kl:shen.lazyderef (car V2475) V2733))) (if (eq? (quote :) V2476) (let ((V2477 (kl:shen.lazyderef (cdr V2475) V2733))) (if (pair? V2477) (let ((V2478 (kl:shen.lazyderef (car V2477) V2733))) (if (pair? V2478) (let ((V2479 (kl:shen.lazyderef (car V2478) V2733))) (if (eq? (quote list) V2479) (let ((V2480 (kl:shen.lazyderef (cdr V2478) V2733))) (if (pair? V2480) (let ((A (car V2480))) (let ((V2481 (kl:shen.lazyderef (cdr V2480) V2733))) (if (null? V2481) (let ((V2482 (kl:shen.lazyderef (cdr V2477) V2733))) (if (null? V2482) (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2482) (begin (kl:shen.bindv V2482 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2482 V2733) Result))) #f))) (if (kl:shen.pvar? V2481) (begin (kl:shen.bindv V2481 (quote ()) V2733) (let ((Result (let ((V2483 (kl:shen.lazyderef (cdr V2477) V2733))) (if (null? V2483) (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2483) (begin (kl:shen.bindv V2483 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2483 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2481 V2733) Result))) #f)))) (if (kl:shen.pvar? V2480) (let ((A (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2480 (cons A (quote ())) V2733) (let ((Result (let ((V2484 (kl:shen.lazyderef (cdr V2477) V2733))) (if (null? V2484) (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2484) (begin (kl:shen.bindv V2484 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2484 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2480 V2733) Result)))) #f))) (if (kl:shen.pvar? V2479) (begin (kl:shen.bindv V2479 (quote list) V2733) (let ((Result (let ((V2485 (kl:shen.lazyderef (cdr V2478) V2733))) (if (pair? V2485) (let ((A (car V2485))) (let ((V2486 (kl:shen.lazyderef (cdr V2485) V2733))) (if (null? V2486) (let ((V2487 (kl:shen.lazyderef (cdr V2477) V2733))) (if (null? V2487) (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2487) (begin (kl:shen.bindv V2487 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2487 V2733) Result))) #f))) (if (kl:shen.pvar? V2486) (begin (kl:shen.bindv V2486 (quote ()) V2733) (let ((Result (let ((V2488 (kl:shen.lazyderef (cdr V2477) V2733))) (if (null? V2488) (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2488) (begin (kl:shen.bindv V2488 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2488 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2486 V2733) Result))) #f)))) (if (kl:shen.pvar? V2485) (let ((A (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2485 (cons A (quote ())) V2733) (let ((Result (let ((V2489 (kl:shen.lazyderef (cdr V2477) V2733))) (if (null? V2489) (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2489) (begin (kl:shen.bindv V2489 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2489 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2485 V2733) Result)))) #f))))) (begin (kl:shen.unbindv V2479 V2733) Result))) #f))) (if (kl:shen.pvar? V2478) (let ((A (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2478 (cons (quote list) (cons A (quote ()))) V2733) (let ((Result (let ((V2490 (kl:shen.lazyderef (cdr V2477) V2733))) (if (null? V2490) (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2490) (begin (kl:shen.bindv V2490 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2468))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote list) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2490 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2478 V2733) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2491 (kl:shen.lazyderef V2731 V2733))) (if (pair? V2491) (let ((V2492 (kl:shen.lazyderef (car V2491) V2733))) (if (pair? V2492) (let ((V2493 (kl:shen.lazyderef (car V2492) V2733))) (if (pair? V2493) (let ((V2494 (kl:shen.lazyderef (car V2493) V2733))) (if (eq? (quote _waspvm_at_p) V2494) (let ((V2495 (kl:shen.lazyderef (cdr V2493) V2733))) (if (pair? V2495) (let ((X (car V2495))) (let ((V2496 (kl:shen.lazyderef (cdr V2495) V2733))) (if (pair? V2496) (let ((Y (car V2496))) (let ((V2497 (kl:shen.lazyderef (cdr V2496) V2733))) (if (null? V2497) (let ((V2498 (kl:shen.lazyderef (cdr V2492) V2733))) (if (pair? V2498) (let ((V2499 (kl:shen.lazyderef (car V2498) V2733))) (if (eq? (quote :) V2499) (let ((V2500 (kl:shen.lazyderef (cdr V2498) V2733))) (if (pair? V2500) (let ((V2501 (kl:shen.lazyderef (car V2500) V2733))) (if (pair? V2501) (let ((A (car V2501))) (let ((V2502 (kl:shen.lazyderef (cdr V2501) V2733))) (if (pair? V2502) (let ((V2503 (kl:shen.lazyderef (car V2502) V2733))) (if (eq? (quote *) V2503) (let ((V2504 (kl:shen.lazyderef (cdr V2502) V2733))) (if (pair? V2504) (let ((B (car V2504))) (let ((V2505 (kl:shen.lazyderef (cdr V2504) V2733))) (if (null? V2505) (let ((V2506 (kl:shen.lazyderef (cdr V2500) V2733))) (if (null? V2506) (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2506) (begin (kl:shen.bindv V2506 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2506 V2733) Result))) #f))) (if (kl:shen.pvar? V2505) (begin (kl:shen.bindv V2505 (quote ()) V2733) (let ((Result (let ((V2507 (kl:shen.lazyderef (cdr V2500) V2733))) (if (null? V2507) (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2507) (begin (kl:shen.bindv V2507 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2507 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2505 V2733) Result))) #f)))) (if (kl:shen.pvar? V2504) (let ((B (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2504 (cons B (quote ())) V2733) (let ((Result (let ((V2508 (kl:shen.lazyderef (cdr V2500) V2733))) (if (null? V2508) (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2508) (begin (kl:shen.bindv V2508 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2508 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2504 V2733) Result)))) #f))) (if (kl:shen.pvar? V2503) (begin (kl:shen.bindv V2503 (quote *) V2733) (let ((Result (let ((V2509 (kl:shen.lazyderef (cdr V2502) V2733))) (if (pair? V2509) (let ((B (car V2509))) (let ((V2510 (kl:shen.lazyderef (cdr V2509) V2733))) (if (null? V2510) (let ((V2511 (kl:shen.lazyderef (cdr V2500) V2733))) (if (null? V2511) (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2511) (begin (kl:shen.bindv V2511 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2511 V2733) Result))) #f))) (if (kl:shen.pvar? V2510) (begin (kl:shen.bindv V2510 (quote ()) V2733) (let ((Result (let ((V2512 (kl:shen.lazyderef (cdr V2500) V2733))) (if (null? V2512) (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2512) (begin (kl:shen.bindv V2512 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2512 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2510 V2733) Result))) #f)))) (if (kl:shen.pvar? V2509) (let ((B (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2509 (cons B (quote ())) V2733) (let ((Result (let ((V2513 (kl:shen.lazyderef (cdr V2500) V2733))) (if (null? V2513) (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2513) (begin (kl:shen.bindv V2513 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2513 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2509 V2733) Result)))) #f))))) (begin (kl:shen.unbindv V2503 V2733) Result))) #f))) (if (kl:shen.pvar? V2502) (let ((B (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2502 (cons (quote *) (cons B (quote ()))) V2733) (let ((Result (let ((V2514 (kl:shen.lazyderef (cdr V2500) V2733))) (if (null? V2514) (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2514) (begin (kl:shen.bindv V2514 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2514 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2502 V2733) Result)))) #f)))) (if (kl:shen.pvar? V2501) (let ((A (kl:shen.newpv V2733))) (let ((B (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2501 (cons A (cons (quote *) (cons B (quote ())))) V2733) (let ((Result (let ((V2515 (kl:shen.lazyderef (cdr V2500) V2733))) (if (null? V2515) (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2515) (begin (kl:shen.bindv V2515 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2491))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (kl:shen.lazyderef B V2733) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2515 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2501 V2733) Result))))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2516 (kl:shen.lazyderef V2731 V2733))) (if (pair? V2516) (let ((V2517 (kl:shen.lazyderef (car V2516) V2733))) (if (pair? V2517) (let ((V2518 (kl:shen.lazyderef (car V2517) V2733))) (if (pair? V2518) (let ((V2519 (kl:shen.lazyderef (car V2518) V2733))) (if (eq? (quote _waspvm_at_v) V2519) (let ((V2520 (kl:shen.lazyderef (cdr V2518) V2733))) (if (pair? V2520) (let ((X (car V2520))) (let ((V2521 (kl:shen.lazyderef (cdr V2520) V2733))) (if (pair? V2521) (let ((Y (car V2521))) (let ((V2522 (kl:shen.lazyderef (cdr V2521) V2733))) (if (null? V2522) (let ((V2523 (kl:shen.lazyderef (cdr V2517) V2733))) (if (pair? V2523) (let ((V2524 (kl:shen.lazyderef (car V2523) V2733))) (if (eq? (quote :) V2524) (let ((V2525 (kl:shen.lazyderef (cdr V2523) V2733))) (if (pair? V2525) (let ((V2526 (kl:shen.lazyderef (car V2525) V2733))) (if (pair? V2526) (let ((V2527 (kl:shen.lazyderef (car V2526) V2733))) (if (eq? (quote vector) V2527) (let ((V2528 (kl:shen.lazyderef (cdr V2526) V2733))) (if (pair? V2528) (let ((A (car V2528))) (let ((V2529 (kl:shen.lazyderef (cdr V2528) V2733))) (if (null? V2529) (let ((V2530 (kl:shen.lazyderef (cdr V2525) V2733))) (if (null? V2530) (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2530) (begin (kl:shen.bindv V2530 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2530 V2733) Result))) #f))) (if (kl:shen.pvar? V2529) (begin (kl:shen.bindv V2529 (quote ()) V2733) (let ((Result (let ((V2531 (kl:shen.lazyderef (cdr V2525) V2733))) (if (null? V2531) (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2531) (begin (kl:shen.bindv V2531 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2531 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2529 V2733) Result))) #f)))) (if (kl:shen.pvar? V2528) (let ((A (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2528 (cons A (quote ())) V2733) (let ((Result (let ((V2532 (kl:shen.lazyderef (cdr V2525) V2733))) (if (null? V2532) (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2532) (begin (kl:shen.bindv V2532 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2532 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2528 V2733) Result)))) #f))) (if (kl:shen.pvar? V2527) (begin (kl:shen.bindv V2527 (quote vector) V2733) (let ((Result (let ((V2533 (kl:shen.lazyderef (cdr V2526) V2733))) (if (pair? V2533) (let ((A (car V2533))) (let ((V2534 (kl:shen.lazyderef (cdr V2533) V2733))) (if (null? V2534) (let ((V2535 (kl:shen.lazyderef (cdr V2525) V2733))) (if (null? V2535) (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2535) (begin (kl:shen.bindv V2535 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2535 V2733) Result))) #f))) (if (kl:shen.pvar? V2534) (begin (kl:shen.bindv V2534 (quote ()) V2733) (let ((Result (let ((V2536 (kl:shen.lazyderef (cdr V2525) V2733))) (if (null? V2536) (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2536) (begin (kl:shen.bindv V2536 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2536 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2534 V2733) Result))) #f)))) (if (kl:shen.pvar? V2533) (let ((A (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2533 (cons A (quote ())) V2733) (let ((Result (let ((V2537 (kl:shen.lazyderef (cdr V2525) V2733))) (if (null? V2537) (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2537) (begin (kl:shen.bindv V2537 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2537 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2533 V2733) Result)))) #f))))) (begin (kl:shen.unbindv V2527 V2733) Result))) #f))) (if (kl:shen.pvar? V2526) (let ((A (kl:shen.newpv V2733))) (begin (kl:shen.bindv V2526 (cons (quote vector) (cons A (quote ()))) V2733) (let ((Result (let ((V2538 (kl:shen.lazyderef (cdr V2525) V2733))) (if (null? V2538) (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2538) (begin (kl:shen.bindv V2538 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2516))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (kl:shen.lazyderef A V2733) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (cons (quote vector) (cons (kl:shen.lazyderef A V2733) (quote ()))) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2538 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2526 V2733) Result)))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2539 (kl:shen.lazyderef V2731 V2733))) (if (pair? V2539) (let ((V2540 (kl:shen.lazyderef (car V2539) V2733))) (if (pair? V2540) (let ((V2541 (kl:shen.lazyderef (car V2540) V2733))) (if (pair? V2541) (let ((V2542 (kl:shen.lazyderef (car V2541) V2733))) (if (eq? (quote _waspvm_at_s) V2542) (let ((V2543 (kl:shen.lazyderef (cdr V2541) V2733))) (if (pair? V2543) (let ((X (car V2543))) (let ((V2544 (kl:shen.lazyderef (cdr V2543) V2733))) (if (pair? V2544) (let ((Y (car V2544))) (let ((V2545 (kl:shen.lazyderef (cdr V2544) V2733))) (if (null? V2545) (let ((V2546 (kl:shen.lazyderef (cdr V2540) V2733))) (if (pair? V2546) (let ((V2547 (kl:shen.lazyderef (car V2546) V2733))) (if (eq? (quote :) V2547) (let ((V2548 (kl:shen.lazyderef (cdr V2546) V2733))) (if (pair? V2548) (let ((V2549 (kl:shen.lazyderef (car V2548) V2733))) (if (eq? (quote string) V2549) (let ((V2550 (kl:shen.lazyderef (cdr V2548) V2733))) (if (null? V2550) (let ((Hyp (cdr V2539))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2550) (begin (kl:shen.bindv V2550 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2539))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2550 V2733) Result))) #f))) (if (kl:shen.pvar? V2549) (begin (kl:shen.bindv V2549 (quote string) V2733) (let ((Result (let ((V2551 (kl:shen.lazyderef (cdr V2548) V2733))) (if (null? V2551) (let ((Hyp (cdr V2539))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))) (if (kl:shen.pvar? V2551) (begin (kl:shen.bindv V2551 (quote ()) V2733) (let ((Result (let ((Hyp (cdr V2539))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (cons (kl:shen.lazyderef X V2733) (cons (quote :) (cons (quote string) (quote ())))) (cons (cons (kl:shen.lazyderef Y V2733) (cons (quote :) (cons (quote string) (quote ())))) (kl:shen.lazyderef Hyp V2733))) V2733 V2734))))) (begin (kl:shen.unbindv V2551 V2733) Result))) #f))))) (begin (kl:shen.unbindv V2549 V2733) Result))) #f))) #f)) #f)) #f)) #f))) #f))) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((V2552 (kl:shen.lazyderef V2731 V2733))) (if (pair? V2552) (let ((X (car V2552))) (let ((Hyp (cdr V2552))) (let ((NewHyps (kl:shen.newpv V2733))) (begin (kl:shen.incinfs) (kl:bind V2732 (cons (kl:shen.lazyderef X V2733) (kl:shen.lazyderef NewHyps V2733)) V2733 (lambda () (kl:shen.t*-hyps Hyp NewHyps V2733 V2734))))))) #f)) Case)) Case)) Case)) Case))) (export shen.t*-hyps) (quote shen.t*-hyps))
(begin (register-function-arity (quote shen.show) 4) (define (kl:shen.show V2751 V2752 V2753 V2754) (cond ((assert-boolean (kl:value (quote shen.*spy*))) (begin (kl:shen.line) (begin (kl:shen.show-p (kl:shen.deref V2751 V2753)) (begin (kl:nl 1) (begin (kl:nl 1) (begin (kl:shen.show-assumptions (kl:shen.deref V2752 V2753) 1) (begin (kl:shen.prhush "\n> " (kl:stoutput)) (begin (kl:shen.pause-for-user) (kl:thaw V2754))))))))) (#t (kl:thaw V2754)))) (export shen.show) (quote shen.show))
(begin (register-function-arity (quote shen.line) 0) (define (kl:shen.line) (let ((Infs (kl:inferences))) (kl:shen.prhush (string-append "____________________________________________________________ " (kl:shen.app Infs (string-append " inference" (kl:shen.app (if (kl:= 1 Infs) "" "s") " \n?- " (quote shen.a))) (quote shen.a))) (kl:stoutput)))) (export shen.line) (quote shen.line))
(begin (register-function-arity (quote shen.show-p) 1) (define (kl:shen.show-p V2756) (cond ((and (pair? V2756) (and (pair? (cdr V2756)) (and (eq? (quote :) (car (cdr V2756))) (and (pair? (cdr (cdr V2756))) (null? (cdr (cdr (cdr V2756)))))))) (kl:shen.prhush (kl:shen.app (car V2756) (string-append " : " (kl:shen.app (car (cdr (cdr V2756))) "" (quote shen.r))) (quote shen.r)) (kl:stoutput))) (#t (kl:shen.prhush (kl:shen.app V2756 "" (quote shen.r)) (kl:stoutput))))) (export shen.show-p) (quote shen.show-p))
(begin (register-function-arity (quote shen.show-assumptions) 2) (define (kl:shen.show-assumptions V2761 V2762) (cond ((null? V2761) (quote shen.skip)) ((pair? V2761) (begin (kl:shen.prhush (kl:shen.app V2762 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.show-p (car V2761)) (begin (kl:nl 1) (kl:shen.show-assumptions (cdr V2761) (+ V2762 1)))))) (#t (kl:shen.f_error (quote shen.show-assumptions))))) (export shen.show-assumptions) (quote shen.show-assumptions))
(begin (register-function-arity (quote shen.pause-for-user) 0) (define (kl:shen.pause-for-user) (let ((Byte (read-u8 (kl:stinput)))) (if (kl:= Byte 94) (simple-error "input aborted\n") (kl:nl 1)))) (export shen.pause-for-user) (quote shen.pause-for-user))
(begin (register-function-arity (quote shen.typedf?) 1) (define (kl:shen.typedf? V2764) (pair? (kl:assoc V2764 (kl:value (quote shen.*signedfuncs*))))) (export shen.typedf?) (quote shen.typedf?))
(begin (register-function-arity (quote shen.sigf) 1) (define (kl:shen.sigf V2766) (kl:concat (quote shen.type-signature-of-) V2766)) (export shen.sigf) (quote shen.sigf))
(begin (register-function-arity (quote shen.placeholder) 0) (define (kl:shen.placeholder) (kl:gensym (quote &&))) (export shen.placeholder) (quote shen.placeholder))
(begin (register-function-arity (quote shen.base) 4) (define (kl:shen.base V2771 V2772 V2773 V2774) (let ((Case (let ((V2455 (kl:shen.lazyderef V2772 V2773))) (if (eq? (quote number) V2455) (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V2771 V2773)) V2773 V2774)) (if (kl:shen.pvar? V2455) (begin (kl:shen.bindv V2455 (quote number) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (number? (kl:shen.lazyderef V2771 V2773)) V2773 V2774)))) (begin (kl:shen.unbindv V2455 V2773) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V2456 (kl:shen.lazyderef V2772 V2773))) (if (eq? (quote boolean) V2456) (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V2771 V2773)) V2773 V2774)) (if (kl:shen.pvar? V2456) (begin (kl:shen.bindv V2456 (quote boolean) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:boolean? (kl:shen.lazyderef V2771 V2773)) V2773 V2774)))) (begin (kl:shen.unbindv V2456 V2773) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V2457 (kl:shen.lazyderef V2772 V2773))) (if (eq? (quote string) V2457) (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V2771 V2773)) V2773 V2774)) (if (kl:shen.pvar? V2457) (begin (kl:shen.bindv V2457 (quote string) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (string? (kl:shen.lazyderef V2771 V2773)) V2773 V2774)))) (begin (kl:shen.unbindv V2457 V2773) Result))) #f))))) (if (kl:= Case #f) (let ((Case (let ((V2458 (kl:shen.lazyderef V2772 V2773))) (if (eq? (quote symbol) V2458) (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V2771 V2773)) V2773 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V2771 V2773))) V2773 V2774)))) (if (kl:shen.pvar? V2458) (begin (kl:shen.bindv V2458 (quote symbol) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:fwhen (kl:symbol? (kl:shen.lazyderef V2771 V2773)) V2773 (lambda () (kl:fwhen (kl:not (kl:shen.ue? (kl:shen.lazyderef V2771 V2773))) V2773 V2774)))))) (begin (kl:shen.unbindv V2458 V2773) Result))) #f))))) (if (kl:= Case #f) (let ((V2459 (kl:shen.lazyderef V2771 V2773))) (if (null? V2459) (let ((V2460 (kl:shen.lazyderef V2772 V2773))) (if (pair? V2460) (let ((V2461 (kl:shen.lazyderef (car V2460) V2773))) (if (eq? (quote list) V2461) (let ((V2462 (kl:shen.lazyderef (cdr V2460) V2773))) (if (pair? V2462) (let ((A (car V2462))) (let ((V2463 (kl:shen.lazyderef (cdr V2462) V2773))) (if (null? V2463) (begin (kl:shen.incinfs) (kl:thaw V2774)) (if (kl:shen.pvar? V2463) (begin (kl:shen.bindv V2463 (quote ()) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V2774)))) (begin (kl:shen.unbindv V2463 V2773) Result))) #f)))) (if (kl:shen.pvar? V2462) (let ((A (kl:shen.newpv V2773))) (begin (kl:shen.bindv V2462 (cons A (quote ())) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V2774)))) (begin (kl:shen.unbindv V2462 V2773) Result)))) #f))) (if (kl:shen.pvar? V2461) (begin (kl:shen.bindv V2461 (quote list) V2773) (let ((Result (let ((V2464 (kl:shen.lazyderef (cdr V2460) V2773))) (if (pair? V2464) (let ((A (car V2464))) (let ((V2465 (kl:shen.lazyderef (cdr V2464) V2773))) (if (null? V2465) (begin (kl:shen.incinfs) (kl:thaw V2774)) (if (kl:shen.pvar? V2465) (begin (kl:shen.bindv V2465 (quote ()) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V2774)))) (begin (kl:shen.unbindv V2465 V2773) Result))) #f)))) (if (kl:shen.pvar? V2464) (let ((A (kl:shen.newpv V2773))) (begin (kl:shen.bindv V2464 (cons A (quote ())) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V2774)))) (begin (kl:shen.unbindv V2464 V2773) Result)))) #f))))) (begin (kl:shen.unbindv V2461 V2773) Result))) #f))) (if (kl:shen.pvar? V2460) (let ((A (kl:shen.newpv V2773))) (begin (kl:shen.bindv V2460 (cons (quote list) (cons A (quote ()))) V2773) (let ((Result (begin (kl:shen.incinfs) (kl:thaw V2774)))) (begin (kl:shen.unbindv V2460 V2773) Result)))) #f))) #f)) Case)) Case)) Case)) Case))) (export shen.base) (quote shen.base))
(begin (register-function-arity (quote shen.by_hypothesis) 5) (define (kl:shen.by_hypothesis V2780 V2781 V2782 V2783 V2784) (let ((Case (let ((V2446 (kl:shen.lazyderef V2782 V2783))) (if (pair? V2446) (let ((V2447 (kl:shen.lazyderef (car V2446) V2783))) (if (pair? V2447) (let ((Y (car V2447))) (let ((V2448 (kl:shen.lazyderef (cdr V2447) V2783))) (if (pair? V2448) (let ((V2449 (kl:shen.lazyderef (car V2448) V2783))) (if (eq? (quote :) V2449) (let ((V2450 (kl:shen.lazyderef (cdr V2448) V2783))) (if (pair? V2450) (let ((B (car V2450))) (let ((V2451 (kl:shen.lazyderef (cdr V2450) V2783))) (if (null? V2451) (begin (kl:shen.incinfs) (kl:identical V2780 Y V2783 (lambda () (kl:unify! V2781 B V2783 V2784)))) #f))) #f)) #f)) #f))) #f)) #f)))) (if (kl:= Case #f) (let ((V2452 (kl:shen.lazyderef V2782 V2783))) (if (pair? V2452) (let ((Hyp (cdr V2452))) (begin (kl:shen.incinfs) (kl:shen.by_hypothesis V2780 V2781 Hyp V2783 V2784))) #f)) Case))) (export shen.by_hypothesis) (quote shen.by_hypothesis))
(begin (register-function-arity (quote shen.t*-def) 5) (define (kl:shen.t*-def V2790 V2791 V2792 V2793 V2794) (let ((V2440 (kl:shen.lazyderef V2790 V2793))) (if (pair? V2440) (let ((V2441 (kl:shen.lazyderef (car V2440) V2793))) (if (eq? (quote define) V2441) (let ((V2442 (kl:shen.lazyderef (cdr V2440) V2793))) (if (pair? V2442) (let ((F (car V2442))) (let ((X (cdr V2442))) (let ((Y (kl:shen.newpv V2793))) (let ((E (kl:shen.newpv V2793))) (begin (kl:shen.incinfs) (kl:shen.t*-defh (kl:compile (lambda (Y) (kl:shen.<sig+rules> Y)) X (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n")))) F V2791 V2792 V2793 V2794)))))) #f)) #f)) #f))) (export shen.t*-def) (quote shen.t*-def))
(begin (register-function-arity (quote shen.t*-defh) 6) (define (kl:shen.t*-defh V2801 V2802 V2803 V2804 V2805 V2806) (let ((V2436 (kl:shen.lazyderef V2801 V2805))) (if (pair? V2436) (let ((Sig (car V2436))) (let ((Rules (cdr V2436))) (begin (kl:shen.incinfs) (kl:shen.t*-defhh Sig (kl:shen.ue-sig Sig) V2802 V2803 V2804 Rules V2805 V2806)))) #f))) (export shen.t*-defh) (quote shen.t*-defh))
(begin (register-function-arity (quote shen.t*-defhh) 8) (define (kl:shen.t*-defhh V2815 V2816 V2817 V2818 V2819 V2820 V2821 V2822) (begin (kl:shen.incinfs) (kl:shen.t*-rules V2820 V2816 1 V2817 (cons (cons V2817 (cons (quote :) (cons V2816 (quote ())))) V2819) V2821 (lambda () (kl:shen.memo V2817 V2815 V2818 V2821 V2822))))) (export shen.t*-defhh) (quote shen.t*-defhh))
(begin (register-function-arity (quote shen.memo) 5) (define (kl:shen.memo V2828 V2829 V2830 V2831 V2832) (let ((Jnk (kl:shen.newpv V2831))) (begin (kl:shen.incinfs) (kl:unify! V2830 V2829 V2831 (lambda () (kl:bind Jnk (kl:declare (kl:shen.lazyderef V2828 V2831) (kl:shen.lazyderef V2830 V2831)) V2831 V2832)))))) (export shen.memo) (quote shen.memo))
(begin (register-function-arity (quote shen.<sig+rules>) 1) (define (kl:shen.<sig+rules> V2834) (let ((Parse_shen.<signature> (kl:shen.<signature> V2834))) (if (kl:not (kl:= (kl:fail) Parse_shen.<signature>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<signature>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<signature>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail)))) (export shen.<sig+rules>) (quote shen.<sig+rules>))
(begin (register-function-arity (quote shen.<non-ll-rules>) 1) (define (kl:shen.<non-ll-rules> V2836) (let ((YaccParse (let ((Parse_shen.<rule> (kl:shen.<rule> V2836))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (let ((Parse_shen.<non-ll-rules> (kl:shen.<non-ll-rules> Parse_shen.<rule>))) (if (kl:not (kl:= (kl:fail) Parse_shen.<non-ll-rules>)) (kl:shen.pair (car Parse_shen.<non-ll-rules>) (cons (kl:shen.hdtl Parse_shen.<rule>) (kl:shen.hdtl Parse_shen.<non-ll-rules>))) (kl:fail))) (kl:fail))))) (if (kl:= YaccParse (kl:fail)) (let ((Parse_shen.<rule> (kl:shen.<rule> V2836))) (if (kl:not (kl:= (kl:fail) Parse_shen.<rule>)) (kl:shen.pair (car Parse_shen.<rule>) (cons (kl:shen.hdtl Parse_shen.<rule>) (quote ()))) (kl:fail))) YaccParse))) (export shen.<non-ll-rules>) (quote shen.<non-ll-rules>))
(begin (register-function-arity (quote shen.ue) 1) (define (kl:shen.ue V2838) (cond ((and (pair? V2838) (and (pair? (cdr V2838)) (and (null? (cdr (cdr V2838))) (eq? (car V2838) (quote protect))))) V2838) ((pair? V2838) (kl:map (lambda (Z) (kl:shen.ue Z)) V2838)) ((kl:variable? V2838) (kl:concat (quote &&) V2838)) (#t V2838))) (export shen.ue) (quote shen.ue))
(begin (register-function-arity (quote shen.ue-sig) 1) (define (kl:shen.ue-sig V2840) (cond ((pair? V2840) (kl:map (lambda (Z) (kl:shen.ue-sig Z)) V2840)) ((kl:variable? V2840) (kl:concat (quote &&&) V2840)) (#t V2840))) (export shen.ue-sig) (quote shen.ue-sig))
(begin (register-function-arity (quote shen.ues) 1) (define (kl:shen.ues V2846) (cond ((assert-boolean (kl:shen.ue? V2846)) (cons V2846 (quote ()))) ((pair? V2846) (kl:union (kl:shen.ues (car V2846)) (kl:shen.ues (cdr V2846)))) (#t (quote ())))) (export shen.ues) (quote shen.ues))
(begin (register-function-arity (quote shen.ue?) 1) (define (kl:shen.ue? V2848) (and (kl:symbol? V2848) (assert-boolean (kl:shen.ue-h? (kl:str V2848))))) (export shen.ue?) (quote shen.ue?))
(begin (register-function-arity (quote shen.ue-h?) 1) (define (kl:shen.ue-h? V2856) (cond ((and (assert-boolean (kl:shen.+string? V2856)) (and (equal? "&" (make-string 1 (string-ref V2856 0))) (and (assert-boolean (kl:shen.+string? (string-tail V2856 1))) (equal? "&" (make-string 1 (string-ref (string-tail V2856 1) 0)))))) #t) (#t #f))) (export shen.ue-h?) (quote shen.ue-h?))
(begin (register-function-arity (quote shen.t*-rules) 7) (define (kl:shen.t*-rules V2864 V2865 V2866 V2867 V2868 V2869 V2870) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V2420 (kl:shen.lazyderef V2864 V2869))) (if (null? V2420) (begin (kl:shen.incinfs) (kl:thaw V2870)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2421 (kl:shen.lazyderef V2864 V2869))) (if (pair? V2421) (let ((Rule (car V2421))) (let ((Rules (cdr V2421))) (begin (kl:shen.incinfs) (kl:shen.t*-rule (kl:shen.ue Rule) V2865 V2868 V2869 (lambda () (kl:cut Throwcontrol V2869 (lambda () (kl:shen.t*-rules Rules V2865 (+ V2866 1) V2867 V2868 V2869 V2870)))))))) #f)))) (if (kl:= Case #f) (let ((Err (kl:shen.newpv V2869))) (begin (kl:shen.incinfs) (kl:bind Err (simple-error (string-append "type error in rule " (kl:shen.app (kl:shen.lazyderef V2866 V2869) (string-append " of " (kl:shen.app (kl:shen.lazyderef V2867 V2869) "" (quote shen.a))) (quote shen.a)))) V2869 V2870))) Case)) Case))))) (export shen.t*-rules) (quote shen.t*-rules))
(begin (register-function-arity (quote shen.t*-rule) 5) (define (kl:shen.t*-rule V2876 V2877 V2878 V2879 V2880) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((V2412 (kl:shen.lazyderef V2876 V2879))) (if (pair? V2412) (let ((Patterns (car V2412))) (let ((V2413 (kl:shen.lazyderef (cdr V2412) V2879))) (if (pair? V2413) (let ((Action (car V2413))) (let ((V2414 (kl:shen.lazyderef (cdr V2413) V2879))) (if (null? V2414) (let ((NewHyps (kl:shen.newpv V2879))) (begin (kl:shen.incinfs) (kl:shen.newhyps (kl:shen.placeholders Patterns) V2878 NewHyps V2879 (lambda () (kl:shen.t*-patterns Patterns V2877 NewHyps V2879 (lambda () (kl:cut Throwcontrol V2879 (lambda () (kl:shen.t*-action (kl:shen.curry (kl:shen.ue Action)) (kl:shen.result-type Patterns V2877) (kl:shen.patthyps Patterns V2877 V2878) V2879 V2880))))))))) #f))) #f))) #f))))) (export shen.t*-rule) (quote shen.t*-rule))
(begin (register-function-arity (quote shen.placeholders) 1) (define (kl:shen.placeholders V2886) (cond ((assert-boolean (kl:shen.ue? V2886)) (cons V2886 (quote ()))) ((pair? V2886) (kl:union (kl:shen.placeholders (car V2886)) (kl:shen.placeholders (cdr V2886)))) (#t (quote ())))) (export shen.placeholders) (quote shen.placeholders))
(begin (register-function-arity (quote shen.newhyps) 5) (define (kl:shen.newhyps V2892 V2893 V2894 V2895 V2896) (let ((Case (let ((V2399 (kl:shen.lazyderef V2892 V2895))) (if (null? V2399) (begin (kl:shen.incinfs) (kl:unify! V2894 V2893 V2895 V2896)) #f)))) (if (kl:= Case #f) (let ((V2400 (kl:shen.lazyderef V2892 V2895))) (if (pair? V2400) (let ((V2395 (car V2400))) (let ((Vs (cdr V2400))) (let ((V2401 (kl:shen.lazyderef V2894 V2895))) (if (pair? V2401) (let ((V2402 (kl:shen.lazyderef (car V2401) V2895))) (if (pair? V2402) (let ((V (car V2402))) (let ((V2403 (kl:shen.lazyderef (cdr V2402) V2895))) (if (pair? V2403) (let ((V2404 (kl:shen.lazyderef (car V2403) V2895))) (if (eq? (quote :) V2404) (let ((V2405 (kl:shen.lazyderef (cdr V2403) V2895))) (if (pair? V2405) (let ((A (car V2405))) (let ((V2406 (kl:shen.lazyderef (cdr V2405) V2895))) (if (null? V2406) (let ((NewHyp (cdr V2401))) (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (if (kl:shen.pvar? V2406) (begin (kl:shen.bindv V2406 (quote ()) V2895) (let ((Result (let ((NewHyp (cdr V2401))) (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896))))))) (begin (kl:shen.unbindv V2406 V2895) Result))) #f)))) (if (kl:shen.pvar? V2405) (let ((A (kl:shen.newpv V2895))) (begin (kl:shen.bindv V2405 (cons A (quote ())) V2895) (let ((Result (let ((NewHyp (cdr V2401))) (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896))))))) (begin (kl:shen.unbindv V2405 V2895) Result)))) #f))) (if (kl:shen.pvar? V2404) (begin (kl:shen.bindv V2404 (quote :) V2895) (let ((Result (let ((V2407 (kl:shen.lazyderef (cdr V2403) V2895))) (if (pair? V2407) (let ((A (car V2407))) (let ((V2408 (kl:shen.lazyderef (cdr V2407) V2895))) (if (null? V2408) (let ((NewHyp (cdr V2401))) (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896))))) (if (kl:shen.pvar? V2408) (begin (kl:shen.bindv V2408 (quote ()) V2895) (let ((Result (let ((NewHyp (cdr V2401))) (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896))))))) (begin (kl:shen.unbindv V2408 V2895) Result))) #f)))) (if (kl:shen.pvar? V2407) (let ((A (kl:shen.newpv V2895))) (begin (kl:shen.bindv V2407 (cons A (quote ())) V2895) (let ((Result (let ((NewHyp (cdr V2401))) (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896))))))) (begin (kl:shen.unbindv V2407 V2895) Result)))) #f))))) (begin (kl:shen.unbindv V2404 V2895) Result))) #f))) (if (kl:shen.pvar? V2403) (let ((A (kl:shen.newpv V2895))) (begin (kl:shen.bindv V2403 (cons (quote :) (cons A (quote ()))) V2895) (let ((Result (let ((NewHyp (cdr V2401))) (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896))))))) (begin (kl:shen.unbindv V2403 V2895) Result)))) #f)))) (if (kl:shen.pvar? V2402) (let ((V (kl:shen.newpv V2895))) (let ((A (kl:shen.newpv V2895))) (begin (kl:shen.bindv V2402 (cons V (cons (quote :) (cons A (quote ())))) V2895) (let ((Result (let ((NewHyp (cdr V2401))) (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896))))))) (begin (kl:shen.unbindv V2402 V2895) Result))))) #f))) (if (kl:shen.pvar? V2401) (let ((V (kl:shen.newpv V2895))) (let ((A (kl:shen.newpv V2895))) (let ((NewHyp (kl:shen.newpv V2895))) (begin (kl:shen.bindv V2401 (cons (cons V (cons (quote :) (cons A (quote ())))) NewHyp) V2895) (let ((Result (begin (kl:shen.incinfs) (kl:unify! V V2395 V2895 (lambda () (kl:shen.newhyps Vs V2893 NewHyp V2895 V2896)))))) (begin (kl:shen.unbindv V2401 V2895) Result)))))) #f))))) #f)) Case))) (export shen.newhyps) (quote shen.newhyps))
(begin (register-function-arity (quote shen.patthyps) 3) (define (kl:shen.patthyps V2902 V2903 V2904) (cond ((null? V2902) V2904) ((and (pair? V2902) (and (pair? V2903) (and (pair? (cdr V2903)) (and (eq? (quote -->) (car (cdr V2903))) (and (pair? (cdr (cdr V2903))) (null? (cdr (cdr (cdr V2903))))))))) (kl:adjoin (cons (kl:shen.curry (car V2902)) (cons (quote :) (cons (car V2903) (quote ())))) (kl:shen.patthyps (cdr V2902) (car (cdr (cdr V2903))) V2904))) (#t (kl:shen.f_error (quote shen.patthyps))))) (export shen.patthyps) (quote shen.patthyps))
(begin (register-function-arity (quote shen.result-type) 2) (define (kl:shen.result-type V2911 V2912) (cond ((and (null? V2911) (and (pair? V2912) (and (eq? (quote -->) (car V2912)) (and (pair? (cdr V2912)) (null? (cdr (cdr V2912))))))) (car (cdr V2912))) ((null? V2911) V2912) ((and (pair? V2911) (and (pair? V2912) (and (pair? (cdr V2912)) (and (eq? (quote -->) (car (cdr V2912))) (and (pair? (cdr (cdr V2912))) (null? (cdr (cdr (cdr V2912))))))))) (kl:shen.result-type (cdr V2911) (car (cdr (cdr V2912))))) (#t (kl:shen.f_error (quote shen.result-type))))) (export shen.result-type) (quote shen.result-type))
(begin (register-function-arity (quote shen.t*-patterns) 5) (define (kl:shen.t*-patterns V2918 V2919 V2920 V2921 V2922) (let ((Case (let ((V2387 (kl:shen.lazyderef V2918 V2921))) (if (null? V2387) (begin (kl:shen.incinfs) (kl:thaw V2922)) #f)))) (if (kl:= Case #f) (let ((V2388 (kl:shen.lazyderef V2918 V2921))) (if (pair? V2388) (let ((Pattern (car V2388))) (let ((Patterns (cdr V2388))) (let ((V2389 (kl:shen.lazyderef V2919 V2921))) (if (pair? V2389) (let ((A (car V2389))) (let ((V2390 (kl:shen.lazyderef (cdr V2389) V2921))) (if (pair? V2390) (let ((V2391 (kl:shen.lazyderef (car V2390) V2921))) (if (eq? (quote -->) V2391) (let ((V2392 (kl:shen.lazyderef (cdr V2390) V2921))) (if (pair? V2392) (let ((B (car V2392))) (let ((V2393 (kl:shen.lazyderef (cdr V2392) V2921))) (if (null? V2393) (begin (kl:shen.incinfs) (kl:shen.t* (cons (kl:shen.curry Pattern) (cons (quote :) (cons A (quote ())))) V2920 V2921 (lambda () (kl:shen.t*-patterns Patterns B V2920 V2921 V2922)))) #f))) #f)) #f)) #f))) #f)))) #f)) Case))) (export shen.t*-patterns) (quote shen.t*-patterns))
(begin (register-function-arity (quote shen.t*-action) 5) (define (kl:shen.t*-action V2928 V2929 V2930 V2931 V2932) (let ((Throwcontrol (kl:shen.catchpoint))) (kl:shen.cutpoint Throwcontrol (let ((Case (let ((V2364 (kl:shen.lazyderef V2928 V2931))) (if (pair? V2364) (let ((V2365 (kl:shen.lazyderef (car V2364) V2931))) (if (eq? (quote where) V2365) (let ((V2366 (kl:shen.lazyderef (cdr V2364) V2931))) (if (pair? V2366) (let ((P (car V2366))) (let ((V2367 (kl:shen.lazyderef (cdr V2366) V2931))) (if (pair? V2367) (let ((Action (car V2367))) (let ((V2368 (kl:shen.lazyderef (cdr V2367) V2931))) (if (null? V2368) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2931 (lambda () (kl:shen.t* (cons P (cons (quote :) (cons (quote boolean) (quote ())))) V2930 V2931 (lambda () (kl:cut Throwcontrol V2931 (lambda () (kl:shen.t*-action Action V2929 (cons (cons P (cons (quote :) (cons (quote verified) (quote ())))) V2930) V2931 V2932)))))))) #f))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2369 (kl:shen.lazyderef V2928 V2931))) (if (pair? V2369) (let ((V2370 (kl:shen.lazyderef (car V2369) V2931))) (if (eq? (quote shen.choicepoint!) V2370) (let ((V2371 (kl:shen.lazyderef (cdr V2369) V2931))) (if (pair? V2371) (let ((V2372 (kl:shen.lazyderef (car V2371) V2931))) (if (pair? V2372) (let ((V2373 (kl:shen.lazyderef (car V2372) V2931))) (if (pair? V2373) (let ((V2374 (kl:shen.lazyderef (car V2373) V2931))) (if (eq? (quote fail-if) V2374) (let ((V2375 (kl:shen.lazyderef (cdr V2373) V2931))) (if (pair? V2375) (let ((F (car V2375))) (let ((V2376 (kl:shen.lazyderef (cdr V2375) V2931))) (if (null? V2376) (let ((V2377 (kl:shen.lazyderef (cdr V2372) V2931))) (if (pair? V2377) (let ((Action (car V2377))) (let ((V2378 (kl:shen.lazyderef (cdr V2377) V2931))) (if (null? V2378) (let ((V2379 (kl:shen.lazyderef (cdr V2371) V2931))) (if (null? V2379) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2931 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons F (cons Action (quote ()))) (quote ()))) (cons Action (quote ())))) V2929 V2930 V2931 V2932)))) #f)) #f))) #f)) #f))) #f)) #f)) #f)) #f)) #f)) #f)) #f)))) (if (kl:= Case #f) (let ((Case (let ((V2380 (kl:shen.lazyderef V2928 V2931))) (if (pair? V2380) (let ((V2381 (kl:shen.lazyderef (car V2380) V2931))) (if (eq? (quote shen.choicepoint!) V2381) (let ((V2382 (kl:shen.lazyderef (cdr V2380) V2931))) (if (pair? V2382) (let ((Action (car V2382))) (let ((V2383 (kl:shen.lazyderef (cdr V2382) V2931))) (if (null? V2383) (begin (kl:shen.incinfs) (kl:cut Throwcontrol V2931 (lambda () (kl:shen.t*-action (cons (quote where) (cons (cons (quote not) (cons (cons (cons (quote =) (cons Action (quote ()))) (cons (cons (quote fail) (quote ())) (quote ()))) (quote ()))) (cons Action (quote ())))) V2929 V2930 V2931 V2932)))) #f))) #f)) #f)) #f)))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:shen.t* (cons V2928 (cons (quote :) (cons V2929 (quote ())))) V2930 V2931 V2932)) Case)) Case)) Case))))) (export shen.t*-action) (quote shen.t*-action))
(begin (register-function-arity (quote findall) 5) (define (kl:findall V2938 V2939 V2940 V2941 V2942) (let ((B (kl:shen.newpv V2941))) (let ((A (kl:shen.newpv V2941))) (begin (kl:shen.incinfs) (kl:bind A (kl:gensym (quote shen.a)) V2941 (lambda () (kl:bind B (kl:set (kl:shen.lazyderef A V2941) (quote ())) V2941 (lambda () (kl:shen.findallhelp V2938 V2939 V2940 A V2941 V2942))))))))) (export findall) (quote findall))
(begin (register-function-arity (quote shen.findallhelp) 6) (define (kl:shen.findallhelp V2949 V2950 V2951 V2952 V2953 V2954) (let ((Case (begin (kl:shen.incinfs) (kl:call V2950 V2953 (lambda () (kl:shen.remember V2952 V2949 V2953 (lambda () (kl:fwhen #f V2953 V2954)))))))) (if (kl:= Case #f) (begin (kl:shen.incinfs) (kl:bind V2951 (kl:value (kl:shen.lazyderef V2952 V2953)) V2953 V2954)) Case))) (export shen.findallhelp) (quote shen.findallhelp))
(begin (register-function-arity (quote shen.remember) 4) (define (kl:shen.remember V2959 V2960 V2961 V2962) (let ((B (kl:shen.newpv V2961))) (begin (kl:shen.incinfs) (kl:bind B (kl:set (kl:shen.deref V2959 V2961) (cons (kl:shen.deref V2960 V2961) (kl:value (kl:shen.deref V2959 V2961)))) V2961 V2962)))) (export shen.remember) (quote shen.remember))

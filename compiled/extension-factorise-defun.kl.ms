(module "compiled/extension-factorise-defun.kl")
"Copyright (c) 2012-2019 Bruno Deferrari.  All rights reserved.\nBSD 3-Clause License: http://opensource.org/licenses/BSD-3-Clause"
(begin (register-function-arity (quote shen.x.factorise-defun.factorise-defun) 1) (define (kl:shen.x.factorise-defun.factorise-defun V4873) (cond ((and (pair? V4873) (and (eq? (quote defun) (car V4873)) (and (pair? (cdr V4873)) (and (pair? (cdr (cdr V4873))) (and (pair? (cdr (cdr (cdr V4873)))) (and (pair? (car (cdr (cdr (cdr V4873))))) (and (eq? (quote cond) (car (car (cdr (cdr (cdr V4873)))))) (null? (cdr (cdr (cdr (cdr V4873)))))))))))) (cons (quote defun) (cons (car (cdr V4873)) (cons (car (cdr (cdr V4873))) (cons (kl:shen.x.factorise-defun.factorise-cond (car (cdr (cdr (cdr V4873)))) (cons (quote shen.f_error) (cons (car (cdr V4873)) (quote ()))) (car (cdr (cdr V4873)))) (quote ())))))) (#t V4873))) (export shen.x.factorise-defun.factorise-defun) (quote shen.x.factorise-defun.factorise-defun))
(begin (register-function-arity (quote shen.x.factorise-defun.factorise-cond) 3) (define (kl:shen.x.factorise-defun.factorise-cond V4885 V4886 V4887) (cond ((and (pair? V4885) (eq? (quote cond) (car V4885))) (kl:shen.x.factorise-defun.inline-mono-labels (kl:shen.x.factorise-defun.rebranch (kl:shen.x.factorise-defun.add-returns (cdr V4885)) V4886) V4887)) (#t V4885))) (export shen.x.factorise-defun.factorise-cond) (quote shen.x.factorise-defun.factorise-cond))
(begin (register-function-arity (quote shen.x.factorise-defun.add-returns) 1) (define (kl:shen.x.factorise-defun.add-returns V4889) (cond ((null? V4889) (quote ())) ((and (pair? V4889) (and (pair? (car V4889)) (and (pair? (cdr (car V4889))) (null? (cdr (cdr (car V4889))))))) (cons (cons (car (car V4889)) (cons (cons (quote %%return) (cdr (car V4889))) (quote ()))) (kl:shen.x.factorise-defun.add-returns (cdr V4889)))) (#t (kl:shen.f_error (quote shen.x.factorise-defun.add-returns))))) (export shen.x.factorise-defun.add-returns) (quote shen.x.factorise-defun.add-returns))
(begin (register-function-arity (quote shen.x.factorise-defun.generate-label) 0) (define (kl:shen.x.factorise-defun.generate-label) (kl:gensym (quote %%label))) (export shen.x.factorise-defun.generate-label) (quote shen.x.factorise-defun.generate-label))
(begin (register-function-arity (quote shen.x.factorise-defun.free-variables) 2) (define (kl:shen.x.factorise-defun.free-variables V4892 V4893) (kl:reverse (kl:shen.x.factorise-defun.free-variables-h V4892 V4893 (quote ())))) (export shen.x.factorise-defun.free-variables) (quote shen.x.factorise-defun.free-variables))
(begin (register-function-arity (quote shen.x.factorise-defun.free-variables-h) 3) (define (kl:shen.x.factorise-defun.free-variables-h V4905 V4906 V4907) (cond ((and (pair? V4905) (and (eq? (quote let) (car V4905)) (and (pair? (cdr V4905)) (and (pair? (cdr (cdr V4905))) (and (pair? (cdr (cdr (cdr V4905)))) (null? (cdr (cdr (cdr (cdr V4905)))))))))) (kl:shen.x.factorise-defun.free-variables-h (car (cdr (cdr (cdr V4905)))) (kl:remove (car (cdr V4905)) V4906) (kl:shen.x.factorise-defun.free-variables-h (car (cdr (cdr V4905))) V4906 V4907))) ((and (pair? V4905) (and (eq? (quote lambda) (car V4905)) (and (pair? (cdr V4905)) (and (pair? (cdr (cdr V4905))) (null? (cdr (cdr (cdr V4905)))))))) (kl:shen.x.factorise-defun.free-variables-h (car (cdr (cdr V4905))) (kl:remove (car (cdr V4905)) V4906) V4907)) ((pair? V4905) (kl:shen.x.factorise-defun.free-variables-h (cdr V4905) V4906 (kl:shen.x.factorise-defun.free-variables-h (car V4905) V4906 V4907))) ((kl:element? V4905 V4906) (kl:adjoin V4905 V4907)) (#t V4907))) (export shen.x.factorise-defun.free-variables-h) (quote shen.x.factorise-defun.free-variables-h))
(begin (register-function-arity (quote shen.x.factorise-defun.attach-free-variables) 2) (define (kl:shen.x.factorise-defun.attach-free-variables V4910 V4911) (cond ((and (pair? V4910) (and (eq? (quote %%let-label) (car V4910)) (and (pair? (cdr V4910)) (and (pair? (cdr (cdr V4910))) (and (pair? (cdr (cdr (cdr V4910)))) (null? (cdr (cdr (cdr (cdr V4910)))))))))) (let ((FreeVars (kl:shen.x.factorise-defun.free-variables (car (cdr (cdr V4910))) V4911))) (let ((NewBody (if (null? FreeVars) (car (cdr (cdr (cdr V4910)))) (kl:subst (cons (quote %%goto-label) (cons (car (cdr V4910)) FreeVars)) (cons (quote %%goto-label) (cons (car (cdr V4910)) (quote ()))) (car (cdr (cdr (cdr V4910)))))))) (cons (quote %%let-label) (cons (cons (car (cdr V4910)) FreeVars) (cons (car (cdr (cdr V4910))) (cons (kl:shen.x.factorise-defun.inline-mono-labels NewBody V4911) (quote ())))))))) (#t (kl:shen.f_error (quote shen.x.factorise-defun.attach-free-variables))))) (export shen.x.factorise-defun.attach-free-variables) (quote shen.x.factorise-defun.attach-free-variables))
(begin (register-function-arity (quote shen.x.factorise-defun.inline-mono-labels) 2) (define (kl:shen.x.factorise-defun.inline-mono-labels V4918 V4919) (cond ((and (pair? V4918) (and (eq? (quote %%let-label) (car V4918)) (and (pair? (cdr V4918)) (and (pair? (cdr (cdr V4918))) (and (pair? (cdr (cdr (cdr V4918)))) (and (null? (cdr (cdr (cdr (cdr V4918))))) (> (kl:occurrences (cons (quote %%goto-label) (cons (car (cdr V4918)) (quote ()))) (car (cdr (cdr (cdr V4918))))) 1))))))) (kl:shen.x.factorise-defun.attach-free-variables (cons (quote %%let-label) (cons (car (cdr V4918)) (cons (kl:shen.x.factorise-defun.inline-mono-labels (car (cdr (cdr V4918))) V4919) (cdr (cdr (cdr V4918)))))) V4919)) ((and (pair? V4918) (and (eq? (quote %%let-label) (car V4918)) (and (pair? (cdr V4918)) (and (pair? (cdr (cdr V4918))) (and (pair? (cdr (cdr (cdr V4918)))) (null? (cdr (cdr (cdr (cdr V4918)))))))))) (kl:subst (kl:shen.x.factorise-defun.inline-mono-labels (car (cdr (cdr V4918))) V4919) (cons (quote %%goto-label) (cons (car (cdr V4918)) (quote ()))) (kl:shen.x.factorise-defun.inline-mono-labels (car (cdr (cdr (cdr V4918)))) V4919))) ((and (pair? V4918) (and (eq? (quote if) (car V4918)) (and (pair? (cdr V4918)) (and (pair? (cdr (cdr V4918))) (and (pair? (cdr (cdr (cdr V4918)))) (null? (cdr (cdr (cdr (cdr V4918)))))))))) (cons (quote if) (cons (car (cdr V4918)) (cons (kl:shen.x.factorise-defun.inline-mono-labels (car (cdr (cdr V4918))) V4919) (cons (kl:shen.x.factorise-defun.inline-mono-labels (car (cdr (cdr (cdr V4918)))) V4919) (quote ())))))) ((and (pair? V4918) (and (eq? (quote let) (car V4918)) (and (pair? (cdr V4918)) (and (pair? (cdr (cdr V4918))) (and (pair? (cdr (cdr (cdr V4918)))) (null? (cdr (cdr (cdr (cdr V4918)))))))))) (cons (quote let) (cons (car (cdr V4918)) (cons (car (cdr (cdr V4918))) (cons (kl:shen.x.factorise-defun.inline-mono-labels (car (cdr (cdr (cdr V4918)))) (cons (car (cdr V4918)) V4919)) (quote ())))))) (#t V4918))) (export shen.x.factorise-defun.inline-mono-labels) (quote shen.x.factorise-defun.inline-mono-labels))
(begin (register-function-arity (quote shen.x.factorise-defun.rebranch) 2) (define (kl:shen.x.factorise-defun.rebranch V4926 V4927) (cond ((null? V4926) V4927) ((and (pair? V4926) (and (pair? (car V4926)) (and (kl:= #t (car (car V4926))) (and (pair? (cdr (car V4926))) (null? (cdr (cdr (car V4926)))))))) (car (cdr (car V4926)))) ((and (pair? V4926) (and (pair? (car V4926)) (and (pair? (car (car V4926))) (and (eq? (quote and) (car (car (car V4926)))) (and (pair? (cdr (car (car V4926)))) (and (pair? (cdr (cdr (car (car V4926))))) (and (null? (cdr (cdr (cdr (car (car V4926)))))) (and (pair? (cdr (car V4926))) (null? (cdr (cdr (car V4926)))))))))))) (let ((TrueBranch (kl:shen.x.factorise-defun.true-branch (car (cdr (car (car V4926)))) V4926))) (let ((FalseBranch (kl:shen.x.factorise-defun.false-branch (car (cdr (car (car V4926)))) V4926))) (kl:shen.x.factorise-defun.rebranch-h (car (cdr (car (car V4926)))) TrueBranch FalseBranch V4927)))) ((and (pair? V4926) (and (pair? (car V4926)) (and (pair? (cdr (car V4926))) (null? (cdr (cdr (car V4926))))))) (let ((TrueBranch (kl:shen.x.factorise-defun.true-branch (car (car V4926)) V4926))) (let ((FalseBranch (kl:shen.x.factorise-defun.false-branch (car (car V4926)) V4926))) (kl:shen.x.factorise-defun.rebranch-h (car (car V4926)) TrueBranch FalseBranch V4927)))) (#t (kl:shen.f_error (quote shen.x.factorise-defun.rebranch))))) (export shen.x.factorise-defun.rebranch) (quote shen.x.factorise-defun.rebranch))
(begin (register-function-arity (quote shen.x.factorise-defun.rebranch-h) 4) (define (kl:shen.x.factorise-defun.rebranch-h V4932 V4933 V4934 V4935) (let ((NewElse (kl:shen.x.factorise-defun.rebranch V4934 V4935))) (kl:shen.x.factorise-defun.with-labelled-else NewElse (lambda (GotoElse) (kl:shen.x.factorise-defun.merge-same-else-ifs (cons (quote if) (cons V4932 (cons (kl:shen.x.factorise-defun.optimize-selectors V4932 (kl:shen.x.factorise-defun.rebranch V4933 GotoElse)) (cons GotoElse (quote ())))))))))) (export shen.x.factorise-defun.rebranch-h) (quote shen.x.factorise-defun.rebranch-h))
(begin (register-function-arity (quote shen.x.factorise-defun.true-branch) 2) (define (kl:shen.x.factorise-defun.true-branch V4948 V4949) (cond ((and (pair? V4949) (and (pair? (car V4949)) (and (pair? (car (car V4949))) (and (eq? (quote and) (car (car (car V4949)))) (and (pair? (cdr (car (car V4949)))) (and (pair? (cdr (cdr (car (car V4949))))) (and (null? (cdr (cdr (cdr (car (car V4949)))))) (and (pair? (cdr (car V4949))) (and (null? (cdr (cdr (car V4949)))) (kl:= (car (cdr (car (car V4949)))) V4948)))))))))) (cons (cons (car (cdr (cdr (car (car V4949))))) (cdr (car V4949))) (kl:shen.x.factorise-defun.true-branch (car (cdr (car (car V4949)))) (cdr V4949)))) ((and (pair? V4949) (and (pair? (car V4949)) (and (pair? (cdr (car V4949))) (and (null? (cdr (cdr (car V4949)))) (kl:= (car (car V4949)) V4948))))) (cons (cons #t (cdr (car V4949))) (quote ()))) (#t (quote ())))) (export shen.x.factorise-defun.true-branch) (quote shen.x.factorise-defun.true-branch))
(begin (register-function-arity (quote shen.x.factorise-defun.false-branch) 2) (define (kl:shen.x.factorise-defun.false-branch V4958 V4959) (cond ((and (pair? V4959) (and (pair? (car V4959)) (and (pair? (car (car V4959))) (and (eq? (quote and) (car (car (car V4959)))) (and (pair? (cdr (car (car V4959)))) (and (pair? (cdr (cdr (car (car V4959))))) (and (null? (cdr (cdr (cdr (car (car V4959)))))) (and (pair? (cdr (car V4959))) (and (null? (cdr (cdr (car V4959)))) (kl:= (car (cdr (car (car V4959)))) V4958)))))))))) (kl:shen.x.factorise-defun.false-branch (car (cdr (car (car V4959)))) (cdr V4959))) ((and (pair? V4959) (and (pair? (car V4959)) (and (pair? (cdr (car V4959))) (and (null? (cdr (cdr (car V4959)))) (kl:= (car (car V4959)) V4958))))) (kl:shen.x.factorise-defun.false-branch (car (car V4959)) (cdr V4959))) (#t V4959))) (export shen.x.factorise-defun.false-branch) (quote shen.x.factorise-defun.false-branch))
(begin (register-function-arity (quote shen.x.factorise-defun.with-labelled-else) 2) (define (kl:shen.x.factorise-defun.with-labelled-else V4962 V4963) (cond ((and (pair? V4962) (and (eq? (quote %%return) (car V4962)) (and (pair? (cdr V4962)) (and (null? (cdr (cdr V4962))) (kl:not (pair? (car (cdr V4962)))))))) (V4963 V4962)) ((and (pair? V4962) (and (eq? (quote fail) (car V4962)) (null? (cdr V4962)))) (V4963 V4962)) ((and (pair? V4962) (and (eq? (quote %%goto-label) (car V4962)) (and (pair? (cdr V4962)) (null? (cdr (cdr V4962)))))) (V4963 V4962)) (#t (let ((Label (kl:shen.x.factorise-defun.generate-label))) (cons (quote %%let-label) (cons Label (cons V4962 (cons (V4963 (cons (quote %%goto-label) (cons Label (quote ())))) (quote ()))))))))) (export shen.x.factorise-defun.with-labelled-else) (quote shen.x.factorise-defun.with-labelled-else))
(begin (register-function-arity (quote shen.x.factorise-defun.merge-same-else-ifs) 1) (define (kl:shen.x.factorise-defun.merge-same-else-ifs V4966) (cond ((and (pair? V4966) (and (eq? (quote if) (car V4966)) (and (pair? (cdr V4966)) (and (pair? (cdr (cdr V4966))) (and (pair? (car (cdr (cdr V4966)))) (and (eq? (quote if) (car (car (cdr (cdr V4966))))) (and (pair? (cdr (car (cdr (cdr V4966))))) (and (pair? (cdr (cdr (car (cdr (cdr V4966)))))) (and (pair? (cdr (cdr (cdr (car (cdr (cdr V4966))))))) (and (null? (cdr (cdr (cdr (cdr (car (cdr (cdr V4966)))))))) (and (pair? (cdr (cdr (cdr V4966)))) (and (null? (cdr (cdr (cdr (cdr V4966))))) (kl:= (car (cdr (cdr (cdr V4966)))) (car (cdr (cdr (cdr (car (cdr (cdr V4966)))))))))))))))))))) (cons (quote if) (cons (cons (quote and) (cons (car (cdr V4966)) (cons (car (cdr (car (cdr (cdr V4966))))) (quote ())))) (cons (car (cdr (cdr (car (cdr (cdr V4966)))))) (cdr (cdr (cdr V4966))))))) (#t V4966))) (export shen.x.factorise-defun.merge-same-else-ifs) (quote shen.x.factorise-defun.merge-same-else-ifs))
(begin (register-function-arity (quote shen.x.factorise-defun.concat/) 2) (define (kl:shen.x.factorise-defun.concat/ V4969 V4970) (kl:concat V4969 (kl:concat (quote /) V4970))) (export shen.x.factorise-defun.concat/) (quote shen.x.factorise-defun.concat/))
(begin (register-function-arity (quote shen.x.factorise-defun.exp-var) 1) (define (kl:shen.x.factorise-defun.exp-var V4974) (cond ((and (pair? V4974) (and (pair? (cdr V4974)) (and (null? (cdr (cdr V4974))) (kl:symbol? (car V4974))))) (kl:shen.x.factorise-defun.concat/ (kl:shen.x.factorise-defun.exp-var (car (cdr V4974))) (car V4974))) ((pair? V4974) (kl:gensym (car V4974))) (#t V4974))) (export shen.x.factorise-defun.exp-var) (quote shen.x.factorise-defun.exp-var))
(begin (register-function-arity (quote shen.x.factorise-defun.optimize-selectors) 2) (define (kl:shen.x.factorise-defun.optimize-selectors V4977 V4978) (kl:shen.x.factorise-defun.bind-repeating-selectors (kl:shen.x.factorise-defun.test->selectors V4977) V4978)) (export shen.x.factorise-defun.optimize-selectors) (quote shen.x.factorise-defun.optimize-selectors))
(begin (register-function-arity (quote shen.x.factorise-defun.test->selectors) 1) (define (kl:shen.x.factorise-defun.test->selectors V4984) (cond ((and (pair? V4984) (and (eq? (quote cons?) (car V4984)) (and (pair? (cdr V4984)) (null? (cdr (cdr V4984)))))) (cons (cons (quote hd) (cdr V4984)) (cons (cons (quote tl) (cdr V4984)) (quote ())))) ((and (pair? V4984) (and (eq? (quote tuple?) (car V4984)) (and (pair? (cdr V4984)) (null? (cdr (cdr V4984)))))) (cons (cons (quote fst) (cdr V4984)) (cons (cons (quote snd) (cdr V4984)) (quote ())))) ((and (pair? V4984) (and (eq? (quote shen.+string?) (car V4984)) (and (pair? (cdr V4984)) (null? (cdr (cdr V4984)))))) (cons (cons (quote hdstr) (cdr V4984)) (cons (cons (quote tlstr) (cdr V4984)) (quote ())))) ((and (pair? V4984) (and (eq? (quote shen.+vector?) (car V4984)) (and (pair? (cdr V4984)) (null? (cdr (cdr V4984)))))) (cons (cons (quote hdv) (cdr V4984)) (cons (cons (quote tlv) (cdr V4984)) (quote ())))) (#t (let ((Result (kl:shen.x.factorise-defun.apply-selector-handlers (kl:value (quote shen.x.factorise-defun.*selector-handlers*)) V4984))) (if (kl:= Result (kl:fail)) (quote ()) Result))))) (export shen.x.factorise-defun.test->selectors) (quote shen.x.factorise-defun.test->selectors))
(begin (register-function-arity (quote shen.x.factorise-defun.bind-repeating-selectors) 2) (define (kl:shen.x.factorise-defun.bind-repeating-selectors V4987 V4988) (cond ((pair? V4987) (kl:shen.x.factorise-defun.bind-selector (car V4987) (kl:shen.x.factorise-defun.bind-repeating-selectors (cdr V4987) V4988))) ((null? V4987) V4988) (#t (kl:shen.f_error (quote shen.x.factorise-defun.bind-repeating-selectors))))) (export shen.x.factorise-defun.bind-repeating-selectors) (quote shen.x.factorise-defun.bind-repeating-selectors))
(begin (register-function-arity (quote shen.x.factorise-defun.bind-selector) 2) (define (kl:shen.x.factorise-defun.bind-selector V4995 V4996) (cond ((> (kl:occurrences V4995 V4996) 1) (let ((Var (kl:shen.x.factorise-defun.exp-var V4995))) (cons (quote let) (cons Var (cons V4995 (cons (kl:subst Var V4995 V4996) (quote ()))))))) (#t V4996))) (export shen.x.factorise-defun.bind-selector) (quote shen.x.factorise-defun.bind-selector))
(begin (register-function-arity (quote shen.x.factorise-defun.apply-selector-handlers) 2) (define (kl:shen.x.factorise-defun.apply-selector-handlers V5009 V5010) (cond ((null? V5009) (kl:fail)) (#t (let ((Freeze (lambda () (cond ((pair? V5009) (kl:shen.x.factorise-defun.apply-selector-handlers (cdr V5009) V5010)) (#t (kl:shen.f_error (quote shen.x.factorise-defun.apply-selector-handlers))))))) (if (pair? V5009) (let ((Result ((car V5009) V5010))) (if (kl:= Result (kl:fail)) (kl:thaw Freeze) Result)) (kl:thaw Freeze)))))) (export shen.x.factorise-defun.apply-selector-handlers) (quote shen.x.factorise-defun.apply-selector-handlers))
(begin (register-function-arity (quote shen.x.factorise-defun.initialise) 0) (define (kl:shen.x.factorise-defun.initialise) (begin (kl:set (quote shen.x.factorise-defun.*selector-handlers*) (quote ())) (begin (kl:set (quote shen.x.factorise-defun.*selector-handlers-reg*) (quote ())) (quote shen.x.factorise-defun.done)))) (export shen.x.factorise-defun.initialise) (quote shen.x.factorise-defun.initialise))
(begin (register-function-arity (quote shen.x.factorise-defun.register-selector-handler) 1) (define (kl:shen.x.factorise-defun.register-selector-handler V5012) (cond ((kl:element? V5012 (kl:value (quote shen.x.factorise-defun.*selector-handlers*))) V5012) (#t (begin (kl:set (quote shen.x.factorise-defun.*selector-handlers-reg*) (cons V5012 (kl:value (quote shen.x.factorise-defun.*selector-handlers*)))) (begin (kl:set (quote shen.x.factorise-defun.*selector-handlers*) (cons (kl:function V5012) (kl:value (quote shen.x.factorise-defun.*selector-handlers*)))) V5012))))) (export shen.x.factorise-defun.register-selector-handler) (quote shen.x.factorise-defun.register-selector-handler))
(begin (register-function-arity (quote shen.x.factorise-defun.findpos) 2) (define (kl:shen.x.factorise-defun.findpos V5015 V5016) (guard (lambda (_) (simple-error (kl:shen.app V5015 " is not a selector handler\n" (quote shen.a)))) (kl:shen.findpos V5015 V5016))) (export shen.x.factorise-defun.findpos) (quote shen.x.factorise-defun.findpos))
(begin (register-function-arity (quote shen.x.factorise-defun.unregister-selector-handler) 1) (define (kl:shen.x.factorise-defun.unregister-selector-handler V5018) (let ((Reg (kl:value (quote shen.x.factorise-defun.*selector-handlers-reg*)))) (let ((Pos (kl:shen.x.factorise-defun.findpos V5018 Reg))) (let ((RemoveReg (kl:set (quote shen.x.factorise-defun.*selector-handlers-reg*) (kl:remove V5018 Reg)))) (let ((RemoveFun (kl:set (quote shen.x.factorise-defun.*selector-handlers*) (kl:shen.remove-nth Pos (kl:value (quote shen.x.factorise-defun.*selector-handlers*)))))) V5018))))) (export shen.x.factorise-defun.unregister-selector-handler) (quote shen.x.factorise-defun.unregister-selector-handler))

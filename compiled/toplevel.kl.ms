(module "compiled/toplevel.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote shen.repl) 0) (define (kl:shen.repl) (begin (kl:shen.credits) (kl:shen.loop))) (export shen.repl) (quote shen.repl))
(begin (register-function-arity (quote shen.loop) 0) (define (kl:shen.loop) (begin (kl:shen.initialise_environment) (begin (kl:shen.prompt) (begin (guard (lambda (E) (kl:shen.toplevel-display-exception E)) (kl:shen.read-evaluate-print)) (kl:shen.loop))))) (export shen.loop) (quote shen.loop))
(begin (register-function-arity (quote shen.toplevel-display-exception) 1) (define (kl:shen.toplevel-display-exception V2964) (kl:pr (kl:error-to-string V2964) (kl:stoutput))) (export shen.toplevel-display-exception) (quote shen.toplevel-display-exception))
(begin (register-function-arity (quote shen.credits) 0) (define (kl:shen.credits) (begin (kl:shen.prhush "\nShen, copyright (C) 2010-2015 Mark Tarver\n" (kl:stoutput)) (begin (kl:shen.prhush (string-append "www.shenlanguage.org, " (kl:shen.app (kl:value (quote *version*)) "\n" (quote shen.a))) (kl:stoutput)) (begin (kl:shen.prhush (string-append "running under " (kl:shen.app (kl:value (quote *language*)) (string-append ", implementation: " (kl:shen.app (kl:value (quote *implementation*)) "" (quote shen.a))) (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\nport " (kl:shen.app (kl:value (quote *port*)) (string-append " ported by " (kl:shen.app (kl:value (quote *porters*)) "\n" (quote shen.a))) (quote shen.a))) (kl:stoutput)))))) (export shen.credits) (quote shen.credits))
(begin (register-function-arity (quote shen.initialise_environment) 0) (define (kl:shen.initialise_environment) (kl:shen.multiple-set (cons (quote shen.*call*) (cons 0 (cons (quote shen.*infs*) (cons 0 (cons (quote shen.*process-counter*) (cons 0 (cons (quote shen.*catch*) (cons 0 (quote ()))))))))))) (export shen.initialise_environment) (quote shen.initialise_environment))
(begin (register-function-arity (quote shen.multiple-set) 1) (define (kl:shen.multiple-set V2966) (cond ((null? V2966) (quote ())) ((and (pair? V2966) (pair? (cdr V2966))) (begin (kl:set (car V2966) (car (cdr V2966))) (kl:shen.multiple-set (cdr (cdr V2966))))) (#t (kl:shen.f_error (quote shen.multiple-set))))) (export shen.multiple-set) (quote shen.multiple-set))
(begin (register-function-arity (quote destroy) 1) (define (kl:destroy V2968) (kl:declare V2968 (quote symbol))) (export destroy) (quote destroy))
(begin (register-function-arity (quote shen.read-evaluate-print) 0) (define (kl:shen.read-evaluate-print) (let ((Lineread (kl:shen.toplineread))) (let ((History (kl:value (quote shen.*history*)))) (let ((NewLineread (kl:shen.retrieve-from-history-if-needed Lineread History))) (let ((NewHistory (kl:shen.update_history NewLineread History))) (let ((Parsed (kl:fst NewLineread))) (kl:shen.toplevel Parsed))))))) (export shen.read-evaluate-print) (quote shen.read-evaluate-print))
(begin (register-function-arity (quote shen.retrieve-from-history-if-needed) 2) (define (kl:shen.retrieve-from-history-if-needed V2980 V2981) (cond ((and (kl:tuple? V2980) (and (pair? (kl:snd V2980)) (kl:element? (car (kl:snd V2980)) (cons (kl:shen.space) (cons (kl:shen.newline) (quote ())))))) (kl:shen.retrieve-from-history-if-needed (kl:_waspvm_at_p (kl:fst V2980) (cdr (kl:snd V2980))) V2981)) ((and (kl:tuple? V2980) (and (pair? (kl:snd V2980)) (and (pair? (cdr (kl:snd V2980))) (and (null? (cdr (cdr (kl:snd V2980)))) (and (pair? V2981) (and (kl:= (car (kl:snd V2980)) (kl:shen.exclamation)) (kl:= (car (cdr (kl:snd V2980))) (kl:shen.exclamation)))))))) (let ((PastPrint (kl:shen.prbytes (kl:snd (car V2981))))) (car V2981))) ((and (kl:tuple? V2980) (and (pair? (kl:snd V2980)) (kl:= (car (kl:snd V2980)) (kl:shen.exclamation)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V2980)) V2981))) (let ((Find (kl:head (kl:shen.find-past-inputs Key? V2981)))) (let ((PastPrint (kl:shen.prbytes (kl:snd Find)))) Find)))) ((and (kl:tuple? V2980) (and (pair? (kl:snd V2980)) (and (null? (cdr (kl:snd V2980))) (kl:= (car (kl:snd V2980)) (kl:shen.percent))))) (begin (kl:shen.print-past-inputs (lambda (X) #t) (kl:reverse V2981) 0) (kl:abort))) ((and (kl:tuple? V2980) (and (pair? (kl:snd V2980)) (kl:= (car (kl:snd V2980)) (kl:shen.percent)))) (let ((Key? (kl:shen.make-key (cdr (kl:snd V2980)) V2981))) (let ((Pastprint (kl:shen.print-past-inputs Key? (kl:reverse V2981) 0))) (kl:abort)))) (#t V2980))) (export shen.retrieve-from-history-if-needed) (quote shen.retrieve-from-history-if-needed))
(begin (register-function-arity (quote shen.percent) 0) (define (kl:shen.percent) 37) (export shen.percent) (quote shen.percent))
(begin (register-function-arity (quote shen.exclamation) 0) (define (kl:shen.exclamation) 33) (export shen.exclamation) (quote shen.exclamation))
(begin (register-function-arity (quote shen.prbytes) 1) (define (kl:shen.prbytes V2983) (begin (kl:shen.for-each (lambda (Byte) (kl:pr (make-string 1 Byte) (kl:stoutput))) V2983) (kl:nl 1))) (export shen.prbytes) (quote shen.prbytes))
(begin (register-function-arity (quote shen.update_history) 2) (define (kl:shen.update_history V2986 V2987) (kl:set (quote shen.*history*) (cons V2986 V2987))) (export shen.update_history) (quote shen.update_history))
(begin (register-function-arity (quote shen.toplineread) 0) (define (kl:shen.toplineread) (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (quote ()))) (export shen.toplineread) (quote shen.toplineread))
(begin (register-function-arity (quote shen.toplineread_loop) 2) (define (kl:shen.toplineread_loop V2991 V2992) (cond ((kl:= V2991 (kl:shen.hat)) (simple-error "line read aborted")) ((kl:element? V2991 (cons (kl:shen.newline) (cons (kl:shen.carriage-return) (quote ())))) (let ((Line (kl:compile (lambda (X) (kl:shen.<st_input> X)) V2992 (lambda (E) (quote shen.nextline))))) (let ((It (kl:shen.record-it V2992))) (if (or (eq? Line (quote shen.nextline)) (kl:empty? Line)) (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (kl:append V2992 (cons V2991 (quote ())))) (kl:_waspvm_at_p Line V2992))))) (#t (kl:shen.toplineread_loop (kl:shen.read-char-code (kl:stinput)) (if (kl:= V2991 -1) V2992 (kl:append V2992 (cons V2991 (quote ())))))))) (export shen.toplineread_loop) (quote shen.toplineread_loop))
(begin (register-function-arity (quote shen.hat) 0) (define (kl:shen.hat) 94) (export shen.hat) (quote shen.hat))
(begin (register-function-arity (quote shen.newline) 0) (define (kl:shen.newline) 10) (export shen.newline) (quote shen.newline))
(begin (register-function-arity (quote shen.carriage-return) 0) (define (kl:shen.carriage-return) 13) (export shen.carriage-return) (quote shen.carriage-return))
(begin (register-function-arity (quote tc) 1) (define (kl:tc V2998) (cond ((eq? (quote +) V2998) (kl:set (quote shen.*tc*) #t)) ((eq? (quote -) V2998) (kl:set (quote shen.*tc*) #f)) (#t (simple-error "tc expects a + or -")))) (export tc) (quote tc))
(begin (register-function-arity (quote shen.prompt) 0) (define (kl:shen.prompt) (if (assert-boolean (kl:value (quote shen.*tc*))) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "+) " (quote shen.a))) (kl:stoutput)) (kl:shen.prhush (string-append "\n\n(" (kl:shen.app (kl:length (kl:value (quote shen.*history*))) "-) " (quote shen.a))) (kl:stoutput)))) (export shen.prompt) (quote shen.prompt))
(begin (register-function-arity (quote shen.toplevel) 1) (define (kl:shen.toplevel V3000) (kl:shen.toplevel_evaluate V3000 (kl:value (quote shen.*tc*)))) (export shen.toplevel) (quote shen.toplevel))
(begin (register-function-arity (quote shen.find-past-inputs) 2) (define (kl:shen.find-past-inputs V3003 V3004) (let ((F (kl:shen.find V3003 V3004))) (if (kl:empty? F) (simple-error "input not found\n") F))) (export shen.find-past-inputs) (quote shen.find-past-inputs))
(begin (register-function-arity (quote shen.make-key) 2) (define (kl:shen.make-key V3007 V3008) (let ((Atom (car (kl:compile (lambda (X) (kl:shen.<st_input> X)) V3007 (lambda (E) (if (pair? E) (simple-error (string-append "parse error here: " (kl:shen.app E "\n" (quote shen.s)))) (simple-error "parse error\n"))))))) (if (assert-boolean (kl:integer? Atom)) (lambda (X) (kl:= X (kl:nth (+ Atom 1) (kl:reverse V3008)))) (lambda (X) (kl:shen.prefix? V3007 (kl:shen.trim-gubbins (kl:snd X))))))) (export shen.make-key) (quote shen.make-key))
(begin (register-function-arity (quote shen.trim-gubbins) 1) (define (kl:shen.trim-gubbins V3010) (cond ((and (pair? V3010) (kl:= (car V3010) (kl:shen.space))) (kl:shen.trim-gubbins (cdr V3010))) ((and (pair? V3010) (kl:= (car V3010) (kl:shen.newline))) (kl:shen.trim-gubbins (cdr V3010))) ((and (pair? V3010) (kl:= (car V3010) (kl:shen.carriage-return))) (kl:shen.trim-gubbins (cdr V3010))) ((and (pair? V3010) (kl:= (car V3010) (kl:shen.tab))) (kl:shen.trim-gubbins (cdr V3010))) ((and (pair? V3010) (kl:= (car V3010) (kl:shen.left-round))) (kl:shen.trim-gubbins (cdr V3010))) (#t V3010))) (export shen.trim-gubbins) (quote shen.trim-gubbins))
(begin (register-function-arity (quote shen.space) 0) (define (kl:shen.space) 32) (export shen.space) (quote shen.space))
(begin (register-function-arity (quote shen.tab) 0) (define (kl:shen.tab) 9) (export shen.tab) (quote shen.tab))
(begin (register-function-arity (quote shen.left-round) 0) (define (kl:shen.left-round) 40) (export shen.left-round) (quote shen.left-round))
(begin (register-function-arity (quote shen.find) 2) (define (kl:shen.find V3019 V3020) (cond ((null? V3020) (quote ())) ((and (pair? V3020) (assert-boolean (V3019 (car V3020)))) (cons (car V3020) (kl:shen.find V3019 (cdr V3020)))) ((pair? V3020) (kl:shen.find V3019 (cdr V3020))) (#t (kl:shen.f_error (quote shen.find))))) (export shen.find) (quote shen.find))
(begin (register-function-arity (quote shen.prefix?) 2) (define (kl:shen.prefix? V3034 V3035) (cond ((null? V3034) #t) ((and (pair? V3034) (and (pair? V3035) (kl:= (car V3035) (car V3034)))) (kl:shen.prefix? (cdr V3034) (cdr V3035))) (#t #f))) (export shen.prefix?) (quote shen.prefix?))
(begin (register-function-arity (quote shen.print-past-inputs) 3) (define (kl:shen.print-past-inputs V3047 V3048 V3049) (cond ((null? V3048) (quote _)) ((and (pair? V3048) (kl:not (V3047 (car V3048)))) (kl:shen.print-past-inputs V3047 (cdr V3048) (+ V3049 1))) ((and (pair? V3048) (kl:tuple? (car V3048))) (begin (kl:shen.prhush (kl:shen.app V3049 ". " (quote shen.a)) (kl:stoutput)) (begin (kl:shen.prbytes (kl:snd (car V3048))) (kl:shen.print-past-inputs V3047 (cdr V3048) (+ V3049 1))))) (#t (kl:shen.f_error (quote shen.print-past-inputs))))) (export shen.print-past-inputs) (quote shen.print-past-inputs))
(begin (register-function-arity (quote shen.toplevel_evaluate) 2) (define (kl:shen.toplevel_evaluate V3052 V3053) (cond ((and (pair? V3052) (and (pair? (cdr V3052)) (and (eq? (quote :) (car (cdr V3052))) (and (pair? (cdr (cdr V3052))) (and (null? (cdr (cdr (cdr V3052)))) (kl:= #t V3053)))))) (kl:shen.typecheck-and-evaluate (car V3052) (car (cdr (cdr V3052))))) ((and (pair? V3052) (pair? (cdr V3052))) (begin (kl:shen.toplevel_evaluate (cons (car V3052) (quote ())) V3053) (begin (kl:nl 1) (kl:shen.toplevel_evaluate (cdr V3052) V3053)))) ((and (pair? V3052) (and (null? (cdr V3052)) (kl:= #t V3053))) (kl:shen.typecheck-and-evaluate (car V3052) (kl:gensym (quote A)))) ((and (pair? V3052) (and (null? (cdr V3052)) (kl:= #f V3053))) (let ((Eval (kl:shen.eval-without-macros (car V3052)))) (kl:print Eval))) (#t (kl:shen.f_error (quote shen.toplevel_evaluate))))) (export shen.toplevel_evaluate) (quote shen.toplevel_evaluate))
(begin (register-function-arity (quote shen.typecheck-and-evaluate) 2) (define (kl:shen.typecheck-and-evaluate V3056 V3057) (let ((Typecheck (kl:shen.typecheck V3056 V3057))) (if (kl:= Typecheck #f) (simple-error "type error\n") (let ((Eval (kl:shen.eval-without-macros V3056))) (let ((Type (kl:shen.pretty-type Typecheck))) (kl:shen.prhush (kl:shen.app Eval (string-append " : " (kl:shen.app Type "" (quote shen.r))) (quote shen.s)) (kl:stoutput))))))) (export shen.typecheck-and-evaluate) (quote shen.typecheck-and-evaluate))
(begin (register-function-arity (quote shen.pretty-type) 1) (define (kl:shen.pretty-type V3059) (kl:shen.mult_subst (kl:value (quote shen.*alphabet*)) (kl:shen.extract-pvars V3059) V3059)) (export shen.pretty-type) (quote shen.pretty-type))
(begin (register-function-arity (quote shen.extract-pvars) 1) (define (kl:shen.extract-pvars V3065) (cond ((kl:shen.pvar? V3065) (cons V3065 (quote ()))) ((pair? V3065) (kl:union (kl:shen.extract-pvars (car V3065)) (kl:shen.extract-pvars (cdr V3065)))) (#t (quote ())))) (export shen.extract-pvars) (quote shen.extract-pvars))
(begin (register-function-arity (quote shen.mult_subst) 3) (define (kl:shen.mult_subst V3073 V3074 V3075) (cond ((null? V3073) V3075) ((null? V3074) V3075) ((and (pair? V3073) (pair? V3074)) (kl:shen.mult_subst (cdr V3073) (cdr V3074) (kl:subst (car V3073) (car V3074) V3075))) (#t (kl:shen.f_error (quote shen.mult_subst))))) (export shen.mult_subst) (quote shen.mult_subst))

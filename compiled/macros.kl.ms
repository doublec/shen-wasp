(module "compiled/macros.kl")
"Copyright (c) 2010-2015, Mark Tarver\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
(begin (register-function-arity (quote macroexpand) 1) (define (kl:macroexpand V690) (let ((Y (kl:shen.compose (kl:value (quote *macros*)) V690))) (if (kl:= V690 Y) V690 (kl:shen.walk (lambda (Z) (kl:macroexpand Z)) Y)))) (export macroexpand) (quote macroexpand))
(begin (register-function-arity (quote shen.error-macro) 1) (define (kl:shen.error-macro V692) (cond ((and (pair? V692) (and (eq? (quote error) (car V692)) (pair? (cdr V692)))) (cons (quote simple-error) (cons (kl:shen.mkstr (car (cdr V692)) (cdr (cdr V692))) (quote ())))) (#t V692))) (export shen.error-macro) (quote shen.error-macro))
(begin (register-function-arity (quote shen.output-macro) 1) (define (kl:shen.output-macro V694) (cond ((and (pair? V694) (and (eq? (quote output) (car V694)) (pair? (cdr V694)))) (cons (quote shen.prhush) (cons (kl:shen.mkstr (car (cdr V694)) (cdr (cdr V694))) (cons (cons (quote stoutput) (quote ())) (quote ()))))) ((and (pair? V694) (and (eq? (quote pr) (car V694)) (and (pair? (cdr V694)) (null? (cdr (cdr V694)))))) (cons (quote pr) (cons (car (cdr V694)) (cons (cons (quote stoutput) (quote ())) (quote ()))))) (#t V694))) (export shen.output-macro) (quote shen.output-macro))
(begin (register-function-arity (quote shen.make-string-macro) 1) (define (kl:shen.make-string-macro V696) (cond ((and (pair? V696) (and (eq? (quote make-string) (car V696)) (pair? (cdr V696)))) (kl:shen.mkstr (car (cdr V696)) (cdr (cdr V696)))) (#t V696))) (export shen.make-string-macro) (quote shen.make-string-macro))
(begin (register-function-arity (quote shen.input-macro) 1) (define (kl:shen.input-macro V698) (cond ((and (pair? V698) (and (eq? (quote lineread) (car V698)) (null? (cdr V698)))) (cons (quote lineread) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V698) (and (eq? (quote input) (car V698)) (null? (cdr V698)))) (cons (quote input) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V698) (and (eq? (quote read) (car V698)) (null? (cdr V698)))) (cons (quote read) (cons (cons (quote stinput) (quote ())) (quote ())))) ((and (pair? V698) (and (eq? (quote input+) (car V698)) (and (pair? (cdr V698)) (null? (cdr (cdr V698)))))) (cons (quote input+) (cons (car (cdr V698)) (cons (cons (quote stinput) (quote ())) (quote ()))))) ((and (pair? V698) (and (eq? (quote read-byte) (car V698)) (null? (cdr V698)))) (cons (quote read-byte) (cons (cons (quote stinput) (quote ())) (quote ())))) (#t V698))) (export shen.input-macro) (quote shen.input-macro))
(begin (register-function-arity (quote shen.compose) 2) (define (kl:shen.compose V701 V702) (cond ((null? V701) V702) ((pair? V701) (kl:shen.compose (cdr V701) ((car V701) V702))) (#t (kl:shen.f_error (quote shen.compose))))) (export shen.compose) (quote shen.compose))
(begin (register-function-arity (quote shen.compile-macro) 1) (define (kl:shen.compile-macro V704) (cond ((and (pair? V704) (and (eq? (quote compile) (car V704)) (and (pair? (cdr V704)) (and (pair? (cdr (cdr V704))) (null? (cdr (cdr (cdr V704)))))))) (cons (quote compile) (cons (car (cdr V704)) (cons (car (cdr (cdr V704))) (cons (cons (quote lambda) (cons (quote E) (cons (cons (quote if) (cons (cons (quote cons?) (cons (quote E) (quote ()))) (cons (cons (quote error) (cons "parse error here: ~S~%" (cons (quote E) (quote ())))) (cons (cons (quote error) (cons "parse error~%" (quote ()))) (quote ()))))) (quote ())))) (quote ())))))) (#t V704))) (export shen.compile-macro) (quote shen.compile-macro))
(begin (register-function-arity (quote shen.prolog-macro) 1) (define (kl:shen.prolog-macro V706) (cond ((and (pair? V706) (eq? (quote prolog?) (car V706))) (cons (quote let) (cons (quote NPP) (cons (cons (quote shen.start-new-prolog-process) (quote ())) (cons (let ((Calls (kl:shen.bld-prolog-call (quote NPP) (cdr V706)))) (let ((Vs (kl:shen.extract_vars (cdr V706)))) (let ((External (kl:shen.externally-bound (cdr V706)))) (let ((PrologVs (kl:difference Vs External))) (kl:shen.locally-bind-prolog-vs (quote NPP) PrologVs Calls))))) (quote ())))))) (#t V706))) (export shen.prolog-macro) (quote shen.prolog-macro))
(begin (register-function-arity (quote shen.externally-bound) 1) (define (kl:shen.externally-bound V712) (cond ((and (pair? V712) (and (eq? (quote receive) (car V712)) (and (pair? (cdr V712)) (null? (cdr (cdr V712)))))) (cdr V712)) ((pair? V712) (kl:union (kl:shen.externally-bound (car V712)) (kl:shen.externally-bound (cdr V712)))) (#t (quote ())))) (export shen.externally-bound) (quote shen.externally-bound))
(begin (register-function-arity (quote shen.locally-bind-prolog-vs) 3) (define (kl:shen.locally-bind-prolog-vs V730 V731 V732) (cond ((null? V731) V732) ((pair? V731) (cons (quote let) (cons (car V731) (cons (cons (quote shen.newpv) (cons V730 (quote ()))) (cons (kl:shen.locally-bind-prolog-vs V730 (cdr V731) V732) (quote ())))))) (#t (simple-error "implementation error inp locally-bind-prolog-vs")))) (export shen.locally-bind-prolog-vs) (quote shen.locally-bind-prolog-vs))
(begin (register-function-arity (quote shen.bld-prolog-call) 2) (define (kl:shen.bld-prolog-call V745 V746) (cond ((null? V746) #t) ((and (pair? V746) (eq? (quote !) (car V746))) (cons (quote cut) (cons #f (cons V745 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V745 (cdr V746)) (quote ()))) (quote ())))))) ((and (pair? V746) (and (pair? (car V746)) (and (eq? (quote when) (car (car V746))) (and (pair? (cdr (car V746))) (null? (cdr (cdr (car V746)))))))) (cons (quote fwhen) (cons (kl:shen.insert-deref (car (cdr (car V746))) V745) (cons V745 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V745 (cdr V746)) (quote ()))) (quote ())))))) ((and (pair? V746) (and (pair? (car V746)) (and (eq? (quote is) (car (car V746))) (and (pair? (cdr (car V746))) (and (pair? (cdr (cdr (car V746)))) (null? (cdr (cdr (cdr (car V746)))))))))) (cons (quote bind) (cons (car (cdr (car V746))) (cons (kl:shen.insert-deref (car (cdr (cdr (car V746)))) V745) (cons V745 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V745 (cdr V746)) (quote ()))) (quote ()))))))) ((and (pair? V746) (and (pair? (car V746)) (and (eq? (quote receive) (car (car V746))) (and (pair? (cdr (car V746))) (null? (cdr (cdr (car V746)))))))) (kl:shen.bld-prolog-call V745 (cdr V746))) ((and (pair? V746) (and (pair? (car V746)) (and (eq? (quote bind) (car (car V746))) (and (pair? (cdr (car V746))) (and (pair? (cdr (cdr (car V746)))) (null? (cdr (cdr (cdr (car V746)))))))))) (cons (quote bind) (cons (car (cdr (car V746))) (cons (kl:shen.insert-lazyderef (car (cdr (cdr (car V746)))) V745) (cons V745 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V745 (cdr V746)) (quote ()))) (quote ()))))))) ((and (pair? V746) (and (pair? (car V746)) (and (eq? (quote fwhen) (car (car V746))) (and (pair? (cdr (car V746))) (null? (cdr (cdr (car V746)))))))) (cons (quote fwhen) (cons (kl:shen.insert-lazyderef (car (cdr (car V746))) V745) (cons V745 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V745 (cdr V746)) (quote ()))) (quote ())))))) ((pair? V746) (kl:append (car V746) (cons V745 (cons (cons (quote freeze) (cons (kl:shen.bld-prolog-call V745 (cdr V746)) (quote ()))) (quote ()))))) (#t (simple-error "implementation error in bld-prolog-call")))) (export shen.bld-prolog-call) (quote shen.bld-prolog-call))
(begin (register-function-arity (quote shen.defprolog-macro) 1) (define (kl:shen.defprolog-macro V748) (cond ((and (pair? V748) (and (eq? (quote defprolog) (car V748)) (pair? (cdr V748)))) (kl:compile (lambda (Y) (kl:shen.<defprolog> Y)) (cdr V748) (lambda (Y) (kl:shen.prolog-error (car (cdr V748)) Y)))) (#t V748))) (export shen.defprolog-macro) (quote shen.defprolog-macro))
(begin (register-function-arity (quote shen.datatype-macro) 1) (define (kl:shen.datatype-macro V750) (cond ((and (pair? V750) (and (eq? (quote datatype) (car V750)) (pair? (cdr V750)))) (cons (quote shen.process-datatype) (cons (kl:shen.intern-type (car (cdr V750))) (cons (cons (quote compile) (cons (cons (quote lambda) (cons (quote X) (cons (cons (quote shen.<datatype-rules>) (cons (quote X) (quote ()))) (quote ())))) (cons (kl:shen.rcons_form (cdr (cdr V750))) (cons (cons (quote function) (cons (quote shen.datatype-error) (quote ()))) (quote ()))))) (quote ()))))) (#t V750))) (export shen.datatype-macro) (quote shen.datatype-macro))
(begin (register-function-arity (quote shen.intern-type) 1) (define (kl:shen.intern-type V752) (kl:intern (string-append (kl:str V752) "#type"))) (export shen.intern-type) (quote shen.intern-type))
(begin (register-function-arity (quote shen._waspvm_at_s-macro) 1) (define (kl:shen._waspvm_at_s-macro V754) (cond ((and (pair? V754) (and (eq? (quote _waspvm_at_s) (car V754)) (and (pair? (cdr V754)) (and (pair? (cdr (cdr V754))) (pair? (cdr (cdr (cdr V754)))))))) (cons (quote _waspvm_at_s) (cons (car (cdr V754)) (cons (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (cdr (cdr V754)))) (quote ()))))) ((and (pair? V754) (and (eq? (quote _waspvm_at_s) (car V754)) (and (pair? (cdr V754)) (and (pair? (cdr (cdr V754))) (and (null? (cdr (cdr (cdr V754)))) (string? (car (cdr V754)))))))) (let ((E (kl:explode (car (cdr V754))))) (if (> (kl:length E) 1) (kl:shen._waspvm_at_s-macro (cons (quote _waspvm_at_s) (kl:append E (cdr (cdr V754))))) V754))) (#t V754))) (export shen._waspvm_at_s-macro) (quote shen._waspvm_at_s-macro))
(begin (register-function-arity (quote shen.synonyms-macro) 1) (define (kl:shen.synonyms-macro V756) (cond ((and (pair? V756) (eq? (quote synonyms) (car V756))) (cons (quote shen.synonyms-help) (cons (kl:shen.rcons_form (kl:shen.curry-synonyms (cdr V756))) (quote ())))) (#t V756))) (export shen.synonyms-macro) (quote shen.synonyms-macro))
(begin (register-function-arity (quote shen.curry-synonyms) 1) (define (kl:shen.curry-synonyms V758) (kl:map (lambda (X) (kl:shen.curry-type X)) V758)) (export shen.curry-synonyms) (quote shen.curry-synonyms))
(begin (register-function-arity (quote shen.nl-macro) 1) (define (kl:shen.nl-macro V760) (cond ((and (pair? V760) (and (eq? (quote nl) (car V760)) (null? (cdr V760)))) (cons (quote nl) (cons 1 (quote ())))) (#t V760))) (export shen.nl-macro) (quote shen.nl-macro))
(begin (register-function-arity (quote shen.assoc-macro) 1) (define (kl:shen.assoc-macro V762) (cond ((and (pair? V762) (and (pair? (cdr V762)) (and (pair? (cdr (cdr V762))) (and (pair? (cdr (cdr (cdr V762)))) (kl:element? (car V762) (cons (quote _waspvm_at_p) (cons (quote _waspvm_at_v) (cons (quote append) (cons (quote and) (cons (quote or) (cons (quote +) (cons (quote *) (cons (quote do) (quote ())))))))))))))) (cons (car V762) (cons (car (cdr V762)) (cons (kl:shen.assoc-macro (cons (car V762) (cdr (cdr V762)))) (quote ()))))) (#t V762))) (export shen.assoc-macro) (quote shen.assoc-macro))
(begin (register-function-arity (quote shen.let-macro) 1) (define (kl:shen.let-macro V764) (cond ((and (pair? V764) (and (eq? (quote let) (car V764)) (and (pair? (cdr V764)) (and (pair? (cdr (cdr V764))) (and (pair? (cdr (cdr (cdr V764)))) (pair? (cdr (cdr (cdr (cdr V764)))))))))) (cons (quote let) (cons (car (cdr V764)) (cons (car (cdr (cdr V764))) (cons (kl:shen.let-macro (cons (quote let) (cdr (cdr (cdr V764))))) (quote ())))))) (#t V764))) (export shen.let-macro) (quote shen.let-macro))
(begin (register-function-arity (quote shen.abs-macro) 1) (define (kl:shen.abs-macro V766) (cond ((and (pair? V766) (and (eq? (quote /.) (car V766)) (and (pair? (cdr V766)) (and (pair? (cdr (cdr V766))) (pair? (cdr (cdr (cdr V766)))))))) (cons (quote lambda) (cons (car (cdr V766)) (cons (kl:shen.abs-macro (cons (quote /.) (cdr (cdr V766)))) (quote ()))))) ((and (pair? V766) (and (eq? (quote /.) (car V766)) (and (pair? (cdr V766)) (and (pair? (cdr (cdr V766))) (null? (cdr (cdr (cdr V766)))))))) (cons (quote lambda) (cdr V766))) (#t V766))) (export shen.abs-macro) (quote shen.abs-macro))
(begin (register-function-arity (quote shen.cases-macro) 1) (define (kl:shen.cases-macro V770) (cond ((and (pair? V770) (and (eq? (quote cases) (car V770)) (and (pair? (cdr V770)) (and (kl:= #t (car (cdr V770))) (pair? (cdr (cdr V770))))))) (car (cdr (cdr V770)))) ((and (pair? V770) (and (eq? (quote cases) (car V770)) (and (pair? (cdr V770)) (and (pair? (cdr (cdr V770))) (null? (cdr (cdr (cdr V770)))))))) (cons (quote if) (cons (car (cdr V770)) (cons (car (cdr (cdr V770))) (cons (cons (quote simple-error) (cons "error: cases exhausted" (quote ()))) (quote ())))))) ((and (pair? V770) (and (eq? (quote cases) (car V770)) (and (pair? (cdr V770)) (pair? (cdr (cdr V770)))))) (cons (quote if) (cons (car (cdr V770)) (cons (car (cdr (cdr V770))) (cons (kl:shen.cases-macro (cons (quote cases) (cdr (cdr (cdr V770))))) (quote ())))))) ((and (pair? V770) (and (eq? (quote cases) (car V770)) (and (pair? (cdr V770)) (null? (cdr (cdr V770)))))) (simple-error "error: odd number of case elements\n")) (#t V770))) (export shen.cases-macro) (quote shen.cases-macro))
(begin (register-function-arity (quote shen.timer-macro) 1) (define (kl:shen.timer-macro V772) (cond ((and (pair? V772) (and (eq? (quote time) (car V772)) (and (pair? (cdr V772)) (null? (cdr (cdr V772)))))) (kl:shen.let-macro (cons (quote let) (cons (quote Start) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Result) (cons (car (cdr V772)) (cons (quote Finish) (cons (cons (quote get-time) (cons (quote run) (quote ()))) (cons (quote Time) (cons (cons (quote -) (cons (quote Finish) (cons (quote Start) (quote ())))) (cons (quote Message) (cons (cons (quote shen.prhush) (cons (cons (quote cn) (cons "\nrun time: " (cons (cons (quote cn) (cons (cons (quote str) (cons (quote Time) (quote ()))) (cons " secs\n" (quote ())))) (quote ())))) (cons (cons (quote stoutput) (quote ())) (quote ())))) (cons (quote Result) (quote ()))))))))))))))) (#t V772))) (export shen.timer-macro) (quote shen.timer-macro))
(begin (register-function-arity (quote shen.tuple-up) 1) (define (kl:shen.tuple-up V774) (cond ((pair? V774) (cons (quote _waspvm_at_p) (cons (car V774) (cons (kl:shen.tuple-up (cdr V774)) (quote ()))))) (#t V774))) (export shen.tuple-up) (quote shen.tuple-up))
(begin (register-function-arity (quote shen.put/get-macro) 1) (define (kl:shen.put/get-macro V776) (cond ((and (pair? V776) (and (eq? (quote put) (car V776)) (and (pair? (cdr V776)) (and (pair? (cdr (cdr V776))) (and (pair? (cdr (cdr (cdr V776)))) (null? (cdr (cdr (cdr (cdr V776)))))))))) (cons (quote put) (cons (car (cdr V776)) (cons (car (cdr (cdr V776))) (cons (car (cdr (cdr (cdr V776)))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ()))))))) ((and (pair? V776) (and (eq? (quote get) (car V776)) (and (pair? (cdr V776)) (and (pair? (cdr (cdr V776))) (null? (cdr (cdr (cdr V776)))))))) (cons (quote get) (cons (car (cdr V776)) (cons (car (cdr (cdr V776))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) ((and (pair? V776) (and (eq? (quote unput) (car V776)) (and (pair? (cdr V776)) (and (pair? (cdr (cdr V776))) (null? (cdr (cdr (cdr V776)))))))) (cons (quote unput) (cons (car (cdr V776)) (cons (car (cdr (cdr V776))) (cons (cons (quote value) (cons (quote *property-vector*) (quote ()))) (quote ())))))) (#t V776))) (export shen.put/get-macro) (quote shen.put/get-macro))
(begin (register-function-arity (quote shen.function-macro) 1) (define (kl:shen.function-macro V778) (cond ((and (pair? V778) (and (eq? (quote function) (car V778)) (and (pair? (cdr V778)) (null? (cdr (cdr V778)))))) (kl:shen.function-abstraction (car (cdr V778)) (kl:arity (car (cdr V778))))) (#t V778))) (export shen.function-macro) (quote shen.function-macro))
(begin (register-function-arity (quote shen.function-abstraction) 2) (define (kl:shen.function-abstraction V781 V782) (cond ((kl:= 0 V782) (simple-error (kl:shen.app V781 " has no lambda form\n" (quote shen.a)))) ((kl:= -1 V782) (cons (quote function) (cons V781 (quote ())))) (#t (kl:shen.function-abstraction-help V781 V782 (quote ()))))) (export shen.function-abstraction) (quote shen.function-abstraction))
(begin (register-function-arity (quote shen.function-abstraction-help) 3) (define (kl:shen.function-abstraction-help V786 V787 V788) (cond ((kl:= 0 V787) (cons V786 V788)) (#t (let ((X (kl:gensym (quote V)))) (cons (quote /.) (cons X (cons (kl:shen.function-abstraction-help V786 (- V787 1) (kl:append V788 (cons X (quote ())))) (quote ())))))))) (export shen.function-abstraction-help) (quote shen.function-abstraction-help))
(begin (register-function-arity (quote undefmacro) 1) (define (kl:undefmacro V790) (let ((MacroReg (kl:value (quote shen.*macroreg*)))) (let ((Pos (kl:shen.findpos V790 MacroReg))) (let ((Remove1 (kl:set (quote shen.*macroreg*) (kl:remove V790 MacroReg)))) (let ((Remove2 (kl:set (quote *macros*) (kl:shen.remove-nth Pos (kl:value (quote *macros*)))))) V790))))) (export undefmacro) (quote undefmacro))
(begin (register-function-arity (quote shen.findpos) 2) (define (kl:shen.findpos V800 V801) (cond ((null? V801) (simple-error (kl:shen.app V800 " is not a macro\n" (quote shen.a)))) ((and (pair? V801) (kl:= (car V801) V800)) 1) ((pair? V801) (+ 1 (kl:shen.findpos V800 (cdr V801)))) (#t (kl:shen.f_error (quote shen.findpos))))) (export shen.findpos) (quote shen.findpos))
(begin (register-function-arity (quote shen.remove-nth) 2) (define (kl:shen.remove-nth V806 V807) (cond ((and (kl:= 1 V806) (pair? V807)) (cdr V807)) ((pair? V807) (cons (car V807) (kl:shen.remove-nth (- V806 1) (cdr V807)))) (#t (kl:shen.f_error (quote shen.remove-nth))))) (export shen.remove-nth) (quote shen.remove-nth))
